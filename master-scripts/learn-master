#!/bin/bash

# This file is part of the "learn-unix-scripts" project.
#
# The "learn-unix-scripts" project is free software: you can redistribute it and/or modify it under the terms of the GNU
# General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# The "learn-unix-scripts" project is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with this project; if not, write to the
# Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA, 02111-1307, USA.
#
# Copyright (C) 2021 Christopher Evans

# This script was developed in a 130x30 terminal.

# replace start 1acc396a-02a2-40b8-a427-f4685c20320e (see below for what this line does)
#
# This script is the master script for the learn script.  If you have site-specific changes that you don't want to share,
# you can add a GUID in this script and use the "replace" script to merge this script with your site-specific changes
# (in learn-replace) and create a site-specific learn script.  You can insert or replace portions of this code.
#
# If we didn't replace this text when we created the learn script, it would seem as though people should be making the changes
# to the learn script and not this one.  See the replacement for 1acc396a-02a2-40b8-a427-f4685c20320e in learn-replace for more.
#
# Insert exercises or elements that are specific to your site with "# insert <GUID>".  If you put a space after the GUID,
# you can add comments.  Replace parts with "# replace start <GUID>" and "# replace end <GUID>".  To remove sections,
# replace the content with nothing.  Put the replacements in the learn-replace file.
#
# replace end 1acc396a-02a2-40b8-a427-f4685c20320e

# Setting nounset is worth having to sometimes reference variables as ${VAR:-}.
set -e -o nounset

# insert 17fa07e6-24b8-4e35-bc1a-094427fd8699 xterm fix

# insert 7437f7c8-c360-4f96-91f6-b75dcd3b8cd7

if [ `whoami` == "root" ]; then
	echo "Run this script as yourself, not the root user.  (Don't use dzdo or sudo.)"
	exit 1
fi

less_prompt_move_on="Press h for help;?e: Enter for more (line %lb of %L).?e q to move on."
less_prompt_quit="Press h for help;?e: Enter for more (line %lb of %L).?e q to quit."

file_clean_up_array=()

clean_up() {
	if [ -n "${file_clean_up_array:-}" ]; then
		for item in $file_clean_up_array; do
			rm -f $item
		done
	fi
}

# It's a trap!  Run the clean_up subroutine on normal or aborted exit.
trap clean_up EXIT

# insert 1a88ef09-bbc8-4f7e-ac03-a1849fd03166 stty options

# insert ffa9e74e-2b02-4d72-9c82-9f9db2915c62 associative arrays for exercises and belt levels

get_rows_and_columns() {
	STTY_ROWS=`stty ${stty_options} | grep -Po "(?<=rows )[0-9]*(?=;)"`
	STTY_COLUMNS=`stty ${stty_options} | grep -Po "(?<=columns )[0-9]*(?=;)"`
	if (($STTY_ROWS > 50)); then
		WIDTH=`expr $STTY_COLUMNS - 5`
	else
		WIDTH=$STTY_COLUMNS
	fi
}

get_rows_and_columns

resize_to_default() {
	printf "\033[s\033[8;24;80t\033[u"

	echo -n "Resizing..."
	sleep 1

	get_rows_and_columns

	if (($STTY_ROWS < 24)) || (($STTY_COLUMNS < 80)); then
		fmt -u --width=$WIDTH <<EOL
It looks like the automatic resize didn't work.  Continue anyway (y/N)?
EOL

		if [[ ! "$CHOICE" =~ ^\s*[Yy].* ]]; then
			exit 1
		fi
	fi
}

# The following function deals with matters relating to the terminal size.
size_matters() {
	get_rows_and_columns

	# PuTTY uses a default size of 80x24, though 80x25 tends to be more of a standard (because of VT100 terminals).
	standard_rows=0
	if [ "$STTY_ROWS" == 24 ] || [ "$STTY_ROWS" == 25 ]; then
		standard_rows=1
	fi

	if [ "$STTY_COLUMNS" == 80 ] && [ "$standard_rows" -eq "1" ] && [ -z "${RESIZED_ALREADY:-}" ]; then
		fmt -u --width=$WIDTH <<EOL
It looks like your terminal is set to the default size of 80 columns and $STTY_ROWS rows.  This script is capable of
using more.  If you're able to change the size of the terminal, please do so, then press Enter to continue.
EOL

		echo ""
		read

		get_rows_and_columns

		if (("$STTY_COLUMNS" < "80")) || (("$STTY_ROWS" < 24)); then
			fmt -u --width=$WIDTH <<EOL
Oh!  A wise guy!  How about we change that back to the default (Y/y)?
EOL

			read CHOICE

			# We already know the terminal can support 80x24.  Time for a bit of fun.
			if [ -n "${CHOICE:-}" ] && [[ ! "${CHOICE:-}" =~ ^\s*[Yy].* ]]; then
				echo "That's a funny way to spell it but that will do just fine."
			fi

			resize_to_default
			echo ""
		else
			TERM_SIZE="${STTY_COLUMNS}x$STTY_ROWS"

			FMT_STRING=""

			if (("$STTY_COLUMNS" >= "200")) && (("$STTY_ROWS" >= 40)); then
				FMT_STRING="What, $TERM_SIZE?!  Seriously?  Now you're just showing off."
			elif (("$STTY_COLUMNS" >= "170")) && (("$STTY_ROWS" >= 35)); then
				FMT_STRING="Wow, $TERM_SIZE?  Luxurious!  There's plenty of room now."
			elif (("$STTY_COLUMNS" >= "130")) && (("$STTY_ROWS" >= 30)); then
				FMT_STRING="Wow, $TERM_SIZE?  Very spacious!"
			elif (("$STTY_COLUMNS" >= "120")) && (("$STTY_ROWS" >= 30)); then
				FMT_STRING="OK, $TERM_SIZE.  That's very respectable."
			elif (("$STTY_COLUMNS" >= "120")) && (("$STTY_ROWS" >= 25)); then
				FMT_STRING="Alright, $TERM_SIZE.  That will do just fine."
			fi	

			if [ -n "${FMT_STRING:-}" ]; then
				fmt -u --width=$WIDTH <<EOL
$FMT_STRING
EOL
			fi

			echo ""
		fi
	fi
}

# Run "grep" on this file and pipe it to "wc" to count the number of exercises for the current belt.
set_num_exercises() {
	regex="'"
	regex+="${RANK}_exercise_.*\(\)"
	regex+="'"
	NUM_EXERCISES=$(bash -c "grep -E ${regex} ~/bin/learn | wc -l")
}

set_num_exercises_for_review() {
	regex="'"
	regex+="${new_rank}_exercise_.*\(\)"
	regex+="'"
	NUM_REVIEW_EXERCISES=$(bash -c "grep -E ${regex} ~/bin/learn | wc -l")
}

print_rank() {
	# Use an extra ${nc} to fix an issue with PuTTY.
	if [ -n "${SAVED_RANK:-}" ]; then
		if [ "$SAVED_RANK" == "white_belt" ]; then
			printf "Your current rank is `getBeltWithColours white_belt`.\n"
			printf "You are working toward your `getBeltWithColours yellow_stripe`.\n\n"
		elif [ "$SAVED_RANK" == "yellow_stripe" ]; then
			printf "Your current rank is `getBeltWithColours yellow_stripe`.\n"
			printf "You are working toward your `getBeltWithColours yellow_belt`.\n\n"
		elif [ "$SAVED_RANK" == "yellow_belt" ]; then
			printf "Your current rank is `getBeltWithColours yellow_belt`.\n"
			printf "You are working toward your `getBeltWithColours green_stripe`.\n\n"
		fi

		belt=$(getBeltWithColours $RANK)
		printf "You are reviewing the exercises for ${belt}.  "
		printf 'To return to where you were, execute "learn --return".\n\n'
	else
		if [ "$RANK" == "white_belt" ]; then
			printf "Your current rank is `getBeltWithColours white_belt`.\n"
			printf "You are working toward your `getBeltWithColours yellow_stripe`.\n\n"
		elif [ "$RANK" == "yellow_stripe" ]; then
			printf "Your current rank is `getBeltWithColours yellow_stripe`.\n"
			printf "You are working toward your `getBeltWithColours yellow_belt`.\n\n"
		elif [ "$RANK" == "yellow_belt" ]; then
			printf "Your current rank is `getBeltWithColours yellow_belt`.\n"
			printf "You are working toward your `getBeltWithColours green_stripe`.\n\n"
		fi
	fi
}

complete_exercise() {
	less -R -P "$less_prompt_quit" $fmt_file

	# Print the exercise (or the last part of the exercise) to the terminal.  Since "less" cleans up after itself, if we
	# don't do this, the user has nothing to reference to finish the task.
	cat $fmt_file
}

# insert 37333148-8746-4468-826e-544e532f1ebc updateDotFile, getBeltWithColours

prepareLusHome() {
	if [[ "${INSIDE_DOCKER:-0}" == "0" ]]; then
		if [ ! -d $LUS_HOME ]; then
			mkdir $LUS_HOME
		fi
	else
		if [ ! -d "$LUS_DOCKER_BASE/lus" ]; then
			mkdir $LUS_DOCKER_BASE/lus
		fi
	fi
}

white_belt_exercise_what_execute_means() { # What "Execute" Means
	yellow_stripe="${yellow_on_black}yellow ${nc}${bright_white_on_black}stripe${nc}"
	printf "${underline}The Bare Essentials${no_underline}\n\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
In the United States and Canada, grammar rules say to put the period inside the double quotes.

    He told me, "You need to go to the store."

We will follow https://en.wikipedia.org/wiki/Quotation_marks_in_English#Logical_quotation
rules (also called British practice, British style, and logical punctuation).

If this script says to execute "set", that means to type the letters s, e, t, and press Enter.  Don't type the double quotes.

If an exercise asks you to execute "scp bcompcd101:/tmp/file.txt ." then the space and dot at the end, before the final
double quote, are important and must be typed before pressing Enter.

At the end of a sentence, you will see: "scp bcompcd101:/tmp/file.txt .".

To see the overview of what is covered in each belt, execute "learn --welcome".

The exerices leading to your yellow stripe will have more reading and rote completion.  As you rise through the ranks,
fewer steps will be directly stated.  This script will provide resources for you to reference to finish the exercises.
In particular, this exercise has the most reading and the least to do.
EOL

	printf "\n\n${underline}Your Prompt${no_underline}\n\n" >> $fmt_file
	x="$(PS1=\"$PS1\" echo -n | bash -i 2>&1)"
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
Your current prompt is as follows.

${x%exit}

When you see your prompt, that means that the previous commands have completed and your shell is ready for another command.
(We'll be going into more detail on shells later.)  Prompts are one of the most heavily customized aspects of Unix, ranging
from a simple dollar sign to multi-line creations.  You should expect your prompt to look similar across different computers
(or hosts) run by the same people, but different as you move elsewhere.
EOL

	printf "\n\n${underline}I'm Stuck!${no_underline}\n\n" >> $fmt_file
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
It's always a good idea to take notes, because it helps with recall.  But there a few things this script will specifically
call out for you to make a note of, things you're always going to want to have handy.  Take them down in whatever style you
like (Evernote, a personal wiki, on your phone, Microsoft OneNote, a mind map, or good old pen and paper) but make sure it
will be available whenever you're at a Unix terminal.

Characters include letters, numbers, and punctuation.  Space is a character.  There are non-printable characters like
tab, carriage return, and Ctrl+a through Ctrl+z.  We're not going to get into Chinese, Japanese, and Korean, where things
are even more complicated.

Your interrupt character is Ctrl+c (don't type it now, but in order to type it, hold one of the Ctrl keys down and press
the "c" key.  Do not use either Shift key.)  There are only a few cases where typing Ctrl+c will not stop what's happening
and return you to a prompt.  We will be covering two of these soon.  Make a note of it.

For now, it's a good thing that Ctrl+c will get you out of most situations.  Later, you will learn to be more careful
about using Ctrl+c, and you will learn other things you might want to try first.

EOL

	printf "\n\n${underline}Moving On${no_underline}\n\n" >> $fmt_file
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
After reading the text for each exercise, you will need to
quit the lesson by pressing "q" (which will return you to your prompt).  You can then complete anything the exercise asked
you to do.

Your first task is to execute ". check".
EOL

	complete_exercise
}

white_belt_exercise_stuck() { # Freezing and Unfreezing the Terminal
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The first thing you don't want to be caught by is Ctrl+q and Ctrl+s.  If you accidentally type Ctrl and "s", the terminal will
freeze.  Ctrl+s is easy to type and is in common use in Windows programs as a keyboard shortcut for saving the current file.
Depending on your background, it may be second nature to you to type it when you want to save something.

If you find that your terminal is locked, frozen, or in a weird state, the first thing you should do is type Ctrl+c.
The second thing you should try is typing Ctrl+q (Ctrl with a lowercase "q", or equivalently:  Ctrl and "q" but not
including shift).

Ctrl+q and Ctrl+s are holdovers of an ancient age when it was more common to print output to a printer than a screen.
Printers were much slower and needed time to catch up.  These continued to be used with displays to freeze the screen so
that users could read something that was quickly scrolling by.  Ctrl+q and Ctrl+s can still be used that way, but there are
generally better options available now that allow programs to continue to run while the user is looking at something.

Please make a note of these now.  There will be a question later about it.  (The history lesson is not on the test.)

Execute ". check".
EOL

	complete_exercise
}

white_belt_exercise_cd_root() { # The Root Directory
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
Now that you know how to recover from your terminal getting frozen and how to get a prompt back, you need to know how to
navigate.

All files and directories have a path which tells the operating system how to retrieve them.  You may be familiar with
Microsoft Windows-style paths such as C:\\Windows\\System\\.  When you insert a USB drive, Windows usually assigns the drive
letter E: to the new disk, unless it's already taken.  Unix doesn't have drive letters.  Instead, all disks (local disks,
shared drives, and removeable disks) are in one unified filesystem.  In a future exercise, we'll look at how data is brought
in from shared and removeable drives.

In Unix, paths use forward slashes ( / ) instead of backslashes.  The path to your home directory is $HOME.  Your home
directory contains everything that's only for you.  It will be mostly configuration settings, but more generally,
anything you're working on that isn't shared with other users will be in $HOME.

You may have a $HOME/bin directory for programs that are only for you.  There are multiple directories called "bin" on a
Unix system.  The one in your home directory contains programs (compiled binaries, scripts, and anything else that can
be run) for your use only.  For example, some people set up a particular version of a common program that has different
features.  You may want to have scripts that automate certain tasks that are too specific for other users to use, and
they should go in $HOME/bin.

Windows usually uses the term "folder" as an equivalent term for "directory".

When you ran this script, you were in the `pwd` directory.

Let's begin at the beginning:  the root directory.  (Not to be confused with the /root directory.)
EOL

	echo >> $fmt_file
	echo 'Execute "cd /".' >> $fmt_file
	echo 'Then execute ". check"' >> $fmt_file

	less -R -P "$less_prompt_move_on" $fmt_file

	# Print the exercise to the terminal to retain context.
	cat $fmt_file
}

white_belt_exercise_ls_root() { # What Does the Root Look Like?
	# If the user is coming back after needing to look at something else, they may now be in another directory.
	if [[ `pwd` == "/" ]]; then
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
It's time to take a look around.  Execute "ls", read the names of the directories, and execute ". check".
EOL
	else
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
It's time to take a look around.  Execute "cd /", execute "ls", read the names of the directories, and execute ". check".
EOL
	fi

	complete_exercise
}

white_belt_exercise_common_root_directories() { # Explanation of Directories Under Root
	# The existence of /opt can't be counted on, but it's hard to imagine the rest would be missing on any modern
	# Unix derivative.  Maybe this script is being run in a Docker container.  Handling missing directories, formatting
	# to the TTY size, and paging the whole thing was a chance to sharpen my skills.
	# It's also a good reference for redirecting output from a program that already has a heredoc coming in.

	set +e
	ROOT_USERNAME=$(bash -c 'getent passwd "0" 2> /dev/null | cut -d: -f1')
	set -e
	ROOT_TEXT=""

	if [ -n "${ROOT_USERNAME:-}" ] && [ "$ROOT_USERNAME" != "root" ]; then
		ROOT_TEXT="On this system, the administrator account is called $ROOT_USERNAME."
	fi

	# $ROOT_TEXT should be at the end of the line so the formatting works out.
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
For the following notes, keep in mind that the root user (usually simply called "root") is the administrator account.  $ROOT_TEXT
The root user has access to everything and is allowed to do everything, unless permissions have been deliberately given up.
A simple example is making a file read only.  The root user can put up blocks to make things more difficult to do, but the
root user could remove them at any time.
EOL

	printf "\nHere are some of the things you saw.\n" >> $fmt_file

	if [ -d "/bin" ]; then
		printf "\n${underline}/bin${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Stands for BINaries (programs that aren't scripts).  The core binaries are here, like "ls". 
EOL
	fi

	if [ -d "/etc" ]; then
		printf "\n${underline}/etc${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  You'll find all system wide configuration here.
EOL
	fi

	if [ -d "/home" ]; then
		printf "\n${underline}/home${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Each user's home directory is under here.  Your home directory (${HOME}) contains everything that's only for you,
  especially configuration files.  In most Unix enviroments, your home directory is shared across multiple servers so your
  configuration settings are available across multiple servers.  On Macs, this directory (if it exists) will usually be
  empty, and all the users' home directories will be in /Users instead.
EOL
	fi

	if [ -d "/opt" ]; then
		printf "\n${underline}/opt${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Sometimes seen on Red Hat Linux servers, the /opt directory is for OPTional software that's not part of the distribution.
  (If you want, you can look up what a Linux distribution is.)  You might find an Oracle DB instance or a Dynatrace OneAgent
  installed here.
EOL
	fi

	if [ -d "/root" ]; then
		printf "\n${underline}/root${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  The root user's home directory (set aside for the root user's personal use).  Depending on the installation, the /root
  directory can sometimes be used in emergencies if other parts of the filesystem are full.
EOL
	fi

	if [ -d "/sbin" ]; then
		printf "\n${underline}/sbin${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Stands for Secure BINaries.  Binary programs (not scripts) that are run only by privileged users go here.  For example,
  the programs that change network configurations are here, as well as programs for other system maintenance and starting up the
  operating system.
EOL
	fi

	if [ -d "/tmp" ]; then
		printf "\n${underline}/tmp${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Short for TeMP, this directory is where any temporary files are created.  Well-behaved programs should clean up after
  themselves.  Most systems are configured to delete any files that haven't been modified in a week (two weeks is also common).
EOL
	fi

	if [ -d "/Users" ]; then
		printf "\n${underline}/Users${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Each user's home directory is under here.  On most flavors of Unix, home directories are under /home instead.
  Your home directory ($HOME) contains everything that's only for you, particularly configuration files.  In most
  Unix enviroments, your home directory is shared across multiple servers so your configuration settings are available
  across multiple servers.
EOL
	fi

	if [ -d "/usr" ]; then
		printf "\n${underline}/usr${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Short for "user", i.e. for "regular" users and not the root user.  Most programs are under here somewhere (/usr/bin,
  /usr/local/bin, /usr/sbin, /usr/local/sbin).
EOL
	fi

	if [ -d "/var" ]; then
		printf "\n${underline}/var${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Short for VARiable, this directory is for things that are constantly changing, particularly:  log files, caches, mail, and
  printer queues.
EOL
	fi

	echo "" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
For a full list, see https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard.

EOL
	

	if [[ `pwd` == "$HOME" ]]; then
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
This exercise was going to ask you to go back to your home directory, but you're already there.  Use the "cd" command to
change directory to somewhere else (like "cd /").  You can any one of the following commands to return to your home directory.
Then execute ". check".
EOL
	else
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
Let's return to your home directory.  The following commands are equivalent.  Execute one of them, then execute ". check".
EOL
	fi

	echo "" >> $fmt_file
	echo "cd" >> $fmt_file
	echo "cd ~" >> $fmt_file
	echo "cd $HOME" >> $fmt_file
	echo "cd ${HOME}/" >> $fmt_file

	complete_exercise
}

white_belt_exercise_set() { # The "set" Command
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
There are four ways to pass settings to programs:  environment variables, arguments, standard input, and configuration files.

We will be looking at environment variables next.  The "set" command will show you the current environment variables.
If you run it as is, most of the output will scroll past, but go ahead anyway and execute "set".

Remember to execute ". check" after.
EOL

	complete_exercise
}

white_belt_exercise_frozen() { # The First Test
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
It's time for the first test.  Make sure your notes are handy and execute ". check".
EOL

	complete_exercise
}

white_belt_exercise_set_more() { # The "more" Command
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
To go page by page, add "| more" to a command.  The pipe ( | ) can be used to send the output of one command to the input
of another command.  We'll be going into more detail on pipes later.  The pipe character is rarely used outside
of technical fields.  On many keyboard layouts, you can type it with Shift+Backslash.

When you execute "set | more", you will be able to move a page at a time by pressing Space.  Move a line at a time by
pressing Enter.  To quit before the end, press "q".  With some flavours of Unix, if you quit before the end, you will see
a warning about a broken pipe.  Execute "set | more" now and remember to execute ". check" after.
EOL

	complete_exercise
}

white_belt_exercise_set_less() { # The "less" Command
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The "more" command will only give you more.  If you want to back up, add "| less" to a command.  In many cases (but depending
on your terminal settings) you will be able to move up and down with the cursor keys and use the Page Up and Page Down keys.
As before, Space will go a page forward, Enter will show one more line, and "q" will quit.

Most commands will quit when you type Ctrl+c, but "less" doesn't quit by default with Ctrl+c.  When you press Ctrl+c in
"less", it will stop whatever you're doing within "less".  For example, when you have "less" open you can search
for something, which might take a long time if it's a big file.  You can stop the search by pressing Ctrl+c.  You will need
to press "q" to quit.  Take a note.  If you miss it, you will be stuck, just as with Ctrl+s.

Execute "set | less" and remember to execute ". check" after.
EOL

	complete_exercise
}

white_belt_exercise_path_and_sourcing() { # The $PATH Environment Variable, Sourcing, Final Exam
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
We're going to look at one specific environment variable now:  \$PATH.  Environment variables are usually printed with a
dollar sign ( \$ ) in front of them.  Currently, \$PATH is set to the following value.

$PATH
EOL

	echo "" >> $fmt_file

	# I copied this code from Stack Overflow.  It's probably overkill.
	# https://stackoverflow.com/questions/4774054/reliable-way-for-a-bash-script-to-get-the-full-path-to-itself
	script_path="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P )"
	script_name=`basename $0`

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
\$PATH contains a list of paths where programs might be found (scripts, binaries, and anything that can be run).

This script is in $script_path and the full path to it is $script_path/$script_name.  
EOL

	echo "" >> $fmt_file
	# Use positive lookbehind and positive lookahead to match the exact path, whether it's at the beginning of the
	# $PATH, the end, or in the middle.  This way, we can both highlight the exact path and show the entire $PATH.
	# It won't work if the path in $PATH has a trailing slash, but trailing slashes shouldn't be there.
	printf '%s\n' "$PATH" | grep -P --color=always "(?<=^|:)${script_path}(?=:|\$)" >> $fmt_file
	echo "" >> $fmt_file

	less -R -P "$less_prompt_move_on" $fmt_file

	fmt -u --width=$WIDTH <<EOL > $fmt_file
The \$PATH environment variable lists all the directories where programs can be found.  On Windows, the current directory
is always checked first for commands, operable programs, or batch files.  On Unix, typically the current directory is never
in the \$PATH.

Consider the case where a friend or coworker has made their own /home/user/bin directory available for you to look at.
If they prefer different versions of common tools, like "ls" to get a directory listing, then you will unwittingly run their
version if you are in their /home/user/bin directory.  Normally, such cases are not malicious, but they may be surprising
or confusing.  Unix and all its derivatives are known for a philosophy that prioritizes consistency and security over
convenience.

If you want to run a command in the current directory and you have the appropriate permissions, you can add "./" to the
beginning of it, but we're not going to do that right now.

You've run the "learn" and "check" scripts from two different places (the root directory and your home directory) and
neither one is where the scripts are.  The \$PATH environment variable provides your bin directory as one place to look
for programs, so you can run anything found in your \$PATH wherever you are.
EOL

	echo "" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The last thing to teach you before you get your yellow stripe is why you need to add the dot and space at the beginning
of the "check" script.  Normally, when you run a program, it runs in its own process.  All modern operating systems
allow you to run multiple instances of the same program, which can work on different inputs at the same time.  Each new
instance of the program (the child) gets a copy of some of the environment variables.  Environment variables in scripts
need to be "exported" to show up in child processes.  Any environment variables that are changed while the child runs
are not reflected in the parent.

Carefully controlling environment variables results in programs that are cleaner and more resilient.

You will only need to understand all of these details when writing bash (and similar) scripts, however, being aware of
these factors is important if most of your previous experience is with Microsoft Windows (see below).

The dot (.) in ". check" is a short form for the built-in command "source", so executing ". check" is a short form for
"source check".  When you source a script, the script runs as if it was typed in.  (If you're familiar with Windows
batch files, all batch files run as if they were typed in.  Another way to say it is that Windows batch files are always
sourced.)  This "sourcing" trick is how we can have scripts that set environment variables for other scripts.  It can
also be used to get an up-to-date command history (which is normally inaccessible).  Since running the "set" command
doesn't change anything that can be checked directly, accessing the command history is the only way that the check
script can verify that the correct command was issued.

Once you have read and understood this text, execute ". check" for your (short) final exam.
EOL

	complete_exercise
}

yellow_stripe_exercise_pwd() { # The "pwd" Command
	if [[ `pwd` == "/" ]]; then
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
To begin this exericse, you can't be in the root directory.  Execute "cd", then execute "learn".
EOL
		complete_exercise
		exit 0
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The theme of the yellow stripe exericses is creating files and directories, and in particular, characters that should be avoided.
We will also be looking at the special directories "." and "..".

As you rise through the ranks, fewer steps will be directly stated.  You should be familiar with pressing "q" to quit the
lesson so you can go back to a prompt and continue, and executing ". check" to confirm that you can go on to the next
exercise.  In between will be whatever the lesson requires, which will generally be to execute a command of some sort.

In these exercises, you'll be creating files and directories under $LUS_HOME.  Please leave this directory for the exercises.
If you want to try out the commands you're learning and it's not part of an exercise, please do it in a different directory.

Before we move around, you should have a better sense of where you are.  The "pwd" command stands for "Print Working
Directory" and tells you the full path to your current working directory.  Try it now.  When you're done, remember to execute
". check".
EOL

	complete_exercise
}

yellow_stripe_exercise_cd_dot_dot() { # Parent Directories, ".", and ".."
	if [[ `pwd` == "/" ]]; then
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
To begin this exericse, you can't be in the root directory.  Execute "cd", then execute "learn".
EOL
		complete_exercise
		exit 0
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The directory "." is a special directory that refers to the current directory.  All directories have a "." directory and
it cannot be removed.  The following paths all reference the same directory.

EOL

	echo "$HOME" >> $fmt_file
	echo "$HOME/." >> $fmt_file
	echo "$HOME/./." >> $fmt_file
	echo "$HOME/././." >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

The "." directory can be useful to provide as a source or destination.

For example, the secure copy "scp" program securely copies files and folders between computers.  It requires at least one
source and exactly one destination.

scp user@othercomputer:/home/user/fileToGet .

The command above copies the file /home/user/fileToGet into the current directory.
EOL

printf "\n\n${underline}The Parent Rescue${no_underline}\n\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The special directory ".." refers to the parent directory.  The following paths point to the same directory.

EOL

	echo "/home/" >> $fmt_file
	echo "/home/example/.." >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

All of these following paths also point to the same directory (a different one than the one above).

EOL

echo "/home/example/" >> $fmt_file
echo "/home/example/../example/" >> $fmt_file
echo "/home/example/../example/../example/" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

In the white belt exercises, you went from your home directory to the root directory, then back.  This
time, we'll look at each step along the way.  To go one directory up, execute "cd ..".  In many cases,
"cd.." will also work.  Execute "pwd", then "cd ..", then "pwd", then "cd ..".  If you're not in the root directory by
then, continue until you are.
EOL

	complete_exercise
}

yellow_stripe_exercise_no_news_is_good_news() { # No News is Good News
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
When it comes to Unix, always remember:  no news is good news.

The oldest and most core programs ("cp, "mv", "rm", etc.) will only print something if there was a problem.
If you get a prompt and nothing more, the program did as you asked.  If something went wrong, the program
or your shell would've told you.

Although this point is easy to explain, it's quite important, and so it has its own exercise.

Execute ". check" for a one question quiz.
EOL

	complete_exercise
}

yellow_stripe_exercise_mkdir_and_relative_paths() { # The "mkdir" Command and Relative Paths
	prepareLusHome

	if [ -d $LUS_HOME/parent ]; then
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
This exercise involves creating the directory $LUS_HOME/parent, which already exists.  You will need to move it or rename
it by executing "mv $LUS_HOME/parent newname", then executing "learn" again.
EOL

		less -R -P "$less_prompt_move_on" $fmt_file

		exit 2
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The "mkdir" command creates directories.  Given what you know about "." and "..", think about the following commands.

EOL

	echo "cd $LUS_HOME" >> $fmt_file
	echo "mkdir parent" >> $fmt_file
	echo "cd parent" >> $fmt_file
	echo "mkdir one" >> $fmt_file
	echo "cd one" >> $fmt_file
	echo "mkdir ../two" >> $fmt_file
	echo "mkdir ../three" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

Once you've thought about it, execute the commands.  Please be careful when entering them.  If you get it wrong, you'll
have to rename the parent directory and start from the beginning.  You can delete your attempts later when you have
more experience.

Use "cd" and "ls" to go through the directories and take a look at what you've done.  See if you were right about what
they would look like.  If they look different than you expected, think about why.  (And when you're all done with all of that,
execute ". check".)
EOL

	complete_exercise
}

yellow_stripe_exercise_rmdir() { # The "rmdir" Command
	if [ ! -d "$LUS_HOME" ]; then
		mkdir "$LUS_HOME"
	fi

	if [ ! -d "$LUS_HOME/parent" ] || [ ! -d "$LUS_HOME/parent/one" ] || [ ! -d "$LUS_HOME/parent/two" ] || [ ! -d "$LUS_HOME/parent/three" ]; then
		fmt -u --width=$WIDTH <<EOL
This exercise involves removing directories created in a previous exercise.  At least one of them doesn't exist.  Create them (y/n)?
EOL

		read CHOICE

		if [[ "${CHOICE:-}" =~ ^\s*[Yy].* ]]; then
			mkdir -p $LUS_HOME/parent/one
			mkdir -p $LUS_HOME/parent/two
			mkdir -p $LUS_HOME/parent/three
		else
			exit 2
		fi
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The "rmdir" command removes directories.  The directory must be empty for "rmdir" to work.  We will look at deleting whole
trees of directories later.  Read these commands and see if you can follow what they do.

EOL

	echo "cd $LUS_HOME" >> $fmt_file
	echo "rmdir parent/one" >> $fmt_file
	echo "cd parent" >> $fmt_file
	echo "rmdir two" >> $fmt_file
	echo "rmdir three" >> $fmt_file
	echo "cd .." >> $fmt_file
	echo "rmdir parent" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

Once you've thought about it, execute the commands.  Please be careful when entering them.  If you get it wrong, when you
run "learn" again, you can choose to create any missing directories so you can try again.
EOL

	complete_exercise
}

yellow_stripe_exercise_special_characters() { # Special Characters in Filenames and Directory Names
	prepareLusHome
	
	if [ -f $LUS_HOME/yellow ]; then
		less -R -P "$less_prompt_move_on" $fmt_file
	
		fmt -u --width=$WIDTH <<EOL
This exercise involves creating the file $LUS_HOME/yellow, which already exists.  Delete it (y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			rm -f $LUS_HOME/yellow
		else
			exit 2
		fi
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
We're going to switch focus to filenames, file types, and how to look at file contents.

Windows is up front about the characters that you're not allowed to use in a file or directory name.  They are as follows.

\ / : * ? " < > |

Unix will let you use any character on the keyboard in a file or directory name, except for "/", which is used to create paths.
Problems crop up later.

If you use a colon ":" in a file or directory name, you won't be able to add it to your \$PATH, though it's not a big deal
in most cases.  Historically, Macs used colon ":" for the same purpose as Unix uses "/", so various programs will accept
one and not the other.  Programs will convert between them.  Avoid colons on Macs.  If a Mac program lets you use
a slash "/" in a file or directory name, don't.

Spaces in file and directory names can also be problematic.  It takes more effort to write scripts that handle files with
spaces in them, so it's not hard to find scripts that were never written to handle them.

Files starting with a dash are particularly difficult to handle.  Unix programs almost always take options that start with
a dash.  For example, the copy command "cp" takes an argument "-R" for copying a directory and everything under it to a
new location.  The "R" stands for recursive.

cp -R /tmp/foo /tmp/bar

If you want to copy a file called "-R" and a file called "foo" in "/tmp/" to "/tmp/bar" then you could use the following command.

cp -- -R /tmp/foo /tmp/bar

The core tools (like copy "cp", move "mv", and remove "rm") support the "--" argument to indicate all the options are done
and everything after that is a file or directory.  Don't expect other programs will be able to work with files that start
with a dash.

The other special characters that aren't allowed on Windows are a little easier to work with, though you'll need to put the
file name in single quotes (not double quotes).  We'll do more with single quotes and double quotes soon.

Another thing to keep in mind is that Unix filesystems are usually case-sensitive.  If you create a file called test and try
to open a file called Test, you will receive an error that the file cannot be found.

Execute the following commands, remembering that Unix is case sensitive.  It will create a new file with the filename "yellow".

EOL

	echo "cd $LUS_HOME" >> $fmt_file
	echo 'echo "Hello world." > yellow' >> $fmt_file

	complete_exercise
}

yellow_stripe_exercise_file() { # The "file" Command and Magic
	prepareLusHome
	
	if [ ! -f $LUS_HOME/yellow ]; then
		less -R -P "$less_prompt_move_on" $fmt_file
	
		fmt -u --width=$WIDTH <<EOL
The previous exercise involves creating the file $LUS_HOME/yellow, but it doesn't exist.  Create it (y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			echo "Hello world." > $LUS_HOME/yellow
		else
			exit 2
		fi
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
Now that you've created the file $LUS_HOME/yellow, let's look at ways to see what's in it.

Windows popularized the idea of file extensions (foo.bat is a batch file, foo.txt is a text file, foo.doc is a Microsoft
Word document, etc.)  Unix doesn't require extensions, though it's quite common to see them.  Instead of using file
extensions, Unix uses the first few bytes of a file to tell what kind of file it is.  This file type detection process is
called "file magic" or sometimes "magic".  The file that stores a list of all the bytes and what file types they signify
is usually named "magic".  If you're interested in more details, you can check "man magic".

The program that can check a file's type is named "file".

Execute "cd $LUS_HOME", then execute "file yellow".
EOL

	complete_exercise
}

yellow_stripe_exercise_cat_less() { # Comparing "cat" and "less"
	prepareLusHome
	
	if [ ! -f $LUS_HOME/yellow ]; then
		less -R -P "$less_prompt_move_on" $fmt_file
	
		fmt -u --width=$WIDTH <<EOL
A previous exercise involves creating the file $LUS_HOME/yellow, but it doesn't exist.  Create it (y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			echo "Hello world." > $LUS_HOME/yellow
		else
			exit 2
		fi
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The simplest way to see what's in a file is with the "cat" command (which is short for conCATenate).  Before you use "cat",
you need to know that it's a small file.  (We'll look at file sizes later.)  If you accidentally "cat" a large file, your
terminal may be stuck for a while, even if you type Ctrl+c.

In a previous exercise, you executed "set | less", but you can also provide an argument to "less" to use "less" to look at a file.
It's safe to use "less" on large files.  Remember that you need to press "q" to quit less.

Execute "cd $LUS_HOME", then execute "cat yellow", then execute "less yellow".
EOL

	complete_exercise
}

yellow_stripe_exercise_quotes() { # Introduction to Quoting
	set +o nounset
	x="$(PS1=\"$PS1\" echo -n | bash -i 2>&1)"
	PS2=$(bash -ci 'echo $PS2')
	set -o nounset

	non_default_PS2=""
	if [ "$(simple_trim $PS2)" != ">" ]; then
		non_default_PS2="(On your system, it's different.)  "
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
We're going to change focus one more time and look at single and double quotes.

Double quotes are one way to work with filenames that have spaces in them.  Single quotes are one way to work with filenames
that have special characters in them.  But before we look at how they can be helpful, let's look at what can happen when
things go wrong.

For example, let's assume you've typed "echo", followed by a space, and then a double quote, and finally press Enter.
You'll see the following.

${x%exit} echo "
EOL

	echo "$PS2" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

In most cases, the character on the second line is a right angle bracket ( > ).  ${non_default_PS2}Single quotes
and double quotes must have a matching single or double quote.  (Experts:  we'll look at escaping shortly.)  The right
angle bracket or other prompt tells you that you started some quoted text but didn't finish it.  The shell is letting you
finish it.  The Enter you typed will be part of the final string you're making.  In most cases, this situation is a mistake.
Ctrl+c to the rescue!

We're going to use the "echo" command for these examples, but remember that you can use these strings of characters in a
lot of different situations.  Try out the following.

EOL

	fmt -u -s --width=$WIDTH <<EOL >> $fmt_file
echo "HOME"
echo "\$HOME"
echo '\$HOME'
EOL

	complete_exercise
}

yellow_stripe_exercise_escaping_quotes() { # Escaping Characters
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
Double quotes let you use environment variables.   If you want to work with a file that has a dollar sign, you need to
use single quotes.  Now is a good time to talk about literals.  Your shell treats a lot of characters in a special way.
The pipe ( | ) is used to connect two programs together.  The right angle bracket ( > ) sends a program's output to a file.
But what if you want to use them exactly as they are?  Then you need them to be literals.  A literal pipe is a pipe that
means exactly what it is (and not a direction to the shell to connect two programs together).  If you're using double quotes
and you need to put a literal double quote, then you use the backslash character ( \\ ).  On most keyboards, it's above the
Enter key.  It's usually on the same key as pipe ( | ).

You should expect pretty much every punctuation character to have some kind of special meaning to your shell.

You can also turn spaces into literal spaces with a backslash.  If you're working with a file that has spaces in it,
you can escape the spaces with backslashes rather than putting the whole thing in double quotes.  For example,
the following two command lines produce the same result.
EOL

	fmt -u -s --width=$WIDTH <<EOL >> $fmt_file

echo "Hello world." > "file with spaces"
echo "Hello world." > file\\ with\\ spaces

EOL

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
You can try them out, but keep in mind that you won't be told if you're overwriing an existing file.  Make sure you're not
overwriting anything important first.

Try the following just before executing ". check".

EOL

	fmt -u -s --width=$WIDTH <<EOL >> $fmt_file
echo "\"HOME\""
echo "\"\$HOME\""
echo "'\$HOME'"
EOL

	complete_exercise
}

yellow_stripe_exercise_quote_finale() { # Quoting:  Final Lesson
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
You might think that you could also escape a single quote to use it inside single quotes.  There are some shells that handle
it, but you shouldn't expect it.  What you can do instead is end the single quote, put a single quote in double quotes, and
then start the single quote again.

When it's broken out, it looks like this.

'First section' "'" 'Second section'

But that's a list of three arguments.  If you need to refer to a filename, you'll need to remove the spaces.  (Yes, it's
difficult to read.)

'First section'"'"'Second section'

If you need to work with a filename that has single quotes, it's best to put the whole thing in double quotes.

"First section'Second section"

If you have single quotes, double quotes, and other special characters like dollar sign ( $ ), you may be better off using
the trick above.

Execute ". check" for your final exam.
EOL

	complete_exercise
}

yellow_belt_exercise_speed_and_lists() { # More Speed!  Using Asterisk
	if [ ! -d "$LUS_HOME/complete" ]; then
		mkdir -p "$LUS_HOME/complete"
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
To get your green stripe, we will be looking at two things:  speed, and more about file listings.

The speed part will be partly up to you, for a few reasons.  It's not possible for a script to check that you're doing them
correctly.  It's time for you to take it on yourself.  All the exercises so far will work on many different versions and
flavours of Unix with different terminals and different shells, but some of these exercises may not work the same way for you.

Since it's not possible to build a check script to check the things you're doing in this belt, be extra careful that you
don't execute ". check" multiple times in a row, or you could skip exercises.  Not all the exercises have something to
be checked.  If you accidentally skip an exercise, you can review a previous exercise with "learn yellow belt 4" for
exercise 4 (for example).  You can also see a list of exercises with "learn yellow belt list".  If you complete all the
exercises up to the one you're on, you'll see a message, and your progress will be tracked from that point.

We've been using the words "terminal" and "shell" without defining them, since the exact meaning wasn't necessary to understand.
Perhaps you looked them up.  In the 1970s, it was easy to tell the difference between a terminal and a shell, because
the terminal was a big box that sat on a desk with a keyboard and screen.  Now, both are software.

Your terminal:
EOL

	fmt -u --prefix="  * " --width=$WIDTH <<EOL >> $fmt_file
  * Has a size measured in rows and columns

  * Controls the font and font size (how the characters look)

  * Sends what you type to your shell and displays the output from your shell

  * Accepts special sequences of characters that change the $(tput setaf 2)colour$(tput sgr0) or $(tput smul)formatting$(tput rmul)

Your shell:
  * Accepts characters from your terminal and figures out what you're asking it to do

  * Runs any programs you asked it to run

  * Sends the output from those programs to your terminal so you can see it (or gives you another prompt if there was no output)

Different shells are almost always available, but these scripts only work with the "bash" shell (short for "Bourne Again
Shell").  Depending on what Unix system you're using and how you're connecting to it, you may have a choice of terminal.

What you type is interpreted by your terminal before it gets to your shell.  Since these scripts require you to use the
bash shell, if these don't work, it's likely due to your terminal or your terminal settings, so you will need to find someone
knowledgable in the terminal you're using or have to use.

The first way to boost your speed is tab completion.  In many cases, tab completion can eliminate the need for quoting a
file name.  After going through those tricky questions in the last belt, are you angry?  Annoyed?  Relieved?  Always be
ready to properly quote a filename.  If you need notes for it, keep them with you.  It could come up when you least expect it.

You can use tab completion to complete filenames, directory names, program names, and in a few cases, command line arguments.

Before we do tab completion of a filename, we'll look at what you can do if it's not available.

Go to $LUS_HOME and execute "ls".  From there you're going to cd to the "complete" directory, but you're not going
to type all the letters.  Type "cd", a space, the letter "c", and an asterisk ( * ) which is usually Shift+8.  Press Enter.
You can use this trick with files and directories (but not commands or command line arguments).

The asterisk is often called a "star".

If there are other directories that start with "c" and you type "cd c*", then your shell will change your current directory
to the first one in alphabetical order.  Tab is better than asterisk, because you get to see where you're going before you
go and change your mind.

Here, we're using an asterisk to speed up typing a single file name.  Later, we'll look at using it for multiple filenames.

After trying all that out, remember to execute ". check".
EOL

	complete_exercise
}

yellow_belt_exercise_unquoted_tab_completion() { # Introduction to Tab Completion
	if [ ! -d "$LUS_HOME/complete" ]; then
		mkdir -p "$LUS_HOME/complete"
	fi

	touch "$LUS_HOME/complete/Monday's TPS Report for John"

	files=$(ls -1 "$LUS_HOME/complete"/Mon* | wc -l)
	if [ ! "$files" == "1" ]; then
		fmt -u --width=$WIDTH <<EOL
There are extra files in $LUS_HOME/complete.  Is it OK to delete them (y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			rm -f "$LUS_HOME/complete"/Mon*
			touch "$LUS_HOME/complete/Monday's TPS Report for John"
		else
			exit 2
		fi
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
Now that you know how to speed up no matter the circumstances (with asterisk), let's see if tab completion works for you.

Make sure you're in $LUS_HOME/complete.  Type "file Mon" (without the quotes).  Press Tab.

If nothing happened when you pressed Tab, type an asterisk.

If you saw some garbage characters show up when you pressed Tab, press Backspace until the garbage characters are gone,
then type an asterisk.

If you saw your shell escape the filename with backslashes, breathe a sigh of relief.

Whatever happened, press Enter and read the results of the command you executed.  Do you remember what the "file" command
does?  What does this output mean?  As usual, source the check script to move on.
EOL

	complete_exercise
}

create_two_TPS_reports() {
	touch "$LUS_HOME/complete/Monday's TPS Report for John"

	if [ -f "$LUS_HOME/complete/Monday's TPS Report for Fred" ]; then
		chars=$(cat "$LUS_HOME/complete/Monday's TPS Report for Fred" | wc -c)
		if [ ! "$chars" == "4" ]; then
			fmt -u --width=$WIDTH <<EOL
Monday's TPS Report for Fred has been modified.  Is it OK to overwrite it (y/n)?
EOL

			read CHOICE

			if [[ ! "$CHOICE" =~ ^\s*[Yy].* ]]; then
				exit 2
			fi
		fi
	fi

	echo "TBW" > "$LUS_HOME/complete/Monday's TPS Report for Fred"

	files=$(ls -1 "$LUS_HOME/complete"/Mon* | wc -l)
	if [ ! "$files" == "2" ]; then
		fmt -u --width=$WIDTH <<EOL
There are extra files in $LUS_HOME/complete.  Is it OK to delete them (y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			rm -f "$LUS_HOME/complete"/Mon*
			touch "$LUS_HOME/complete/Monday's TPS Report for John"
			echo "TBW" > "$LUS_HOME/complete/Monday's TPS Report for Fred"
		else
			exit 2
		fi
	fi
}

yellow_belt_exercise_unquoted_tab_completion_two_options() { # Tab Completion with Two Options
	if [ ! -d "$LUS_HOME/complete" ]; then
		mkdir -p "$LUS_HOME/complete"
	fi

	create_two_TPS_reports

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
Make sure you're in $LUS_HOME/complete.  Type "file Mon" (without the quotes).  Press Tab.  This time, if tab completion
is working, part of the file will be filled in.  That's because there are now two files that start with "Mon".

If tab completion is working, press Tab and press Tab again to see the options.  Type F, then Tab, then Enter.

If you saw some garbage characters show up when you pressed Tab, press Backspace until the garbage characters are gone,
then type an asterisk, then type "Fred" (without the quotes).  You should now have "file Mon*Fred" ready to execute.
Press Enter to execute it.

If nothing happened, type an asterisk, then type "Fred" (without the quotes).  You should now have "file Mon*Fred"
ready to execute.  Press Enter to execute it.

Read the results of the command you executed.
EOL

	complete_exercise
}

yellow_belt_exercise_quoted_tab_completion() { # Tab Completion with a Quote
	create_two_TPS_reports

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
When you pressed Tab before, you had typed part of a filename but you didn't use a single or double quote.  In this
exercise, you're going to see what happens if you do.

If you start a filename with a single or double quote, it's likely that your shell won't help you finish the filename like
it did before, nor will it tell you what the valid options are.  In other words, if you start with a double quote, your
shell won't be as helpful.  Worse, if you put an asterisk ( * ) inside a quotation, your shell will treat it as a literal
asterisk, so you can't use it as a filename short cut unless you first close the quotation you started with another quote.

That's what you should do if you run into that situation.

If you start the filename with a single or double quote and press Tab, and your shell fills in part of the filename,
you should type a matching quote and press Tab.  Your shell will convert the quotation to a series of escapes instead,
and now your shell will be a little more helpful letting you finish the filename.

If pressing Tab hasn't done anything at all, you can use an asterisk to complete part of the filename, just make sure it's
not in either kind of quotes.

Make sure you're in $LUS_HOME/complete.  Type in each command line below and then press Tab three times.  To go onto the
next one, hold down Backspace until it's all gone or press Ctrl+c.

EOL

			echo "file Mon" >> $fmt_file
			echo "file "'"'"Mon" >> $fmt_file
			echo "file 'Mon" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

Do you see how starting with a quote will finish part of the filename but won't help you after that?

Try the two kinds of quotes again, but this time, if you started with a double quote, use another double quote at the end
to close the quotation (and the same for single quotes).  Then try pressing Tab again.  Press Tab two more times to see
your options.  Suddenly, your shell is helpful again, offering options and finishing it off once you indicate which
one you want (with an "F" or a "J").

When you execute any of these commands, you'll see the file's type again.  If you run any of them with a starting quote and no
finishing quote, the shell won't give you another standard prompt until you end the quote or press Ctrl+c.  That's how you
create filenames with line breaks in them (please don't).

Now, use what you've learned to take a look at what's inside the file "Monday's TPS Report for Fred" without typing the
whole filename and letting your shell do all the work.  This time, instead of getting the file's type, we're looking for
the file's contents.  (Hint:  the file is very small.)
EOL

	complete_exercise
}

yellow_belt_exercise_tab_is_context_sensitive() { # Tab is Context Sensitive:  What are you Completing?

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
It matters where in the command line you press Tab.  The first thing on a command line must be a program or alias (we'll look
at aliases later).

Let's say you have a program called "myprogram" in your home directory.  Let's say your home directory is not in your \$PATH
(it usually isn't).  If you type "myprog" and press Tab, nothing will happen, because the first thing on a command line must
be a program, and "myprogram" isn't in your \$PATH, so it doesn't count.

But if you type "file myprog" and press Tab, then your shell will complete it, because in this case, any file is good here.

If you type "cd myprog" and press Tab, nothing will happen, because "myprogram" is not a directory.

For your shell to complete something at the beginning of a command line (assuming it's not an alias) it needs to be in your
path and you need to have permission to read it and run it.

If you have permission to read it and run it, you can get around the \$PATH issue by starting with "./".  If you type
"./myprog" (with or without the quotes) and Tab, your shell will complete it for you.  

If you're trying to run a program and the shell is not completing the name for you, it's an indication that it's not in
your \$PATH or the permissions could be wrong.  We'll look at permissions later.  If you're trying to "cd" to a directory
and your shell is not completing it, it might not be a directory, or you might have the name wrong.

There's nothing to complete for this exercise before executing ". check".
EOL

	complete_exercise
}

yellow_belt_exercise_up() { # Finding and Running Previous Commands one Line at a Time
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
There are a few ways you can run a previous command.  The simplest way is with the up arrow.  Depending on your
terminal settings, the most likely thing to happen is that you'll see the previous command you ran (which will
be "learn").  If that works, you can press Up or Down to go through your previous commands.  You'll also be
able to press Left and Right, Del, Backspace, and make any changes you want to.  Press Enter to execute your
current command (even if you're not at the end).

The second most likely thing to happen is that you'll see this: "^]]A".  There are a couple of things you can do.  You can
try to get help from someone who knows the kind of terminal you're using and fix your terminal settings, you can use Ctrl+p
for the previous command and Ctrl+n for the next one, or there are other alternatives, which we'll get to.

If nothing happens, you can try Ctrl+p and Ctrl+n as above.  We'll look at other options shortly.

After you press "q" to quit (as usual) try typing Up, Down, Left, and Right.

If they don't work, try Ctrl+p and Ctrl+n.  Ctrl+f moves forward one character.  Ctrl+b goes backward one character.  If a
single one works, you can hold down the Control key and type the letter multiple times.

If you get lost in your history and don't want to execute anything, you have a few options.  (1) You can go to the end of the
line, then hold down Backspace to wipe everything out.  (2) You can type Ctrl+c, your trusty get-me-out-of-here key combination.
(3) You can hold the Down key until you get out of your history (which may not always work, and in some cases, if you hold
it too long, you'll get a stream of noise from your terminal).  (4) You can go to the beginning of the line, type a pound
sign ( # ) and press Enter. 
EOL

	complete_exercise
}

yellow_belt_exercise_home_end_and_pound() { # The "Home" key, "End" key, and What "#" Does
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
We're going to look at two more keys before we look at other ways to run previous commands.  These are Home and End.
If you have a terminal with the right settings, pressing Home will take you to the beginning of your command line,
and End will take you to the end.

If not, Home will dump ^[[H into your command line and End will dump ^[[F into your command line.  In that case, use Ctrl+a
to go to the beginning of the command line ("a" is the first letter in the alphabet).  Use Ctrl+e to go to the end.

There are more key combinations to go to the beginning and end of words, to delete to the beginning and end of words,
and more.  We do not recommend memorizing them.

We recommend memorizing Ctrl+a and Ctrl+e, for two reasons:  speed and compatibility.  They are much faster than picking
up your hands, finding the Home or End key, pressing it, and returning your hands to the home row.  In some cases, you
may need to use a misconfigured or old terminal, and Home and End won't work.  Home and End don't usually work by
default on Macs either, so it's good to have options.

If you're used to moving quickly back and forth between the cursor keys and the home row, memorizing Ctrl+f and Ctrl+b
may not be of much use.  In the worst case, if you have no choice but to use a misconfigured terminal, you'll still be
able to enter commands, but you'll be slower.  It might never come up.  You might look them up if and when you need them.
If takes a long time for you to move your hands to the cursor keys and back, you might benefit from memorizing Ctrl+f and
Ctrl+b.

You could memorize Ctrl+p and Ctrl+n, but we'd rather you memorize Ctrl+r, which we'll get to shortly.  Ctrl+r will do what
Ctrl+p and Ctrl+n will do and more.

Pound signs ( # ) and everything after them are ignored (unless the pound sign is quoted or escaped).  Using a pound sign at
the beginning of a line is a good way to keep something in your recent command history if you aren't ready to execute it yet.
If you're familiar with Windows Batch files, putting a pound sign at the beginning of a command line is exactly like putting
REM at the beginning of a line of a batch file.  If you're familiar with a programming language, the pound sign starts a comment.
 
To keep something in your recent history without executing it, press Home (or Ctrl+a), then a pound sign, then Enter.
The pound sign is usually typed with Shift+3.

Try Home, End, Ctrl+a, and Ctrl+e now with everything you learned in the previous exercise.  Try the pound trick in the
previous paragraph with a command from your history, and immediately execute ". check".
EOL

	complete_exercise
}

yellow_belt_exercise_ctrl_r() { # Using Ctrl-r to Search for and Run Previous Commands
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
It's time to look at Ctrl+r.  This keystoke lets you search for a command that's in your history, make changes to it if
you want, and then save it for later or execute it.  If you execute it, it will also be added to your history.

To search for a command you've already run, type Ctrl+r.  Then type as many keystrokes as you need to to find what you're
looking for.  If you make a mistake, you can press Backspace.  You don't have to start at the beginning.  If you're looking
for the command line "cat Monday's\\ TPS\\ Report\\ for\\ Fred" in your history, you can type Ctrl+r and then type "Fred"
(without quotes).

Once you've found the command you want, you have multiple options.

EOL

	fmt -u -c --width=$WIDTH <<EOL >> $fmt_file
  * You can run the command as is right now (which will also add it to your history as the last command run).  To do that,
    simply press enter.

  * You can add the command line as the last command line in your history (to make it easier to find) and without running
    it by making it a comment.  To do that, go to the beginning of the line, type the pound sign, and press Enter.
    When you find it later, if you want to run it, you'll need to remove the pound sign with the Delete key or the Backspace
    key.

  * You can make changes to it.  Type any keystroke that will let you move around (without going up or down) like Left, Right,
    Ctrl+a, Ctrl+e, Ctrl+f, or Ctrl+b.  After you do that you'll be out of search mode and you can change anything you like.
    To execute it, press Enter.  To save it for later, go the beginning of the line, type a pound sign, and press Enter.

  * You can change your mind.  Type Ctrl+c and the search will stop, whatever you found so far will be gone, and you'll
    get a fresh new prompt.  You can also get out of search mode with Ctrl+g, but Ctrl+c is easier to remember.
EOL

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

You can also type Ctrl+r again (and again).  Each time you type it, you'll see the previous command line that matches what
you typed.  You can search forward again with Ctrl+s, but if you start over, you only have to remember Ctrl+r.

Try all of these things with Ctrl+r now.  You can execute "learn" to see the current lesson as many times as you want.
EOL

	complete_exercise
}

yellow_belt_exercise_history_bang() { # "!"
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
There are a truly staggering number of ways to speed up typing things.  For example, you can refer to the third
argument of the fifth last command you typed.

EOL

	fmt -u --width=$WIDTH -s <<EOL >> $fmt_file
[user@host:~]$ echo 100 98 96
100 98 96
[user@host:~]$ echo 94 92 90
94 92 90
[user@host:~]$ echo 88 86 84
88 86 84
[user@host:~]$ echo 82 80 78
82 80 78
[user@host:~]$ echo 76 74 72
76 74 72
[user@host:~]$ echo !-5:3
echo 96
96
EOL

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

Your shell will print the full command (in this case, "echo 96") then execute it.

We would not expect very many people in the world to know how to do that.  The depth of what's available to speed up typing
is staggering, and you're likely to use only a fraction of it even if you become a Unix admin as a career.

What we've gone through so far will speed up pretty much any situation, although there's one last thing that comes up often
enough to make it into these exercises.  There's a way to refer to the last argument of the last command line that's quite
short, though it's hard to remember.  It can be helpful when you create a directory and then want to "cd" to it, especially
if the directory name is long or it's a full path (which is long).

EOL

	fmt -u --width=$WIDTH -s <<EOL >> $fmt_file
[user@host:~]$ mkdir dirname
[user@host:~]$ cd !$
cd dirname
[user@host:dirname]$
EOL

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

The exclamation point ( ! ) means you want to fill something in from your history.  The dollar sign ( $ ) means you want
the last argument filled in.  It can be tricky to remember, and you can always fall back on Ctrl+r, Ctrl+p, or Up and then
change "mkdir" to "cd".

If you want to check it first, use "echo !$".  Since the last argument is the same, you can still use "cd !$" after "echo !$".

Try out "!$" now.  If you create any directories under $LUS_HOME, please remove them before continuing.
EOL

	complete_exercise
}

green_stripe_exercise_command_line_options() { # Short Options, Long Options, and Man(ual) Pages
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
Before we get into the various ways you can list files, we'll have to go through short options and long options.
Short options are single characters.  Long options are full words, and sometimes multiple words.

We looked at "cp -R" earlier.  The single letter "R" is a short option.  It comes after a hyphen ( - ).  Sometimes, a
hyphen is used as a negative sign or as a dash.

cp -R source destination

Here's an example of a long option.  Long options start with two dashes.

cp --version

The "version" long option tells "cp" to print information about when it was made (and by who).

Who made it can give you some insight into how it can be used.  It's time for a (very short) history lesson.  (Don't
worry, it's not on the test.)

The Mac OS X operating system is based on NeXTSTEP, which is based on BSD, which is based on research at Bell Labs (which
is where Unix came from).

BSD also "gave birth" to FreeBSD, NetBSD, and OpenBSD, which are still popular.  They're also free.  NeXTSTEP has been
discontinued.

All of the operating systems above are "BSD or BSD-like".

Next, we'll list the commerical non-BSD Unixes (the ones you have to pay for).  All of these were based on the original
work on Unix at Bell Labs and are still around as of this writing:  Solaris, HP-UX, IBM AIX.

Last (but certainly not least) is Linux in all of its many shapes and sizes.  It runs phones (Android) and supercomputers
(all of the fastest 500 as of November 2017).  Linux cannot trace its ancestry back to the original Unix because that was the
whole point.  When it was written, Unix cost a lot of money.  All of the core tools ("cp", "mv", "ls", etc.) were provided
by GNU to make Linux a complete and fully--functioning operating system.

GNU, BSD, and the commerical Unixes do things differently.

The history lesson ends now.

If you're using a Mac (now, or you plan to fully immerse yourself in using the command line) this would be a good time to
take note that Macs are based on BSD and won't work the same way Linux does.  In particular, long options don't appear very
often in BSD tools.  If you don't want to use the command line features of Macs, that's certainly an option as well.

No matter which platform you're using or will be using, programmers can still do short and long options however they want.
Some Linux programs don't have any short options and long options have one dash, not two (like Java).  Some programs
don't have any options at all and only take mandatory arguments (like most scripts).  Some programs only have long options
(like this script).  A lot of programs require you to put all the options first, but some let you put them anywhere.

As we mentioned quite a bit earlier, some programs allow you to give "--" as an argument.  Anything after that will be
treated as a filename and not an option, which lets you use filenames that start with a hyphen.  For programs that don't
support "--", you can't use them with filenames that start with a hyphen, or you need to use tricks like asterisk (unless
they don't support options at all, in which case it doesn't matter).

The tool that shows what programs are running is "ps".  Many versions of "ps" behave more like the BSD version when you don't
start with a hyphen and more like the GNU version when you do.  (Although, BSD did and does have hyphens on short options.
The full story is not really important here.)

Even though programmers can write programs to take arguments however they want, there is a lot of standarization.  You will
need to remember the programs you use on a regular basis that are different, or at least remember how to get the basic help
information.  GNU tools accept the "--help" long option.  Many other tools support "-h" for basic help.

If you have a BSD-like system, chances are, "ls --version" and "ls --help" are not going to work.

It's time to use your first resource.  You can access the manual page (or "man page") for the "ls" command by executing
"man ls".  Just like this script, "man" automatically uses the "less" program so you can see a page of information at a time.
The "ls" command supports a truly staggering number of options.  It's unlikely that anyone would know all of them.  For now,
get some experience using the "man" command.  The check script looks at your last few commands, so make sure you execute
"man ls" and ". check" without too many commands in between.
EOL

	complete_exercise
}

create_lists() {
	prepareLusHome
	
	if [ -f $LUS_HOME/list ]; then
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
This exercise involves creating the directory $LUS_HOME/list, which already exists.  You will need to move it or rename
it by executing "mv $LUS_HOME/list newname", then executing "learn" again.
EOL

		less -R -P "$less_prompt_move_on" $fmt_file

		exit 2
	fi

	if [ ! -d "$LUS_HOME/list/ord" ]; then
		mkdir -p "$LUS_HOME/list/ord"
		touch "$LUS_HOME/list/ord/first"
		touch "$LUS_HOME/list/ord/second"
		touch "$LUS_HOME/list/ord/third"
	fi

	if [ ! -d "$LUS_HOME/list/count" ]; then
		mkdir -p "$LUS_HOME/list/count"
		# I'd like to make these relative to the time they're made, but it's hard to do that in a portable way.
		touch -t 202203010000 "$LUS_HOME/list/count/one"
		touch -t 202203020000 "$LUS_HOME/list/count/two"
		touch -t 202203030000 "$LUS_HOME/list/count/three"
	fi
}

green_stripe_exercise_ls() { # Getting Directory Lists Different Ways
	create_lists

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
List the files in $LUS_HOME/list/ord and $LUS_HOME/list/count.  There a ton of different ways to do that.  You can "cd"
to these directories a bunch of different ways, you could list the contents of these directories without "cd" by providing
each directory as an argument to "ls", either one at a time, or together on the same command line.  You could also try
using the copy and paste features of your terminal.  Explore different ways to list these files without using any options.
We'll look at options for "ls" in the next few exercises.
EOL

	complete_exercise
}

green_stripe_exercise_ls_dash_l() { # Introduction to "ls -l"
	create_lists

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
Before we look at long directory listings, you'll need some idea of size.  If you've sent emails with attachments, you
may already have some sense of the size of information.  The size of attachments is usually shown, and you may have
seen an error that that your attachment was too large.

Outside of the United States, the basic unit of length is the metre, the basic unit of mass is the gram, and the basic
unit of time is the second.  Similarly, the basic unit of information is the byte.  A byte is made up of eight bits,
which can be 0 or 1.  One byte can hold a single character like "a", "1", or "$", or a number from 0 to 255.  A kilobyte
(1 KB) is 1024 bytes.  A page of text or a short email with no pictures or attachments can be stored in a kilobyte or
two.  (If you try it yourself, make sure to save the file in text format.)

Unix doesn't write to disks byte by byte, but instead groups bytes together into blocks.  You can think of a block like
a shipping container.  Most of the time, the block size is 4 KB (4,096 bytes).  Each one is a standard size, and they can
be placed in any order, which makes it easier to organize and move them.  A shipping container might have papers,
packing peanuts, a car, or priceless antiques.  It could be full or empty.  The same is true of a block, which might
contain a part of a larger text file, a small text file with empty space, or a tiny piece of a PhD thesis.  A block
might also contain nothing at all.  Read on for what empty files can be used for.

Only experimental and research file systems allow more than one file to be stored in a block.  If a file only has
100 bytes of data in it, it will take up one block.

We'll look at the "-l" option for "ls" now.  The "-l" option shows the long listing format.

Here's an example.

EOL

	echo '[user@host:~/example]$ ls -l' >> $fmt_file
	echo 'total 4' >> $fmt_file
	echo 'drwxrwxr-x 2 user ug 4096 Nov  8 08:40 zero' >> $fmt_file
	echo '-rw-rw-r-- 1 user ug    0 Jan  1  2021 one' >> $fmt_file
	echo '-rw-rw-r-- 1 user ug    0 Jan  2  2021 two' >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

The first thing that "ls -l" prints is a total, in this case, "total 4".  That means that the files and directories here
take up 4 blocks.  The size of a block can vary from filesystem to filesystem, but is rarely more than 4 KB (4,096
bytes), and very rarely less than 512 bytes (1/2 KB).  We will be looking at more helpful ways to display this "total"
later.

The next three lines tell us information about what's in this directory.

We'll begin at the end.  On the far right are the file and directory names:  "zero", "one", and "two".

We'll go through the rest of the fields from left to right.  The first part of the output shows the permissions
(drwxrwxr-x).  We'll be looking at what these mean and how to change them quite a bit later.  Right now, look at the
first character.  If it's a directory, the first character will be "d".  If it's a regular file, it will be a hyphen.
So "zero" is a directory, and "one" and "two" are not directories.

The next part is who owns the file.  In this example, the user ID is "user".

The part after that is what group owns the file.  In this case, that's "ug".

Fourth, we have the size of the file.  The files "one" and "two" have a size of 0, so they're empty files.  Empty files
can serve as flags to indicate something has been completed, and to provide a timestamp of when it completed.  The
"zero" directory is taking up 4,096 bytes of space.  Directories always take up at least one block (which may be larger
or smaller than 4,096 bytes).  If the number of files in a directory grows so large that the list of files can't fit
inside one block, then the size of the directory will grow.  A directory's size is based on the number of files and the
lengths of their filenames, and doesn't have to do with the size of the files.

Second last, we have the date (and maybe the time).  If a file is very recent, you'll see a date and time.  If it's older,
you'll see a month, day, and year.

For the sake of completion, the file (or directory) name is last.

The "ls -l" command line is typed so frequently that in many cases there's an "ll" alias.  You can see whether it's aliased
on your system with the command "type ll".

In the example below, ll is aliased to "ls -l" (plus two more options, "a", and "F").

EOL

	fmt -u -s --width=$WIDTH <<EOL >> $fmt_file
[user@host:~]$ type ll
ll is aliased to \`ls -alF'
EOL

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

In the following example, ll is not aliased.

EOL
	fmt -u -s --width=$WIDTH <<EOL >> $fmt_file
[user@host:~]$ type ll
bash: type: ll: not found

Check to see if you have the "ll" alias.  List the files in $LUS_HOME/list/ord and $LUS_HOME/list/count with the "-l" option.
EOL

	complete_exercise
}

green_stripe_exercise_ls_explore() { # Searching in a Man(ual) Page
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
It's time to use the man pages again.  This time, you'll be looking for something specific.

When you're using "less", you can look for something specific with slash ( / ).  Type a slash, type what you're looking
for, and press Enter.  You're using "less" right now, but everything is probably on one page in your terminal, so
searching for something is likely to be a bit boring.  (But nothing's stopping you.)

Use the question mark ( ? ) to go back.  Type the letter "h" for more ways to move around.

You know from the previous exercises that the files "one", "two", and "three" have different modification dates.  Open
the man page for "ls" by executing "man ls".  You may want to skim the man page for "ls" so you can appreciate the sheer
number of options.  While it's open, use slash to search through the options to find the right arguments that will list
the files in order.  Once you've found some options that will help, close the man page with "q" as usual and try them
out.  Once you have a listing of the files in $LUS_HOME/list/count in numerical order, execute ". check".

Only the short options will be considered correct, as they work with both BSD and GNU "ls".  Also, please put the options before
the directory name (if you use one).
EOL

	complete_exercise
}

green_stripe_exercise_ls_dash_h() { # Introducing "ls -h"
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
Try out "ls -lh" in or on different directories.  If you're on a BSD or GNU system, it will give you file listings in long
format with "human readable" file sizes.

If you're not, it's anyone's guess.  It may give you an error, do nothing, or do something else.  If you like, check the
man page before you try it.  Once you're done, execute ". check" for your final exam.
EOL

	complete_exercise
}

# Green Stripe
# ls -f (directory order, good for problems with lots of files)
# show ls -l with files at different dates in the past?
# Intermediate arguments to ls; mounts and disk space

####################
# End of exercises #
####################

blue_stripe_exercise_df() {
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The last thing in yellow belt is the "df" command.  But before we go into what it does, we'll have to go over mounts.

Some time ago, we showed how Windows has drive letters, but in Unix, everything is in one filesystem.  In order to bring
disk drives, network shares, USB sticks, and everything that has files in it into one place, they are "mounted" onto the
base filesystem.  How that works isn't important for these lessons.  The important thing is that each "mount" has a bunch
of files and each one has a maximum size.

Just as a USB drive E: in Windows has a maximum size, and the hard disk C: has a maximum size, each mount in Unix can
get filled up.  That means that /var/log can be full of log files, but /home still has room.  That's a good thing.  It
means one problem won't bring down the whole system.  In many cases, mounts will have some space reserved that only
root can use.

The command to see how much space is being taken up for each mount is "df".  By default "df" shows block sizes, which are
not very user friendly.  To see the sizes in "human" units, use the "-h" option.
EOL

	complete_exercise
}

#########################
# End of held exercises #
#########################

ask_about_putty_font_size() {
	fmt -u --width=$WIDTH <<EOL
Was that text comfortable to read?  It looks like you're connected with SSH, so chances are, you're using PuTTY.
If you're using PuTTY, would you like any help to increase the font size (y/N)?
EOL

	read CHOICE

	if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
		fmt -u --width=$WIDTH <<EOL
Right click on PuTTY's title bar and select "Change Settings".  In the left navigation pane, select Window >
Appearance.  Click the "Change..." button about halfway down the right pane.  Select a new font size and
click "OK".  Click "Apply".  When you're happy with the settings, right click on PuTTYs title bar, go to
Session in the left navigation pane, select the session, and click "Save".
EOL

	size_matters

	echo ""

	fi
}

make_temp() {
	set +e
	fmt_file=$(mktemp --suffix_$(whoami) 2>/dev/null)
	RESULT=$?
	if [ $RESULT -ne 0 ]; then
		fmt_file=$(mktemp -t $(whoami)-XXXXXX)
	fi
	set -e
}

welcome() {
	make_temp
	file_clean_up_array+=($fmt_file)

	fmt -u --width=$WIDTH <<EOL > $fmt_file
When you see a prompt like "Press h for help; Enter for more", press Enter for one more line and Space for one more page.

If there's more text than will fit in your terminal, the Up and Down arrow keys should work in addition to Enter and Space
(but it depends on your terminal settings).  Press "h" for other alternatives.

If all the text fits in your terminal, you'll immediately see a prompt to press "q".  Pressing Enter, Space, or the arrow
keys will have no effect.

At the bottom of the text (or immediately if all the text fits) the prompt will change, asking you to press "q" to move on
(or quit if it's the end of the lesson).  Once you're done reading all the text (including right now) press "q".
EOL

	less -R -P "$less_prompt_move_on" $fmt_file

	fmt -u --width=$WIDTH <<EOL > $fmt_file
The following notes are an overview of what will be covered in this course.
It's likely that you will only understand them if you already have some
experience with them.  Consider them like chapter headings in a textbook you recently received.
EOL

	printf "\n${underline}Beginner and Intermediate Ranks${no_underline}\n" >> $fmt_file

	printf "\n`getBeltWithColours white_belt title`\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  In a martial arts club (or dojo) a student gets their white belt when they buy a uniform and sign up for classes.  In this
  case, a student gets their white belt when they run the learn script and choose to get started.
EOL

	echo "" >> $fmt_file

	printf "`getBeltWithColours yellow_stripe title`\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Understanding \$PATH and environment variables.
EOL

	printf "\n`getBeltWithColours yellow_belt title`\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Creating and deleting directories; . and ..; pwd; cd; file types and magic
EOL

	echo "" >> $fmt_file
	printf "`getBeltWithColours green_stripe title`\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Intermediate arguments to ls; mounts and disk space
EOL

	printf "\n\n${underline}Advanced Ranks${no_underline}\n" >> $fmt_file

	printf "\n`getBeltWithColours green_belt title`\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Hidden files and directories; globbing; directory stacks
EOL

	printf "\n`getBeltWithColours blue_stripe title`\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Pipes; tee; redirection; head, tail, sort, grep
EOL

	printf "\n`getBeltWithColours blue_belt title`\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Finding large files and directories with du, sort, and head; rm; rmdir; mv
EOL

	printf "\n`getBeltWithColours red_stripe title`\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  ZIP and tar archives
EOL

	printf "\n`getBeltWithColours red_belt title`\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Signals; stopping processes; ps; pgrep vs grep
EOL

	printf "\n`getBeltWithColours black_stripe title`\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Foreground and background tasks, jobs and &
EOL

	printf "\n`getBeltWithColours black_belt title`\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  User and group ownership; permissions; ls -ld; stat; namei
EOL

	echo "" >> $fmt_file

	less -R -P "$less_prompt_move_on" $fmt_file

	if [ ! -f "${LUS_PROGRESS}" ] || [ -z "${RANK:-}" ] || [ -z "${EXERCISE:-}" ]; then
		if [ -n "${SSH_CONNECTION:-}" ] || [ -n "${SSH_TTY:-}" ]; then
			ask_about_putty_font_size
		fi

		size_matters

		lus_dir=$(dirname "${LUS_PROGRESS}")
		if [ ! -w "${lus_dir}" ]; then
			if [[ "${INSIDE_DOCKER:-0}" == "0" ]]; then
				echo "Unable to save progress.  Please ask your sysadmin to make sure the"
				echo "directory ${lus_dir} is writable."
			else
				echo "The directory ${lus_dir} is not writable."
				echo 'Unable to save progress.  Please exit the docker container (with "exit")'
				echo "and run the following commands."
				echo
				echo "# Setup commands:  run them once"
				echo "docker volume create lus"
				echo "docker run --mount src=lus,target=/mnt/vol -u 0 alpine /bin/ash -c 'mkdir -p /mnt/vol/testuser;chgrp 1000 /mnt/vol/testuser;chmod g+w /mnt/vol/testuser'"
				echo
				echo "# Work with traditional white text on black terminal settings"
				echo "docker run -it --rm --mount src=lus,target=/mnt/vol cevans42ca/learn-unix-scripts"
				echo
				echo "# Work with black text on white"
				echo "docker run -it --rm --mount src=lus,target=/mnt/vol --env DARK_MODE=0 docker run -it --rm cevans42ca/learn-unix-scripts"
				exit 1
			fi
		fi

		fmt -u --width=$WIDTH <<EOL
If you type "y" and press Enter, then you will be given your first task.
EOL

		echo -n "Are you ready to begin (y/n)? "
		read CHOICE

		if [ "$CHOICE" == "" ]; then
			fmt -u --width=$WIDTH <<EOL
Implict consent is not enough this time.  To begin, you must choose.
EOL

			echo -n "Are you ready to get started (y/n)? "
			read CHOICE
		fi

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			clear
			RANK="white_belt"
			EXERCISE="1"
			updateDotFile

			print_rank > $fmt_file

			set_num_exercises

			echo "Exercise 1/${NUM_EXERCISES}" >> $fmt_file
			echo "" >> $fmt_file

			exercise_name=${exercises["${RANK}_1"]}
			function_name="${RANK}_exercise_${exercise_name}"
			eval $function_name
		fi
	fi
}

###############################
# End of function definitions #
###############################

# Script execution will begin here.

if [ -f "${LUS_PROGRESS}" ]; then
	source "${LUS_PROGRESS}"
fi

LUS_HOME=${LUS_HOME:-"$HOME/lus"}

if [ ! -f "${LUS_PROGRESS}" ] || [ -z "${RANK:-}" ] || [ -z "${EXERCISE:-}" ]; then
	if (($STTY_ROWS < 24)) || (($STTY_COLUMNS < 80)); then
		# We haven't introduced what Y/n means, but if the user has made a conscious choice to make their terminal
		# smaller, they probably already know.
		fmt -u --width=$WIDTH <<EOL
A minimum of 80 columns and 24 rows is strongly recommended.  Would you like to automatically update the terminal size to
the recommended minimum and continue (Y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[yY] ]] || [ -z "$CHOICE" ]; then
			resize_to_default
			RESIZED_ALREADY=1
			clear
		fi
	fi

	welcome
	exit 0
fi

if [ "${1:-}" == "--welcome" ]; then
	welcome

	if [ -z "${RANK:-}" ]; then
		print_rank
	fi

	exit 0
fi

if [ "${1:-}" == "--return" ]; then
	if [ -z "${SAVED_RANK:-}" ] || [ -z "${SAVED_EXERCISE:-}" ]; then
		echo "There is no saved progress to return to."
		exit 3
	else
		RANK=$SAVED_RANK
		EXERCISE=$SAVED_EXERCISE
		SAVED_RANK=""
		SAVED_EXERCISE=""
		updateDotFile
	fi
fi

if [[ ! "${RANK}" =~ ^(white|yellow|green|blue|red|black)_(stripe|belt)$ ]]; then
	fmt -u --width=$WIDTH <<EOL
It looks like the "${LUS_PROGRESS}" file has become corrupted.  If it can't be repaired, you may have no choice but to delete it
and start over.  Sorry about that.
EOL
	exit 2
fi

if [[ ! "${EXERCISE}" =~ ^[0-9]+$ ]]; then
	fmt -u --width=$WIDTH <<EOL
It looks like the "${LUS_PROGRESS}" file has become corrupted.  If it can't be repaired, you may have no choice but to delete it
and start over.  Sorry about that.
EOL
	exit 2
fi

all_args="$*"
all_args=${all_args,,}
if [[ "${all_args}" =~ (white|yellow|green|blue|red|black).*(stripe|belt)[^0-9]*([0-9]*) ]]; then
	# The $LUS_PROGRESS file must exist.  If it didn't, we would be running welcome().

	new_rank="${BASH_REMATCH[1]}_${BASH_REMATCH[2]}"

	# No underscore.
	new_rank_for_echo="${BASH_REMATCH[1]} ${BASH_REMATCH[2]}"

	new_exercise="${BASH_REMATCH[3]}"

	if [[ "${all_args}" =~ list ]]; then
		regex="'"
		regex+="${new_rank}_exercise_.*\(\)"
		regex+="'"

		# Advanced sed:  if an exercise exists, skip to the :x label.  If not, replace the line with "No Title".
		# Use cat -n to add a line number (which is the exercise number).
		bash -c "grep -E ${regex} ~/bin/learn | sed 's/.* #\s*//;tx;s/.*/No Title/;:x' | cat -n"
		exit 0
	fi

	if [ "${new_exercise}" == "" ]; then
		new_exercise=1
	fi

	if [ "${new_exercise}" == "0" ]; then
		echo "The first exercise of each rank is exercise 1."
		exit 3
	fi

	if [[ "${new_exercise}" =~ 0[0-9]+ ]]; then
		echo "Please don't add leading zeros to the exercise number."
		exit 3
	fi

	new_belt_number=${belt_to_number[$new_rank]}

	if [ -n "${SAVED_RANK:-}" ]; then
		current_belt_number=${belt_to_number[$SAVED_RANK]}
	else
		current_belt_number=${belt_to_number[$RANK]}
	fi

	if [ -n "${SAVED_EXERCISE:-}" ]; then
		current_exercise=${SAVED_EXERCISE}
	else
		current_exercise=$EXERCISE
	fi

	if (($new_belt_number > $current_belt_number)); then
		fmt -u --width=$WIDTH <<EOL
This feature is for reviewing previous exercises, not for skipping ahead.
EOL
		exit 3
	fi

	if (($new_belt_number == $current_belt_number)); then
		if ((${new_exercise} > $current_exercise)); then
			fmt -u --width=$WIDTH <<EOL
This feature is for reviewing previous exercises, not for skipping ahead.
EOL
			exit 3
		elif ((${new_exercise} == $current_exercise)); then
			fmt -u --width=$WIDTH <<EOL
You're already working on that exercise.
EOL
			exit 3
		fi
	fi

	set_num_exercises_for_review

	if [ "$NUM_REVIEW_EXERCISES" == "0" ]; then
		echo "There aren't any exercises for ${new_rank_for_echo} yet."
		exit 3
	fi

	if (( $new_exercise > $NUM_REVIEW_EXERCISES )); then
		echo "There are only $NUM_REVIEW_EXERCISES exercises in ${new_rank_for_echo}."
		exit 3
	fi

	# Only set saved rank and saved exercise if they're currently unset, otherwise students could use this feature to
	# skip ahead.
	if [ -z "${SAVED_RANK:-}" ]; then
		SAVED_RANK=$RANK
	fi

	if [ -z "${SAVED_EXERCISE:-}" ]; then
		SAVED_EXERCISE=$EXERCISE
	fi

	RANK=$new_rank
	EXERCISE=$new_exercise

	updateDotFile

	# Fall out of the if and continue with the requested lesson.
elif [ -n "${1:-}" ] && [ "${1:-}" != "--return" ]; then
	# There was an argument passed but we couldn't figure out what the user wanted.
	echo "Usage:"
	echo ""
	echo "learn --welcome"
	echo "  To see which skills fall under which belts"
	echo "learn white belt"
	echo "  To review the white belt exercises"
	echo "learn yellow stripe"
	echo "  To review the yellow stripe exercises from the beginning"
	echo "learn white belt list"
	echo "  To see a list of white belt exercises"
	echo "learn white belt 6"
	echo "  To start reviewing at a particular exercise"
	echo "learn --return"
	echo "  If you're reviewing exercises, return to where you were."

	exit 1
fi

if [ -z "${fmt_file:-}" ]; then
	make_temp
	file_clean_up_array+=($fmt_file)
fi

print_rank > $fmt_file

if [ -z ${exercises["${RANK}_${EXERCISE}"]:-} ]; then
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
There are no more exercises at this time.  If you like, you can review exercises you've already completed by executing
"learn white belt" or "learn yellow stripe".  Get a list of exercises with "learn yellow stripe list", and go to a specific
exercise with "learn white belt 6".
EOL

	complete_exercise

	exit 1
fi

set_num_exercises

echo "Exercise ${EXERCISE}/${NUM_EXERCISES}" >> $fmt_file
echo "" >> $fmt_file

exercise_name=${exercises["${RANK}_${EXERCISE}"]}
function_name="${RANK}_exercise_${exercise_name}"
eval $function_name

