#!/bin/bash

# This file is part of the "learn-unix-scripts" project.
#
# The "learn-unix-scripts" project is free software: you can redistribute it and/or modify it under the terms of the GNU
# General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# The "learn-unix-scripts" project is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with this project; if not, write to the
# Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA, 02111-1307, USA.
#
# Copyright (C) 2021 Christopher Evans

# This script was developed in a 130x30 terminal.

# replace start 1acc396a-02a2-40b8-a427-f4685c20320e (see below for what this line does)
#
# This script is the master script for the learn script.  If you have site-specific changes that you don't want to share,
# you can add a GUID in this script and use the "replace" script to merge this script with your site-specific changes
# (in learn-replace) and create a site-specific learn script.  You can insert or replace portions of this code.
#
# If we didn't replace this text when we created the learn script, it would seem as though people should be making the changes
# to the learn script and not this one.  See the replacement for 1acc396a-02a2-40b8-a427-f4685c20320e in learn-replace for more.
#
# Insert exercises or elements that are specific to your site with "# insert <GUID>".  If you put a space after the GUID,
# you can add comments.  Replace parts with "# replace start <GUID>" and "# replace end <GUID>".  To remove sections,
# replace the content with nothing.  Put the replacements in the learn-replace file.
#
# replace end 1acc396a-02a2-40b8-a427-f4685c20320e

# Setting nounset is worth having to sometimes reference variables as ${VAR:-}.
set -e -o nounset

# insert 17fa07e6-24b8-4e35-bc1a-094427fd8699

if [ `whoami` == "root" ]; then
	echo "Run this script as yourself, not the root user.  (Don't use dzdo or sudo.)"
	exit 1
fi

less_prompt_move_on="Press h for help;?e: Enter for more (line %lb of %L).?e q to move on."
less_prompt_quit="Press h for help;?e: Enter for more (line %lb of %L).?e q to quit."

file_clean_up_array=()

clean_up() {
	if [ -n "${file_clean_up_array:-}" ]; then
		for item in $file_clean_up_array; do
			rm -f $item
		done
	fi
}

# It's a trap!  Run the clean_up subroutine on normal or aborted exit.
trap clean_up EXIT

if stty --version 2>/dev/null | grep -q 'coreutils'; then
    stty_options='-a'
else
    stty_options='everything'
fi

# insert ffa9e74e-2b02-4d72-9c82-9f9db2915c62 associative arrays for exercises and belt levels

get_rows_and_columns() {
	STTY_ROWS=`stty ${stty_options} | grep -Po "(?<=rows )[0-9]*(?=;)"`
	STTY_COLUMNS=`stty ${stty_options} | grep -Po "(?<=columns )[0-9]*(?=;)"`
	if (($STTY_ROWS > 50)); then
		WIDTH=`expr $STTY_COLUMNS - 5`
	else
		WIDTH=$STTY_COLUMNS
	fi
}

get_rows_and_columns

resize_to_default() {
	printf "\033[s\033[8;24;80t\033[u"

	echo -n "Resizing..."
	sleep 1

	get_rows_and_columns

	if (($STTY_ROWS < 24)) || (($STTY_COLUMNS < 80)); then
		fmt -u --width=$WIDTH <<EOL
It looks like the automatic resize didn't work.  Continue anyway (y/N)?
EOL

		if [[ ! "$CHOICE" =~ ^\s*[Yy].* ]]; then
			exit 1
		fi
	fi
}

# The following function deals with matters relating to the terminal size.
size_matters() {
	get_rows_and_columns

	# PuTTY uses a default size of 80x24, though 80x25 tends to be more of a standard (because of VT100 terminals).
	# TODO:  handle both
	if [ "$STTY_COLUMNS" == 80 ] && [ "$STTY_ROWS" == 24 ] && [ -z "${RESIZED_ALREADY:-}" ]; then
		fmt -u --width=$WIDTH <<EOL
It looks like your terminal is set to the default size of 80 columns and 24 rows.  This script is capable of using more.
If you're able to change the size of the terminal, please do so, then press Enter to continue.
EOL

		echo ""
		read

		get_rows_and_columns

		if (("$STTY_COLUMNS" < "80")) || (("$STTY_ROWS" < 24)); then
			fmt -u --width=$WIDTH <<EOL
Oh!  A wise guy!  How about we change that back to the default (Y/y)?
EOL

			read CHOICE

			# We already know the terminal can support 80x24.  Time for a bit of fun.
			if [ -n "${CHOICE:-}" ] && [[ ! "${CHOICE:-}" =~ ^\s*[Yy].* ]]; then
				echo "That's a funny way to spell it but that will do just fine."
			fi

			resize_to_default
			echo ""
		else
			TERM_SIZE="${STTY_COLUMNS}x$STTY_ROWS"

			FMT_STRING=""

			if (("$STTY_COLUMNS" >= "200")) && (("$STTY_ROWS" >= 40)); then
				FMT_STRING="What, $TERM_SIZE?!  Seriously?  Now you're just showing off."
			elif (("$STTY_COLUMNS" >= "170")) && (("$STTY_ROWS" >= 35)); then
				FMT_STRING="Wow, $TERM_SIZE?  Luxurious!  There's plenty of room now."
			elif (("$STTY_COLUMNS" >= "130")) && (("$STTY_ROWS" >= 30)); then
				FMT_STRING="Wow, $TERM_SIZE?  Very spacious!"
			elif (("$STTY_COLUMNS" >= "120")) && (("$STTY_ROWS" >= 30)); then
				FMT_STRING="OK, $TERM_SIZE.  That's very respectable."
			elif (("$STTY_COLUMNS" >= "120")) && (("$STTY_ROWS" >= 25)); then
				FMT_STRING="Alright, $TERM_SIZE.  That will do just fine."
			fi	

			if [ -n "${FMT_STRING:-}" ]; then
				fmt -u --width=$WIDTH <<EOL
$FMT_STRING
EOL
			fi

			echo ""
		fi
	fi
}

# Run "grep" on this file and pipe it to "wc" to count the number of exercises for the current belt.
set_num_exercises() {
	regex="'"
	regex+="${RANK}_exercise_.*\(\)"
	regex+="'"
	NUM_EXERCISES=$(bash -c "grep -E ${regex} ~/bin/learn | wc -l")
}

set_num_exercises_for_review() {
	regex="'"
	regex+="${new_rank}_exercise_.*\(\)"
	regex+="'"
	NUM_REVIEW_EXERCISES=$(bash -c "grep -E ${regex} ~/bin/learn | wc -l")
}

print_rank() {
	# Use an extra ${nc} to fix an issue with PuTTY.
	if [ -n "${SAVED_RANK:-}" ]; then
		if [ "$SAVED_RANK" == "white_belt" ]; then
			printf "Your current rank is `getBeltWithColours white_belt`.\n"
			printf "You are working toward your `getBeltWithColours yellow_stripe`.\n\n"
		elif [ "$SAVED_RANK" == "yellow_stripe" ]; then
			printf "Your current rank is `getBeltWithColours yellow_stripe`.\n"
			printf "You are working toward your `getBeltWithColours yellow_belt`.\n\n"
		elif [ "$SAVED_RANK" == "yellow_belt" ]; then
			printf "Your current rank is `getBeltWithColours yellow_belt`.\n"
			printf "You are working toward your `getBeltWithColours green_stripe`.\n\n"
		fi

		belt=$(getBeltWithColours $RANK)
		printf "You are reviewing the exercises for ${belt}.  "
		printf 'To return to where you were, execute "learn --return".\n\n'
	else
		if [ "$RANK" == "white_belt" ]; then
			printf "Your current rank is `getBeltWithColours white_belt`.\n"
			printf "You are working toward your `getBeltWithColours yellow_stripe`.\n\n"
		elif [ "$RANK" == "yellow_stripe" ]; then
			printf "Your current rank is `getBeltWithColours yellow_stripe`.\n"
			printf "You are working toward your `getBeltWithColours yellow_belt`.\n\n"
		elif [ "$RANK" == "yellow_belt" ]; then
			printf "Your current rank is `getBeltWithColours yellow_belt`.\n"
			printf "You are working toward your `getBeltWithColours green_stripe`.\n\n"
		fi
	fi
}

complete_exercise() {
	less -R -P "$less_prompt_quit" $fmt_file

	# Print the exercise (or the last part of the exercise) to the terminal.  Since "less" cleans up after itself, if we
	# don't do this, the user has nothing to reference to finish the task.
	cat $fmt_file
}

# insert 37333148-8746-4468-826e-544e532f1ebc updateDotFile, getBeltWithColours

white_belt_exercise_what_execute_means() {
	yellow_stripe="${yellow_on_black}yellow ${nc}${bright_white_on_black}stripe${nc}"
	printf "${underline}The Bare Essentials${no_underline}\n\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
In the United States and Canada, grammar rules say to put the period inside the double quotes.

    He told me, "You need to go to the store."

We will follow https://en.wikipedia.org/wiki/Quotation_marks_in_English#Logical_quotation
rules (also called British practice, British style, and logical punctuation).

If this script says to execute "set", that means to type the letters s, e, t, and press Enter.  Don't type the double quotes.

If an exercise asks you to execute "scp bcompcd101:/tmp/file.txt ." then the space and dot at the end, before the final
double quote, are important and must be typed before pressing Enter.

At the end of a sentence, you will see: "scp bcompcd101:/tmp/file.txt .".

To see the overview of what is covered in each belt, execute "learn --welcome".

The exerices leading to your yellow stripe will have more reading and rote completion.  As you rise through the ranks,
fewer steps will be directly stated.  This script will provide resources for you to reference to finish the exercises.
In particular, this exercise has the most reading and the least to do.
EOL

	printf "\n\n${underline}Your Prompt${no_underline}\n\n" >> $fmt_file
	x="$(PS1=\"$PS1\" echo -n | bash -i 2>&1)"
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
Your current prompt is as follows.

${x%exit}

When you see your prompt, that means that the previous commands have completed and your shell is ready for another command.
(We'll be going into more detail on shells later.)  Prompts are one of the most heavily customized aspects of Unix, ranging
from a simple dollar sign to multi-line creations.  You should expect your prompt to look similar across different computers
(or hosts) run by the same people, but different as you move elsewhere.
EOL

	printf "\n\n${underline}I'm Stuck!${no_underline}\n\n" >> $fmt_file
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
It's always a good idea to take notes, because it helps with recall.  But there a few things this script will specifically
call out for you to make a note of, things you're always going to want to have handy.  Take them down in whatever style you
like (Evernote, a personal wiki, on your phone, Microsoft OneNote, a mind map, or good old pen and paper) but make sure it
will be available whenever you're at a Unix terminal.

Your interrupt character is Ctrl+c (don't type it now, but in order to type it, hold one of the Ctrl keys down and press
the "c" key.  Do not use either Shift key.)  There are only a few cases where typing Ctrl+c will not stop what's happening
and return you to a prompt.  We will be covering two of these soon.  Make a note of it.
EOL

	printf "\n\n${underline}Moving On${no_underline}\n\n" >> $fmt_file
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
After reading the text for each exercise, you will need to
quit the lesson by pressing "q" (which will return you to your prompt).  You can then complete anything the exercise asked
you to do.

Your first task is to execute ". check".
EOL

	complete_exercise
}

white_belt_exercise_stuck() {
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The first thing you don't want to be caught by is Ctrl+q and Ctrl+s.  If you accidentally type Ctrl and "s", the terminal will
freeze.  Ctrl+s is easy to type and is in common use in Windows programs as a keyboard shortcut for saving the current file.
Depending on your background, it may be second nature to you to type it when you want to save something.

If you find that your terminal is locked, frozen, or in a weird state, the first thing you should do is type Ctrl+c.
The second thing you should try is typing Ctrl+q (Ctrl with a lowercase "q", or equivalently:  Ctrl and "q" but not
including shift).

Ctrl+q and Ctrl+s are holdovers of an ancient age when it was more common to print output to a printer than a screen.
Printers were much slower and needed time to catch up.

Please make a note of these now.  There will be a question later about it.

Execute ". check".
EOL

	complete_exercise
}

white_belt_exercise_cd_root() {
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
First things first:  you need to know how to navigate.

All files and directories have a path which tells the operating system how to retrieve them.  You may be familiar with
Microsoft Windows-style paths such as C:\\Windows\\System\\.  When you insert a USB drive, Windows usually assigns the drive
letter E: to the new disk, unless it's already taken.  Unix doesn't have drive letters.  Instead, all disks (local disks,
shared drives, and removeable disks) are in one unified filesystem.  In a future exercise, we'll look at how data is brought
in from shared and removeable drives.

In Unix, paths use forward slashes ( / ) instead of backslashes.  The path to your home directory is $HOME.  Your home
directory contains everything that's only for you:  configuration settings.  More generally, anything you're working on
that isn't shared with other users will be in $HOME.

You may have a $HOME/bin directory for programs that are only for you.  There are multiple directories called "bin" on a
Unix system.  The one in your home directory contains programs (compiled binaries, scripts, and anything that runs) for your
use only.  For example, some people set up a particular version of a common program that has different features.  You may
want to have scripts that automate certain tasks that are too specific for other users to use, and they should go in $HOME/bin.

Windows usually uses the term "folder" as an equivalent term for "directory".

When you ran this script, you were in the `pwd` directory.

Let's begin at the beginning:  the root directory.  (Not to be confused with the /root directory.)
EOL

	less -R -P "$less_prompt_move_on" $fmt_file

	# Print the exercise to the terminal to retain context.
	cat $fmt_file

	echo ""

	echo 'Execute "cd /".'
	echo 'Then execute ". check"'
}

white_belt_exercise_ls_root() {
	# If the user is coming back after needing to look at something else, they may now be in another directory.
	if [[ `pwd` == "/" ]]; then
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
It's time to take a look around.  Execute "ls", read the names of the directories, and execute ". check".
EOL
	else
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
It's time to take a look around.  Execute "cd /", execute "ls", read the names of the directories, and execute ". check".
EOL
	fi

	complete_exercise
}

white_belt_exercise_common_root_directories() {
	# The existence of /opt can't be counted on, but it's hard to imagine the rest would be missing on any modern
	# Unix derivative.  Maybe this script is being run in a Docker container.  Handling missing directories, formatting
	# to the TTY size, and paging the whole thing using was a chance to sharpen my skills.
	# It's also a good reference for redirecting output from a program that already has a heredoc coming in.

	set +e
	ROOT_USERNAME=$(bash -c 'getent passwd "0" 2> /dev/null | cut -d: -f1')
	set -e
	ROOT_TEXT=""

	if [ -n "${ROOT_USERNAME:-}" ] && [ "$ROOT_USERNAME" != "root" ]; then
		ROOT_TEXT="On this system, the administrator account is called $ROOT_USERNAME."
	fi

	# $ROOT_TEXT should be at the end of the line so the formatting works out.
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
For the following notes, keep in mind that the root user (usually simply called "root") is the administrator account.  $ROOT_TEXT
The root user has access to everything and is allowed to do everything, unless permissions have been deliberately given up.
A simple example is making a file read only.  The root user can put up blocks to make things more difficult to do, but the
root user could remove them at any time.
EOL

	printf "\nHere are some of the things you saw.\n" >> $fmt_file

	if [ -d "/bin" ]; then
		printf "\n${underline}/bin${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Stands for BINaries (programs that aren't scripts).  The core binaries are here, like "ls". 
EOL
	fi

	if [ -d "/etc" ]; then
		printf "\n${underline}/etc${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  You'll find all system wide configuration here.
EOL
	fi

	if [ -d "/home" ]; then
		printf "\n${underline}/home${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Each user's home directory is under here.  Your home directory (/home/$USER) contains everything that's only for you,
  especially configuration files.  In most Unix enviroments, your home directory is shared across multiple servers so your
  configuration settings are available across multiple servers.  On Macs, this directory (if it exists) will usually be
  empty, and all the users' home directories will be in /Users instead.
EOL
	fi

	if [ -d "/opt" ]; then
		printf "\n${underline}/opt${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Sometimes seen on Red Hat Linux servers, the /opt directory is for OPTional software that's not part of the distribution.
  (If you want, you can look up what a Linux distribution is.)  You might find an Oracle DB instance or a Dynatrace OneAgent
  installed here.
EOL
	fi

	if [ -d "/root" ]; then
		printf "\n${underline}/root${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  The root user's home directory (set aside for the root user's personal use).  Depending on the installation, the /root
  directory can sometimes be used in emergencies if other parts of the filesystem are full.
EOL
	fi

	if [ -d "/sbin" ]; then
		printf "\n${underline}/sbin${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Stands for Secure BINaries.  Binary programs (not scripts) that are run only by privileged users go here.  For example,
  the programs that change network configurations are here, as well as programs for other system maintenance and starting up the
  operating system.
EOL
	fi

	if [ -d "/tmp" ]; then
		printf "\n${underline}/tmp${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Short for TeMP, this directory is where any temporary files are created.  Well-behaved programs should clean up after
  themselves.  Most systems are configured to delete any files that haven't been modified in a week (two weeks is also common).
EOL
	fi

	if [ -d "/Users" ]; then
		printf "\n${underline}/Users${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Each user's home directory is under here.  On most flavors of Unix, home directories are under /home instead.
  Your home directory ($HOME) contains everything that's only for you, particularly configuration files.  In most
  Unix enviroments, your home directory is shared across multiple servers so your configuration settings are available
  across multiple servers.
EOL
	fi

	if [ -d "/usr" ]; then
		printf "\n${underline}/usr${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Short for "user", i.e. for "regular" users and not the root user.  Most programs are under here somewhere (/usr/bin,
  /usr/local/bin, /usr/sbin, /usr/local/sbin).
EOL
	fi

	if [ -d "/var" ]; then
		printf "\n${underline}/var${no_underline}\n" >> $fmt_file
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Short for VARiable, this directory is for things that are constantly changing, particularly:  log files, caches, mail, and
  printer queues.
EOL
	fi

	echo "" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
For a full list, see https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard.

EOL
	

	if [[ `pwd` == "$HOME" ]]; then
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
This exercise was going to ask you to go back to your home directory, but you're already there.  Use the "cd" command to
change directory to somewhere else (like "cd /").  You can any one of the following commands to return to your home directory.
Then execute ". check".
EOL
	else
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
Let's return to your home directory.  The following commands are equivalent.  Execute one of them, then execute ". check".
EOL
	fi

	echo "" >> $fmt_file
	echo "cd" >> $fmt_file
	echo "cd ~" >> $fmt_file
	echo "cd $HOME" >> $fmt_file
	echo "cd ${HOME}/" >> $fmt_file

	complete_exercise
}

white_belt_exercise_set() {
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
There are four ways to pass settings to programs:  environment variables, arguments, standard input, and configuration files.

We will be looking at environment variables.  The "set" command will show you the current environment variables.
If you run it as is, most of the output will scroll past, but go ahead anyway and execute "set".

Remember to execute ". check" after.
EOL

	complete_exercise
}

white_belt_exercise_frozen() {
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
It's time for the first test.  Make sure your notes are handy and execute ". check".
EOL

	complete_exercise
}

white_belt_exercise_set_more() {
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
To go page by page, add "| more" to a command.  The pipe ( | ) can be used to send the output of one command to the input
of another command.  We'll be going into more detail on pipes later.  The pipe character is rarely used outside
of technical fields.  On many keyboard layouts, you can type it with Shift+Backslash.

When you execute "set | more", you will be able to move a page at a time by pressing Space.  Move a line at a time by
pressing Enter.  To quit before the end, press "q".  With some flavours of Unix, if you quit before the end, you will see
a warning about a broken pipe.  Execute "set | more" now and remember to execute ". check" after.
EOL

	complete_exercise
}

white_belt_exercise_set_less() {
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The "more" command will only give you more.  If you want to back up, add "| less" to a command.  In many cases (but depending
on your terminal settings) you will be able to move up and down with the cursor keys and use the Page Up and Page Down keys.
As before, Space will go a page forward, Enter will show one more line, and "q" will quit.

Most commands will quit when you type Ctrl+c, but "less" doesn't quit by default with Ctrl+c.  When you press Ctrl+c in
"less", it will stop whatever you're doing within "less".  For example, when you have "less" open you can search
for something, which might take a long time if it's a big file.  You can stop the search by pressing Ctrl+c.  You will need
to press "q" to quit.  Take a note.  If you miss it, you will be stuck, just as with Ctrl+s.

Execute "set | less" and remember to execute ". check" after.
EOL

	complete_exercise
}

white_belt_exercise_path_and_sourcing() {
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
We're going to look at one specific environment variable now:  \$PATH.  Environment variables are usually printed with a
dollar sign ( \$ ) in front of them.  Currently, \$PATH is set to the following value.

$PATH
EOL

	echo "" >> $fmt_file

	# I copied this code from Stack Overflow.  It's probably overkill.
	# https://stackoverflow.com/questions/4774054/reliable-way-for-a-bash-script-to-get-the-full-path-to-itself
	script_path="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P )"
	script_name=`basename $0`

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
\$PATH contains a list of paths where programs might be found (scripts, binaries, and anything that can be run).

This script is in $script_path and the full path to it is $script_path/$script_name.  
EOL

	echo "" >> $fmt_file
	# Use positive lookbehind and positive lookahead to match the exact path, whether it's at the beginning of the
	# $PATH, the end, or in the middle.  This way, we can both highlight the exact path and # show the entire $PATH.
	# It won't work if the path in $PATH has a trailing slash, but trailing slashes shouldn't be there.
	printf '%s\n' "$PATH" | grep -P --color=always "(?<=^|:)${script_path}(?=:|\$)" >> $fmt_file
	echo "" >> $fmt_file

	less -R -P "$less_prompt_move_on" $fmt_file

	fmt -u --width=$WIDTH <<EOL > $fmt_file
The \$PATH environment variable lists all the directories where programs can be found.  On Windows, the current directory
is always checked first for commands, operable programs, or batch files.  On Unix, typically the current directory is never
in the \$PATH.

Consider the case where a friend or coworker has made their own /home/user/bin directory available for you to look at.
If they prefer different versions of common tools, like "ls" to get a directory listing, then you will unwittingly run their
version if you are in their /home/user/bin directory.  Normally, such cases are not malicious, but they may be surprising
or confusing.  Unix and all its derivatives are known for a philosophy that prioritizes consistency and security over
convenience.

If you want to run a command in the current directory and you have the appropriate permissions, you can add "./" to the
beginning of it, but we're not going to do that right now.

You've run the "learn" and "check" scripts from two different places (the root directory and your home directory) and
neither one is where the scripts are.  The \$PATH environment variable provides your bin directory as one place to look
for programs, so you can run anything found in your \$PATH wherever you are.
EOL

	echo "" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The last thing to teach you before you get your yellow stripe is why you need to add the dot and space at the beginning
of the "check" script.  Normally, when you run a program, it runs in its own process.  The new instance of the program
(the child) gets a copy of the current set of environment variables, and any environment variables that are changed are
not reflected in the parent.

By executing ". check" (or equivalently, "source check") instead of "check", the program runs as if it was typed in.
This "sourcing" trick is how we can have scripts that set environment variables for other scripts.  It can also be used to
get an up-to-date command history (which is normally inaccessible).  Since running the "set" command doesn't change anything,
accessing the command history is the only way to verify that the correct command was issued.

Once you have read and understood this text, execute ". check"
EOL

	complete_exercise
}

yellow_stripe_exercise_pwd() {
	if [[ `pwd` == "/" ]]; then
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
To begin this exericse, you can't be in the root directory.  Execute "cd", then execute "learn".
EOL
		complete_exercise
		exit 0
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The theme of the yellow stripe exericses is creating files and directories, and in particular, characters that should be avoided.
We will also be looking at the special directories "." and "..".

As you rise through the ranks, fewer steps will be directly stated.  You should be familiar with pressing "q" to quit the
lesson so you can go back to a prompt and continue, and executing ". check" to confirm that you can go on to the next
exercise.  In between will be whatever the lesson requires, which will generally be to execute a command of some sort.

Before we move around, you should have a better sense of where you are.  The "pwd" command stands for "Print Working
Directory" and tells you the full path to your current working directory.  Try it now.
EOL

	complete_exercise
}

yellow_stripe_exercise_cd_dot_dot() {
	if [[ `pwd` == "/" ]]; then
		fmt -u --width=$WIDTH <<EOL >> $fmt_file
To begin this exericse, you can't be in the root directory.  Execute "cd", then execute "learn".
EOL
		complete_exercise
		exit 0
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The directory "." is a special directory that refers to the current directory.  All directories have a "." directory and
it cannot be removed.  The following paths all reference the same directory.

EOL

	echo "$HOME" >> $fmt_file
	echo "$HOME/." >> $fmt_file
	echo "$HOME/./." >> $fmt_file
	echo "$HOME/././." >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

The "." directory can be useful to provide as a source or destination.

For example, the secure copy "scp" program securely copies files and folders between computers.  It requires at least one
source and exactly one destination.

scp user@othercomputer:/home/user/fileToGet .

The command above copies the file /home/user/fileToGet into the current directory.
EOL

printf "\n\n${underline}The Parent Rescue${no_underline}\n\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The special directory ".." refers to the parent directory.  The following paths point to the same directory.

EOL

	echo "/home/" >> $fmt_file
	echo "/home/example/.." >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

All of these following paths also point to the same directory (a different one than the one above).

EOL

echo "/home/example/" >> $fmt_file
echo "/home/example/../example/" >> $fmt_file
echo "/home/example/../example/../example/" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

In the white belt exercises, you went from your home directory to the root directory, then back.  This
time, we'll look at each step along the way.  To go one directory up, execute "cd ..".  In many cases,
"cd.." will also work.  Execute "pwd", then "cd ..", then "pwd", then "cd ..".  If you're not in the root directory by
then, continue until you are.
EOL

	complete_exercise
}

yellow_stripe_exercise_no_news_is_good_news() {
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
When it comes to Unix, always remember:  no news is good news.

The oldest and most core programs ("cp, "mv", "rm", etc.) will only print something if there was a problem.
If you get a prompt and nothing more, the program did as you asked.  If something went wrong, the program
or your shell would've told you.

Although this point is easy to explain, it's quite important, and so it has its own exercise.
EOL

	complete_exercise
}

yellow_stripe_exercise_mkdir_and_relative_paths() {
	if [ ! -d $LUS_HOME ]; then
		mkdir $LUS_HOME
	fi
	
	if [ -d $LUS_HOME/parent ]; then
		less -R -P "$less_prompt_move_on" $fmt_file
	
		fmt -u --width=$WIDTH <<EOL
This exercise involves creating the directory $LUS_HOME/parent, which already exists.  You will need to move it or rename
it by executing "mv $LUS_HOME/parent newname", then executing "learn" again.
EOL

		exit 2
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The "mkdir" command creates directories.  Given what you know about "." and "..", think about the following commands.

EOL

	echo "cd $LUS_HOME" >> $fmt_file
	echo "mkdir parent" >> $fmt_file
	echo "cd parent" >> $fmt_file
	echo "mkdir one" >> $fmt_file
	echo "cd one" >> $fmt_file
	echo "mkdir ../two" >> $fmt_file
	echo "mkdir ../three" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

Once you've thought about it, execute the commands.  Please be careful when entering them.  If you get it wrong, you'll
have to rename the parent directory and start from the beginning.  You can delete your attempts later when you have
more experience.

Use "cd" and "ls" to go through the directories and take a look at what you've done.  See if you were right about what
they would look like.  If they look different than you expected, think about why.  (And when you're all done with all of that,
execute ". check".)
EOL

	complete_exercise
}

yellow_stripe_exercise_rmdir() {
	if [ ! -d $LUS_HOME ]; then
		mkdir $LUS_HOME
	fi
	
	if [ ! -d $LUS_HOME/parent ] || [ ! -d $LUS_HOME/parent/one ] || [ ! -d $LUS_HOME/parent/two ] || [ ! -d $LUS_HOME/parent/three ]; then
		fmt -u --width=$WIDTH <<EOL
This exercise involves removing directories created in a previous exercise.  At least one of them doesn't exist.  Create them (y/n)?
EOL
		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			mkdir -p $LUS_HOME/parent/one
			mkdir -p $LUS_HOME/parent/two
			mkdir -p $LUS_HOME/parent/three
		else
			exit 2
		fi
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The "rmdir" command removes directories.  The directory must be empty for "rmdir" to work.  We will look at deleting whole
trees of directories later.  Read these commands and see if you can follow what they do.

EOL

	echo "cd $LUS_HOME" >> $fmt_file
	echo "rmdir parent/one" >> $fmt_file
	echo "cd parent" >> $fmt_file
	echo "rmdir two" >> $fmt_file
	echo "rmdir three" >> $fmt_file
	echo "cd .." >> $fmt_file
	echo "rmdir parent" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

Once you've thought about it, execute the commands.  Please be careful when entering them.  If you get it wrong, when you
run "learn" again, you can choose to create any missing directories so you can try again.
EOL

	complete_exercise
}

yellow_stripe_exercise_special_characters() {
	if [ ! -d $LUS_HOME ]; then
		mkdir $LUS_HOME
	fi
	
	if [ -f $LUS_HOME/yellow ]; then
		less -R -P "$less_prompt_move_on" $fmt_file
	
		fmt -u --width=$WIDTH <<EOL
This exercise involves creating the file $LUS_HOME/yellow, which already exists.  Delete it (y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			rm -f $LUS_HOME/yellow
		else
			exit 2
		fi
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
We're going to switch focus to filenames, file types, and how to look at file contents.

Windows is up front about the characters that you're not allowed to use in a file or directory name.  They are as follows.

\ / : * ? " < > |

Unix will let you use any character on the keyboard in a file or directory name, except for "/", which is used to create paths.
Problems crop up later.

If you use a colon ":" in a file or directory name, you won't be able to add it to your \$PATH, though it's not a big deal
in most cases.  Historically, Macs used colon ":" for the same purpose as Unix uses "/", so various programs will accept
one and not the other.  Programs will convert between them.  Avoid colons on Macs.  If a Mac program lets you use
a slash "/" in a file or directory name, don't.

Spaces in file and directory names can also be problematic.  It takes more effort to write scripts that handle files with
spaces in them, so it's not hard to find scripts that were never written to handle them.

Files starting with a dash are particularly difficult to handle.  Unix programs almost always take options that start with
a dash.  For example, the copy command "cp" takes an argument "-R" for copying a directory and everything under it to a
new location.  The "R" stands for recursive.

cp -R /tmp/foo /tmp/bar

If you want to copy a file called "-R" and a file called "foo" in "/tmp/" to "/tmp/bar" then you could use the following command.

cp -- -R /tmp/foo /tmp/bar

The core tools (like copy "cp", move "mv", and remove "rm") support the "--" argument to indicate all the options are done
and everything after that is a file or directory.  Don't expect other programs will be able to work with files that start
with a dash.

The other special characters that aren't allowed on Windows are a little easier to work with, though you'll need to put the
file name in single quotes (not double quotes).  We'll do more with single quotes and double quotes soon.

Another thing to keep in mind is that Unix filesystems are usually case-sensitive.  If you create a file called test and try
to open a file called Test, you will receive an error that the file cannot be found.

Execute the following commands, remembering that Unix is case sensitive.  It will create a new file with the filename "yellow".

EOL

	echo "cd $LUS_HOME" >> $fmt_file
	echo 'echo "Hello world." > yellow' >> $fmt_file

	complete_exercise
}

yellow_stripe_exercise_file() {
	if [ ! -d $LUS_HOME ]; then
		mkdir $LUS_HOME
	fi
	
	if [ ! -f $LUS_HOME/yellow ]; then
		less -R -P "$less_prompt_move_on" $fmt_file
	
		fmt -u --width=$WIDTH <<EOL
The previous exercise involves creating the file $LUS_HOME/yellow, but it doesn't exist.  Create it (y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			echo "Hello world." > $LUS_HOME/yellow
		else
			exit 2
		fi
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
Now that you've created the file $LUS_HOME/yellow, let's look at ways to see what's in it.

Windows popularized the idea of file extensions (foo.bat is a batch file, foo.txt is a text file, foo.doc is a Microsoft
Word document, etc.)  Unix doesn't require extensions, though it's quite common to see them.  Instead of using a file
extension, Unix uses the first few bytes of a file to tell what kind of file it is.  This file type detection process
is called "file magic" or sometimes "magic".  The file that stores the bytes and mappings is usually named "magic".
The program that can check a file's type is named "file".

Execute "cd $LUS_HOME", then execute "file yellow".
EOL

	complete_exercise
}

yellow_stripe_exercise_cat_less() {
	if [ ! -d $LUS_HOME ]; then
		mkdir $LUS_HOME
	fi
	
	if [ ! -f $LUS_HOME/yellow ]; then
		less -R -P "$less_prompt_move_on" $fmt_file
	
		fmt -u --width=$WIDTH <<EOL
A previous exercise involves creating the file $LUS_HOME/yellow, but it doesn't exist.  Create it (y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			echo "Hello world." > $LUS_HOME/yellow
		else
			exit 2
		fi
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
The simplest way to see what's in a file is with the "cat" command (which is short for conCATenate).  Before you use "cat"
you need to know that it's a small file.  (We'll look at file sizes later.)  If you accidentally "cat" a large file, your
terminal may be stuck for a while.

In a previous exercise, you executed "set | less", but you can also provide an argument to "less" to use "less" to look at a file.
It's safe to use "less" on large files.  Remember that you need to press "q" to quit less.

Execute "cd $LUS_HOME", then execute "cat yellow", then execute "less yellow".
EOL

	complete_exercise
}

yellow_stripe_exercise_quotes() {
	set +o nounset
	x="$(PS1=\"$PS1\" echo -n | bash -i 2>&1)"
	PS2=$(bash -ci 'echo $PS2')
	set -o nounset

	non_default_PS2=""
	if [ "$(simple_trim $PS2)" != ">" ]; then
		non_default_PS2="(On your system, it's different.)  "
	fi

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
We're going to change focus one more time and look at single and double quotes.

Double quotes are one way to work with filenames that have spaces in them.  Single quotes are one way to work with filenames
that have special characters in them.  But before we look at how they can be helpful, let's look at what can happen when
things go wrong.

For example, let's assume you've typed "echo", followed by a space, and then a double quote, and finally press Enter.
You'll see the following.

${x%exit} echo "
EOL

	echo "$PS2" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file

In most cases, the character on the second line is a right angle bracket ( > ).  ${non_default_PS2}Single quotes
and double quotes must have a matching single or double quote.  (Experts:  we'll look at escaping shortly.)  The right
angle bracket or other prompt tells you that you started some quoted text but didn't finish it.  The shell is letting you
finish it.  The Enter you typed will be part of the final string you're making.  In most cases, this situation is a mistake.
Ctrl+c to the rescue!

We're going to use the "echo" command for these examples, but remember that you can use these strings of characters in a
lot of different situations.  Try out the following.

EOL

	fmt -u -s --width=$WIDTH <<EOL >> $fmt_file
echo "HOME"
echo "\$HOME"
echo '\$HOME'
EOL

	complete_exercise
}

yellow_stripe_exercise_escaping_quotes() {
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
Double quotes let you use environment variables.   If you want to work with a file that has a dollar sign, you need to
use single quotes.  Now is a good time to talk about literals.  Your shell treats a lot of characters in a special way.
The pipe ( | ) is used to connect two programs together.  The right angle bracket ( > ) sends a program's output to a file.
But what if you want to use them exactly as they are?  Then you need them to be literals.  A literal pipe is a pipe that
means exactly what it is (and not a direction to the shell to connect two programs together).  If you're using double quotes
and you need to put a literal double quote, then you use the backslash character ( \\ ).  On most keyboards, it's above the
Enter key.  It's usually on the same key as pipe ( | ).

Try the following.

EOL

	fmt -u -s --width=$WIDTH <<EOL >> $fmt_file
echo "\"HOME\""
echo "\"\$HOME\""
echo "'\$HOME'"
EOL

	complete_exercise
}

yellow_stripe_exercise_quote_finale() {
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
You might think that you could also escape a single quote to use it inside single quotes.  There are some shells that handle
it, but you shouldn't expect it.  What you can do instead is end the single quote, put a single quote in double quotes, and
then start the single quote again.

When it's broken out, it looks like this.

'First section' "'" 'Second section'

But that's a list of three arguments.  If you need to refer to a filename, you'll need to remove the spaces.  (Yes, it's
difficult to read.)

'First section'"'"'Second section'

If you need to work with a filename that has single quotes, it's best to put the whole thing in double quotes.

"First section'Second section"

If you have single quotes, double quotes, and other special characters like dollar sign ( $ ), you may be better off using
the trick above.

Execute ". check" for your final exam.
EOL

	complete_exercise
}

ask_about_putty_font_size() {
	fmt -u --width=$WIDTH <<EOL
Was that text comfortable to read?  It looks like you're connected with SSH, so chances are, you're using PuTTY.
If you're using PuTTY, would you like any help to increase the font size (y/N)?
EOL

	read CHOICE

	if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
		fmt -u --width=$WIDTH <<EOL
Right click on PuTTY's title bar and select "Change Settings".  In the left navigation pane, select Window >
Appearance.  Click the "Change..." button about halfway down the right pane.  Select a new font size and
click "OK".  Click "Apply".  When you're happy with the settings, right click on PuTTYs title bar, go to
Session in the left navigation pane, select the session, and click "Save".
EOL

	size_matters

	echo ""

	fi
}

welcome() {
	fmt_file=$(mktemp --suffix=_$(whoami))
	file_clean_up_array+=($fmt_file)

	fmt -u --width=$WIDTH <<EOL > $fmt_file
When you see a prompt like "Press h for help; Enter for more", press Enter for one more line and Space for one more page.

If there's more text than will fit in your terminal, the Up and Down arrow keys should work in addition to Enter and Space
(but it depends on your terminal settings).  Press "h" for other alternatives.

If all the text fits in your terminal, you'll immediately see a prompt to press "q".  Pressing Enter, Space, or the arrow
keys will have no effect.

At the bottom of the text (or immediately if all the text fits) the prompt will change, asking you to press "q" to move on
(or quit if it's the end of the lesson).  Once you're done reading all the text (including right now) press "q".
EOL

	less -R -P "$less_prompt_move_on" $fmt_file

	fmt -u --width=$WIDTH <<EOL > $fmt_file
The following notes are an overview of what will be covered in this course.
It's likely that you will only understand them if you already have some
experience with them.  Consider them like chapter headings in a textbook you recently received.
EOL

	printf "\n${underline}Beginner and Intermediate Ranks${no_underline}\n" >> $fmt_file

	printf "\n${bright_white_on_black}White Belt${nc}\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  In a martial arts club (or dojo) a student gets their white belt when they buy a uniform and sign up for classes.  In this
  case, a student gets their white belt when they run the learn script and choose to get started.
EOL

	echo "" >> $fmt_file

	# Use an extra ${nc} to fix an issue with PuTTY.
	printf "${yellow_on_black}Yellow ${nc}${bright_white_on_black}Stripe${nc}\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Understanding \$PATH and environment variables.
EOL

	echo "" >> $fmt_file
	printf "${yellow_on_black}Yellow Belt${nc}\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Creating and deleting directories; . and ..; pwd; cd
EOL

	echo "" >> $fmt_file
	printf "${green_on_black}Green ${yellow_on_black}Stripe${nc}\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  File types; intermediate arguments to ls; mounts and disk space
EOL

	printf "\n\n${underline}Advanced Ranks${no_underline}\n" >> $fmt_file

	printf "\n${green_on_black}Green Belt${nc}\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Hidden files and directories; globbing; directory stacks
EOL

	echo "" >> $fmt_file
	printf "${blue_on_black}Blue ${green_on_black}Stripe${nc}\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Pipes; tee; redirection; head, tail, sort, grep
EOL

	echo "" >> $fmt_file
	printf "${blue_on_black}Blue Belt${nc}\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Finding large files and directories with du, sort, and head; rm; rmdir; mv
EOL

	echo "" >> $fmt_file
	printf "${red_on_black}Red ${blue_on_black}Stripe${nc}\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  ZIP and tar archives
EOL

	echo "" >> $fmt_file
	printf "${red_on_black}Red Belt${nc}\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Signals; stopping processes; ps; pgrep vs grep
EOL

	echo "" >> $fmt_file
	printf "${black_on_white}Black ${red_on_black}Stripe${nc}\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  Foreground and background tasks, jobs and &
EOL

	echo "" >> $fmt_file
	printf "${black_on_white}Black Belt${nc}\n" >> $fmt_file

	fmt -u --width=$WIDTH <<EOL >> $fmt_file
  User and group ownership; permissions; ls -ld; stat; namei
EOL

	echo "" >> $fmt_file

	less -R -P "$less_prompt_move_on" $fmt_file

	if [ ! -f ~/.learnUnix ] || [ -z "${RANK:-}" ] || [ -z "${EXERCISE:-}" ]; then
		if [ -n "${SSH_CONNECTION:-}" ] || [ -n "${SSH_TTY:-}" ]; then
			ask_about_putty_font_size
		fi

		size_matters

		fmt -u --width=$WIDTH <<EOL
If you type "y" and press Enter, then you will be given your first task.
EOL

		echo -n "Are you ready to begin (y/n)? "
		read CHOICE

		if [ "$CHOICE" == "" ]; then
			fmt -u --width=$WIDTH <<EOL
Implict consent is not enough this time.  To begin, you must choose.
EOL

			echo -n "Are you ready to get started (y/n)? "
			read CHOICE
		fi

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			clear
			RANK="white_belt"
			EXERCISE="1"
			updateDotFile

			print_rank > $fmt_file

			set_num_exercises

			echo "Exercise 1/${NUM_EXERCISES}" >> $fmt_file
			echo "" >> $fmt_file

			exercise_name=${exercises["${RANK}_1"]}
			function_name="${RANK}_exercise_${exercise_name}"
			eval $function_name
		fi
	fi
}

# All the function definitions are done.  The script will begin executing here.

if [ -f ~/.learnUnix ]; then
	source ~/.learnUnix
fi

if [ -z "${LUS_HOME:-}" ]; then
	LUS_HOME=$HOME/lus
fi

if [ ! -f ~/.learnUnix ] || [ -z "${RANK:-}" ] || [ -z "${EXERCISE:-}" ]; then
	if (($STTY_ROWS < 24)) || (($STTY_COLUMNS < 80)); then
		# We haven't introduced what Y/n means, but if the user has made a conscious choice to make their terminal
		# smaller, they probably already know.
		fmt -u --width=$WIDTH <<EOL
A minimum of 80 columns and 24 rows is strongly recommended.  Would you like to automatically update the terminal size to
the recommended minimum and continue (Y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[yY] ]] || [ -z "$CHOICE" ]; then
			resize_to_default
			RESIZED_ALREADY=1
			clear
		fi
	fi

	welcome
	exit 0
fi

if [ "${1:-}" == "--welcome" ]; then
	welcome

	if [ -z "${RANK:-}" ]; then
		print_rank
	fi

	exit 0
fi

if [ "${1:-}" == "--return" ]; then
	if [ -z "${SAVED_RANK:-}" ] || [ -z "${SAVED_EXERCISE:-}" ]; then
		echo "There is no saved progress to return to."
		exit 3
	else
		RANK=$SAVED_RANK
		EXERCISE=$SAVED_EXERCISE
		SAVED_RANK=""
		SAVED_EXERCISE=""
		updateDotFile
	fi
fi

if [[ ! "${RANK}" =~ ^(white|yellow|green|blue|red|black)_(stripe|belt)$ ]]; then
	fmt -u --width=$WIDTH <<EOL
It looks like the ~/.learnUnix file has become corrupted.  If it can't be repaired, you may have no choice but to delete it
and start over.  Sorry about that.
EOL
	exit 2
fi

if [[ ! "${EXERCISE}" =~ ^[0-9]+$ ]]; then
	fmt -u --width=$WIDTH <<EOL
It looks like the ~/.learnUnix file has become corrupted.  If it can't be repaired, you may have no choice but to delete it
and start over.  Sorry about that.
EOL
	exit 2
fi

all_args="$*"
all_args=${all_args,,}
if [[ "${all_args}" =~ (white|yellow|green|blue|red|black).*(stripe|belt)[^0-9]*([0-9]*) ]]; then
	# The ~/.learnUnix file must exist.  If it didn't, we would be running welcome().

	new_rank="${BASH_REMATCH[1]}_${BASH_REMATCH[2]}"

	# No underscore.
	new_rank_for_echo="${BASH_REMATCH[1]} ${BASH_REMATCH[2]}"

	new_exercise="${BASH_REMATCH[3]}"

	if [ "${new_exercise}" == "" ]; then
		new_exercise=1
	fi

	if [ "${new_exercise}" == "0" ]; then
		echo "The first exercise of each rank is exercise 1."
		exit 3
	fi

	if [[ "${new_exercise}" =~ 0[0-9]+ ]]; then
		echo "Please don't add leading zeros to the exercise number."
		exit 3
	fi

	new_belt_number=${belt_to_number[$new_rank]}

	if [ -n "${SAVED_RANK:-}" ]; then
		current_belt_number=${belt_to_number[$SAVED_RANK]}
	else
		current_belt_number=${belt_to_number[$RANK]}
	fi

	if [ -n "${SAVED_EXERCISE:-}" ]; then
		current_exercise=${SAVED_EXERCISE}
	else
		current_exercise=$EXERCISE
	fi

	if (($new_belt_number > $current_belt_number)); then
		fmt -u --width=$WIDTH <<EOL
This feature is for reviewing previous exercises, not for skipping ahead.
EOL
		exit 3
	fi

	if (($new_belt_number == $current_belt_number)); then
		if ((${new_exercise} > $current_exercise)); then
			fmt -u --width=$WIDTH <<EOL
This feature is for reviewing previous exercises, not for skipping ahead.
EOL
			exit 3
		elif ((${new_exercise} == $current_exercise)); then
			fmt -u --width=$WIDTH <<EOL
You're already working on that exercise.
EOL
			exit 3
		fi
	fi

	set_num_exercises_for_review

	if [ "$NUM_REVIEW_EXERCISES" == "0" ]; then
		echo "There aren't any exercises for ${new_rank_for_echo} yet."
		exit 3
	fi

	if (( $new_exercise > $NUM_REVIEW_EXERCISES )); then
		echo "There are only $NUM_REVIEW_EXERCISES exercises in ${new_rank_for_echo}."
		exit 3
	fi

	# Only set saved rank and saved exercise if they're currently unset, otherwise students could use this feature to
	# skip ahead.
	if [ -z "${SAVED_RANK:-}" ]; then
		SAVED_RANK=$RANK
	fi

	if [ -z "${SAVED_EXERCISE:-}" ]; then
		SAVED_EXERCISE=$EXERCISE
	fi

	RANK=$new_rank
	EXERCISE=$new_exercise

	updateDotFile

	# Fall out of the if and continue with the requested lesson.
elif [ -n "${1:-}" ] && [ "${1:-}" != "--return" ]; then
	# There was an argument passed but we couldn't figure out what the user wanted.
	echo "Usage:"
	echo ""
	echo "learn --welcome"
	echo "  To see which skills fall under which belts"
	echo "learn white belt"
	echo "  To review the white belt exercises"
	echo "learn yellow stripe"
	echo "  To review the yellow stripe exercises"
	echo "learn white belt 6"
	echo "  To start reviewing at a particular exercise"
	echo "learn --return"
	echo "  If you're reviewing exercises, return to where you were."

	exit 1
fi

if [ -z "${fmt_file:-}" ]; then
	fmt_file=$(mktemp --suffix=_$(whoami))
	file_clean_up_array+=($fmt_file)
fi

# White belt exercise 4 does something different.
print_rank > $fmt_file

if [ -z ${exercises["${RANK}_${EXERCISE}"]:-} ]; then
	fmt -u --width=$WIDTH <<EOL >> $fmt_file
There are no more exercises at this time.  If you like, you can review exercises you've already completed by executing
"learn white belt", "learn yellow stripe", or "learn white belt 6" to start review at a particular exercise.
EOL
	complete_exercise

	exit 1
fi

set_num_exercises

echo "Exercise ${EXERCISE}/${NUM_EXERCISES}" >> $fmt_file
echo "" >> $fmt_file

exercise_name=${exercises["${RANK}_${EXERCISE}"]}
function_name="${RANK}_exercise_${exercise_name}"
eval $function_name

