#!/bin/bash -i

# This script was developed in a 130x30 terminal.

# The "learn-unix-scripts" project is free software: you can redistribute it and/or modify it under the terms of the GNU
# General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# The "learn-unix-scripts" project is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with this project; if not, write to the
# Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA, 02111-1307, USA.
#
# Copyright (C) 2021 Christopher Evans

# replace start b2074508-dd08-48be-bc6c-346c26349e4e (see below for what this line does)

# This script is the master script for the checkmain script.  If you have site-specific changes that you don't want to share,
# you can add a GUID in this script and use the "replace" script to merge this script with your site-specific changes
# (in checkmain-replace) and create a site-specific learn script.  You can insert or replace portions of this code.

# If we didn't replace this text when we created the "checkmain" script, it would seem as though people should be making
# the changes to the "checkmain" script and not this one.  See the replacement for 1acc396a-02a2-40b8-a427-f4685c20320e in
# checkmain-replace for more.

# Insert exercises or elements that are specific to your site with "# insert <GUID>".  If you put a space after the GUID,
# you can add comments.  Replace parts with "# replace start <GUID>" and "# replace end <GUID>".  To remove sections,
# replace the content with nothing.  Put the replacements in the learn-replace file.
#
# replace end b2074508-dd08-48be-bc6c-346c26349e4e

# In case this script needs to be moved back to being sourced, use a prefix on the environment variables to avoid messing
# up other programs (Learn Unix Check or luc_).

set -e -o nounset

# insert 17fa07e6-24b8-4e35-bc1a-094427fd8699

# insert 17fa07e6-24b8-4e35-bc1a-094427fd8699 xterm fix

if [ `whoami` == "root" ]; then
	echo "Run this script as yourself, not the root user."
	exit 1
fi

if [ -z "${1:-}" ]; then
	echo "This script is not meant to be run directly."
	echo "Please execute '. check' to invoke the wrapper script."
fi

luc_history=()
while read i; do
	luc_history+=("$i")
done

LUS_HOME=${LUS_HOME:-"$HOME/lus"}

# insert ffa9e74e-2b02-4d72-9c82-9f9db2915c62 associative arrays for exercises and belt levels

luc_good_work_array[0]="Good work!"
luc_good_work_array[1]="Excellent!"
luc_good_work_array[2]="Well done!"
luc_good_work_array[3]="Brilliant!"
luc_good_work_array[4]="Terrific!"

luc_continue_array[0]="Keep going!"
luc_continue_array[1]="Keep at it!"
luc_continue_array[2]="Keep it up!"

luc_sorry_array[0]="Better luck next time."
luc_sorry_array[1]="Unfortunately, no."
luc_sorry_array[2]="Sorry, that's not it."
luc_sorry_array[3]="That's not it.  Try again."

good_work() {
	size=${#luc_good_work_array[@]}
	index=$(($RANDOM % $size))
	echo ${luc_good_work_array[$index]}

	EXERCISE=`expr $EXERCISE + 1`
}

keep_going() {
	size=${#luc_continue_array[@]}
	index=$(($RANDOM % $size))
	echo ${luc_continue_array[$index]}

	EXERCISE=`expr $EXERCISE + 1`
}

sorry() {
	size=${#luc_sorry_array[@]}
	index=$(($RANDOM % $size))
	echo ${luc_sorry_array[$index]}
	echo "Run the learn script again if you need to."
}

process_choice() {
	luc_processed_choice=0

	if [[ -z "${luc_choice:-}" ]]; then
		return
	fi

	# That's right, Roman numerals!  Inspired by Starship Titanic.

	# Use the ${ ,,} syntax to lowercase.
	if [[ "${luc_choice,,}" =~ ^[\ ]*(one|1|i)[\ ]*$ ]]; then
		luc_processed_choice=1
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(two|2|ii)[\ ]*$ ]]; then
		luc_processed_choice=2
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(three|3|iii)[\ ]*$ ]]; then
		luc_processed_choice=3
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(four|4|iiii|iv)[\ ]*$ ]]; then
		luc_processed_choice=4
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(five|5|v)[\ ]*$ ]]; then
		luc_processed_choice=5
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(six|6|vi)[\ ]*$ ]]; then
		luc_processed_choice=6
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(seven|7|vii)[\ ]*$ ]]; then
		luc_processed_choice=7
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(eight|8|viii)[\ ]*$ ]]; then
		luc_processed_choice=8
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(nine|9|ix)[\ ]*$ ]]; then
		luc_processed_choice=9
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(ten|10|x)[\ ]*$ ]]; then
		luc_processed_choice=10
	fi
}

# insert 37333148-8746-4468-826e-544e532f1ebc updateDotFile, getBeltWithColours

handle_answer() {
	luc_shuffled_answers=()
	while read -r item; do
	    luc_shuffled_answers+=("$item")
	done < <(shuf -e "${luc_answers[@]}")

	luc_num=1
	for item in "${luc_shuffled_answers[@]}"
	do
		echo "(${luc_num}) $item"
		if [[ "$item" == "${1}" ]]; then
			luc_correct_answer=$luc_num
		fi
		luc_num=$((luc_num+1))
	done

	echo ""

	while true
	do
		# Stdin has been redirected to pull in the command history, so we need an extra step to read from the terminal.
		# There must be no space between < and /.
		read -p "Your answer (1-${#luc_answers[@]})?  " luc_choice </dev/tty

		process_choice

		echo ""

		if [[ "$luc_processed_choice" == "$luc_correct_answer" ]]; then
			luc_correct_answers=$((luc_correct_answers+1))
			break
		elif [[ "$luc_processed_choice" == "0" ]]; then
			echo "Your answer should be a number from 1 to 6."
		else
			break
		fi
	done
}

ask_review_final_exam() {
	if [ -n "${SAVED_RANK:-}" ] && [ -n "${SAVED_EXERCISE:-}" ]; then
		echo "Right now, you're reviewing exercises you've already completed."
		echo "The final exam for `getBeltWithColours ${RANK:-}` is next."
		echo
		echo "What would you like to do?"
		echo "(1) Attempt the exam again"
		echo "(2) Skip it"
		echo "(3) Quit"
		read -p "Please choose (1-3)?  " luc_choice </dev/tty
		process_choice

		if [[ "$luc_processed_choice" == "1" ]]; then
			return 1
		elif [[ "$luc_processed_choice" == "2" ]]; then
			return 0
		else
			exit 0
		fi
	else
		return 1
	fi
}

white_belt_exercise_what_execute_means() {
	# For this exercise, we're only confirming this script was run, so there's nothing to check.
	good_work
	echo ""
	fmt -u --width=$luc_width <<EOL
For each exercise, you'll run the learn and check scripts.  Execute "learn" for your next task or to pick up where you left off.
EOL
}

white_belt_exercise_stuck() {
	# For this exercise, we're only confirming this script was run, so there's nothing to check.
	good_work
	echo ""
	fmt -u --width=$luc_width <<EOL
Execute "learn" for your next task or to pick up where you left off.
EOL
}

white_belt_exercise_cd_root() {
	if [[ `pwd` == "/" ]]; then
		good_work
		echo ""
		echo $'Execute "learn" when you\'re ready for the next exercise.'
	else
		sorry
	fi
}

white_belt_exercise_ls_root() {
	# Chances are, "ls" is going to be in the history, so cheaters will get a pass on this one.
	# We could generate history with a smaller size for this exercise, but it doesn't seem worthwhile.
	# The list command is so basic that I'm not really concerned that something will be missed here.

	good_work
	echo ""
	echo $'Execute "learn" when you\'re ready for the next exercise.'
}

white_belt_exercise_common_root_directories() {
	if [[ `pwd` == "$HOME" ]]; then
		good_work
		echo ""
		echo $'Execute "learn" when you\'re ready for the next exercise.'
	else
		sorry
	fi
}

white_belt_exercise_set() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*set([ ]|$) ]]; then
			good_work
			echo ""
			echo $'Execute "learn" when you\'re ready for the next exercise.'
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

white_belt_exercise_frozen() {
	fmt -u --width=$luc_width <<EOL
Question 1/1

Your terminal is frozen!  What is the next thing you should try after typing Ctrl+c?

EOL

	luc_correct_answers=0
	luc_answers=( 'Give up and go back to Windows' 'Type Ctrl+q' 'Type Ctrl+s' 'Type Ctrl+u' 'Scream in panic' 'Open another terminal' )

	handle_answer "Type Ctrl+q"

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
		echo ""
		echo $'Execute "learn" when you\'re ready for the next exercise.'
	else
		sorry
		echo ""
		echo $'Execute "learn white belt list" to see the list of exercises.'
		echo $'Execute "learn white belt 2" to review a specific white belt exercise.'
	fi
}

white_belt_exercise_set_more() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*set[\ ]*\|[\ ]*more[\ ]*$ ]]; then
			good_work
			echo ""
			echo $'Execute "learn" when you\'re ready for the next exercise.'
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

white_belt_exercise_set_less() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*set[\ ]*\|[\ ]*less[\ ]*$ ]]; then
			good_work
			echo ""
			echo $'Execute "learn" when you\'re ready for the next exercise.'
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

white_belt_exercise_path_and_sourcing() {
	if ask_review_final_exam; then
		keep_going
		return 0
	fi

	luc_correct_answers=0

	fmt -u --width=$luc_width <<EOL
If you press Ctrl+c, you will get back to a prompt, but your progress through the questions will not be saved.

Question 1/5

What does the "." in ". check" do?
EOL

	luc_answers=( 'It executes the "check" script as if it was typed in, which changes how environment variables work.' 'It changes the script output to the current directory.' 'It causes the script to be run with authority.' )
	handle_answer 'It executes the "check" script as if it was typed in, which changes how environment variables work.'

	echo
	fmt -u --width=$luc_width <<EOL
Question 2/5

What does slash (/) refer to in terms of a path?

EOL

	luc_answers=( "It's the root directory, in which (or under which) all other directories exist." "It means or:  allowing one path or another to be chosen based on which one exists." "Slash and burn.  Delete everything from here down." "It's the user's home directory." )
	handle_answer "It's the root directory, in which (or under which) all other directories exist."

	echo
	fmt -u --width=$luc_width <<EOL
Question 3/5

What would you find in a user's home directory?

EOL

	luc_answers=( 'Configuration files and other private files' 'System files' 'Global configuration files' 'A well appointed kitchen, including several sinks' )
	handle_answer 'Configuration files and other private files'

	echo
	fmt -u --width=$luc_width <<EOL
Question 4/5

What's the shortest command that will return you to your home directory?

EOL

	luc_answers=( 'cd' 'cd ~' '/' '${HOME}' )
	handle_answer 'cd'

	echo
	fmt -u --width=$luc_width <<EOL
Question 5/5

What are the two situations that you are most likely to run into where Ctrl+c doesn't return you to a prompt?

EOL

	luc_answers=( 'Using less (including man) and accidentally typing Ctrl+s' 'Accidentally typing Ctrl+s and \' 'Using less (including man) and accidentally typing ?' 'The power goes out and gunpowder stops working' )
	handle_answer 'Using less (including man) and accidentally typing Ctrl+s'

	if [ "$luc_correct_answers" == "5" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers/5 correct"
		echo ""
		sorry
	fi
}

yellow_stripe_exercise_pwd() {
	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*pwd([ ]|$) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
}

yellow_stripe_exercise_cd_dot_dot() {
	luc_req_1=0
	luc_req_2=0

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*pwd([ ]|$) ]]; then
			luc_req_1=1
		fi

		if [[ "$item" =~ ^[\ ]*cd( )*\.\.( )*$ ]]; then
			luc_req_2=1
		fi
	done
	unset IFS

	if [ $luc_req_1 == "1" ] && [ $luc_req_2 == "1" ] && [[ `pwd` == "/" ]]; then
		good_work
	else
		sorry
	fi
}

yellow_stripe_exercise_no_news_is_good_news() {
	fmt -u --width=$luc_width <<EOL
Question 1/1

Your coworker is confused that they input a command to create a directory and only got a prompt back.

EOL

	fmt -u -s --width=$luc_width <<EOL
user@example:~/lus$ mkdir one
user@example:~/lus$ 
EOL

	fmt -u --width=$luc_width <<EOL

What happened here?
EOL

	luc_correct_answers=0
	luc_answers=( 'The directory was created.' 'Nothing happened.' 'Something went wrong.' 'A stray cosmic ray flipped a bit in memory.  Reboot!' )

	handle_answer 'The directory was created.'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

yellow_stripe_exercise_mkdir_and_relative_paths() {
	if [ ! -d $LUS_HOME/parent ]; then
		sorry
		return
	fi

	if [ ! -d $LUS_HOME/parent/one ] || [ ! -d $LUS_HOME/parent/two ] || [ ! -d $LUS_HOME/parent/three ]; then
		sorry
		return
	fi

	good_work
}

yellow_stripe_exercise_rmdir() {
	if [ ! -d $LUS_HOME/parent ]; then
		good_work
	else
		sorry
	fi
}

yellow_stripe_exercise_special_characters() {
	if [ -f $LUS_HOME/yellow ]; then
		good_work
	else
		sorry
	fi
}

yellow_stripe_exercise_file() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*file( )*yellow[\ ]*$ ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

yellow_stripe_exercise_cat_less() {
	luc_req_1=0
	luc_req_2=0

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*cat( )*yellow([ ]|$) ]]; then
			luc_req_1=1
		fi

		if [[ "$item" =~ ^[\ ]*less( )*yellow([ ]|$) ]]; then
			luc_req_2=1
		fi
	done
	unset IFS

	if [ $luc_req_1 == "1" ] && [ $luc_req_2 == "1" ]; then
		good_work
	else
		sorry
	fi
}

yellow_stripe_exercise_quotes() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*echo.*HOME ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
}

yellow_stripe_exercise_escaping_quotes() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*echo.*HOME ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
}

yellow_stripe_exercise_quote_finale() {
	if ask_review_final_exam; then
		keep_going
		return 0
	fi

	luc_correct_answers=0

	fmt -u --width=$luc_width <<EOL
If you press Ctrl+c, you will get back to a prompt, but your progress through the questions will not be saved.

Question 1/3

A misbehaving process has created a file called "!@#$".  What is the shortest command line that will successfully rename it?

EOL

	luc_answers=( 'mv !@#$ newname' 'mv !@#'"'"'$'"'"' newname' 'mv '"'"'!@#$'"'"' newname' 'mv "!@#$" newname' 'Open Windows Explorer, click the file, and press F2.' )
	handle_answer 'mv '"'"'!@#$'"'"' newname'

	fmt -u --width=$luc_width <<EOL
Question 2/3

A cat walked across your keyboard while you had a Unix terminal open.  Due to bad luck, you had typed part of a command
line and a single quote before the cat struck.  Due to worse luck, it pressed the single quote key and then Enter.
You now have a file called "kASjiczkskflopd;[f".  Which command will successfully rename it?

EOL

	luc_answers=( 'mv '"'"'kASjiczkskflopd;[f'"'"' newname' 'mv "kASjiczkskflopd;[f" newname' 'mv kASjiczkskflopd\;\[f newname' 'All the mv command lines will work' 'Impossible!  Cats are banned from my workstation.' )
	handle_answer 'All the mv command lines will work'

	fmt -u --width=$luc_width <<EOL
Question 3/3

You need to deal with a file that has multiple spaces and one single quote.  What's the shortest way to quote it that
will work?

EOL

	luc_answers=( '"Monday'"'"'s TPS Report for John"      (30 characters)' '"Monday\'"'"'s TPS Report for John"     (31 characters)' 'Monday\'"'"'s\ TPS\ Report\ for\ John   (33 characters)' 'Funny answer TBD                    (16 characters)' )
	handle_answer '"Monday'"'"'s TPS Report for John"      (30 characters)'

	if [ "$luc_correct_answers" == "3" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers/3 correct"
		echo ""
		sorry
	fi
}

yellow_belt_exercise_speed_and_lists() {
	if [[ `pwd` == "$LUS_HOME/complete" ]]; then
		good_work
		echo ""
		echo $'Execute "learn" when you\'re ready for the next exercise.'
	else
		sorry
	fi
}

yellow_belt_exercise_unquoted_tab_completion() {
	fmt -u --width=$luc_width <<EOL
Question 1/1

What kind of file is Monday's TPS Report for John?

EOL

	luc_correct_answers=0
	luc_answers=( 'empty' 'Microsoft Word' 'text file' 'Martian cartographic data' )

	handle_answer 'empty'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

yellow_belt_exercise_unquoted_tab_completion_two_options() {
	fmt -u --width=$luc_width <<EOL
Question 1/1

What kind of file is Monday's TPS Report for Fred?

EOL

	luc_correct_answers=0
	luc_answers=( 'empty' 'Microsoft Excel' 'ASCII text' 'Open Office Presentation' )

	handle_answer 'ASCII text'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

yellow_belt_exercise_quoted_tab_completion() {
	fmt -u --width=$luc_width <<EOL
Question 1/1

What's inside Monday's TPS Report for Fred?

EOL

	luc_correct_answers=0
	luc_answers=( 'TBA' 'TBD' 'TBW' 'Top-secret Space Station Plans' )

	handle_answer 'TBW'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

yellow_belt_exercise_tab_is_context_sensitive() {
	keep_going
}

yellow_belt_exercise_up() {
	keep_going
}

yellow_belt_exercise_home_end_and_pound() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*# ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
}

yellow_belt_exercise_ctrl_r() {
	keep_going
}

yellow_belt_exercise_history_bang() {
	if ask_review_final_exam; then
		keep_going
		return 0
	fi

	luc_correct_answers=0

	fmt -u --width=$luc_width <<EOL
If you press Ctrl+c, you will get back to a prompt, but your progress through the questions will not be saved.

Question 1/3

If you found a command in your history with Ctrl+r but you need to make a change to it first, what should you do?

EOL

	luc_answers=( 'Type Ctrl+c' 'Type Ctrl+g' 'Start typing the desired changes' 'Press Left, Right, Ctrl+b, or Ctrl+f' 'Ask the audience' )
	handle_answer 'Press Left, Right, Ctrl+b, or Ctrl+f'

	fmt -u --width=$luc_width <<EOL
Question 2/3

With some terminals, what keystrokes do you need to go to the beginning and end of the current command line?

EOL

	luc_answers=( 'Ctrl+a and Ctrl+e' 'Ctrl+f and Ctrl+b' 'Ctrl+1 and Ctrl+9' 'The Home and End keys work everywhere!' )
	handle_answer 'Ctrl+a and Ctrl+e'

	fmt -u --width=$luc_width <<EOL
Question 3/3

If you want to keep what you've typed so far but not run it, what should you do?

EOL

	luc_answers=( 'Type Ctrl+a, #, Enter' "Just press Enter, there are errors so it won't run" 'Type Ctrl+h' 'Type Ctrl+s' )
	handle_answer 'Type Ctrl+a, #, Enter'

	if [ "$luc_correct_answers" == "3" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers/3 correct"
		echo ""
		sorry
	fi
}

green_stripe_exercise_command_line_options() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*man( )*ls([ ]|$) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

green_stripe_exercise_ls() {
	fmt -u --width=$luc_width <<EOL
Question 1/1

Did you notice anything odd about the file listings?

EOL

	luc_correct_answers=0
	luc_answers=( 'The files "one", "two", and "three" were in alphabetical order, which was odd.' 'There was no file called "two".' 'The files "first", "second", and "third" were out of order.' 'Oh, a squirrel.' )

	handle_answer 'The files "one", "two", and "three" were in alphabetical order, which was odd.'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

green_stripe_exercise_ls_dash_l() {
	fmt -u --width=$luc_width <<EOL
Question 1/1

What did you find?

EOL

	luc_correct_answers=0
	luc_answers=( 'The files "one", "two", and "three" have different dates.' 'There is no file called "second".' 'The files "first", "second", and "third" have different dates.' 'Hey!  Look at the obvious distraction!' )

	handle_answer 'The files "one", "two", and "three" have different dates.'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

green_stripe_exercise_ls_explore() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*ls( )*-([A-Za-z]*t[A-Za-z]*r[A-Za-z]*|[A-Za-z]*r[A-Za-z]*t[A-Za-z]*) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

green_stripe_exercise_ls_dash_h() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*ls( )*-([A-Za-z]*h) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

green_stripe_exercise_ls_dash_f() {
	keep_going
}

green_stripe_exercise_df() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*df( )*-([A-Za-z]*h) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

green_stripe_final_exam() {
	if ask_review_final_exam; then
		keep_going
		return 0
	fi

	luc_correct_answers=0

	fmt -u --width=$luc_width <<EOL
If you press Ctrl+c, you will get back to a prompt, but your progress through the questions will not be saved.

Question 1/3

If you found a command in your history with Ctrl+r but you need to make a change to it first, what should you do?

EOL

	luc_answers=( 'Type Ctrl+c' 'Type Ctrl+g' 'Start typing the desired changes' 'Press Left, Right, Ctrl+b, or Ctrl+f' 'Ask the audience' )
	handle_answer 'Press Left, Right, Ctrl+b, or Ctrl+f'

	fmt -u --width=$luc_width <<EOL
Question 2/3

You want to see a long-format file list with the most recent files at the bottom.  Which options will do that?

EOL

	luc_answers=( 'ls -lh' 'ls -ltr' 'ls -Al' 'ls -lt' 'ls -ohno' )
	handle_answer 'ls -ltr'

	fmt -u --width=$luc_width <<EOL
Question 3/3

You want to see a long-format file list with the oldest files at the bottom.  Which options will do that?

EOL

	luc_answers=( 'ls -lh' 'ls -lt' 'ls -Al' 'ls -ltr' 'Ctrl+c! Ctrl+c!!' )
	handle_answer 'ls -lt'

	if [ "$luc_correct_answers" == "3" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers/3 correct"
		echo ""
		sorry
	fi
}

####################
# End of exercises #
####################

belt_complete() {
	rank_exercises_completed=$RANK
	rank_attained=$(getNextBelt $RANK)
	rank_working_towards=$(getNextBelt $rank_attained)

	RANK=$rank_attained
	EXERCISE=1

	echo ""

	if [ -z "${SAVED_RANK:-}" ]; then
		printf "Congratulations!  You have now attained your `getBeltWithColours $RANK`.\n"
		printf "You're working toward your `getBeltWithColours $rank_working_towards`.\n\n"
	else
		printf "You have reviewed all the exercises in `getBeltWithColours $rank_exercises_completed`.\n"
		printf "Execute \"learn\" to start reviewing the `getBeltWithColours $rank_attained` exercises.\n\n"
	fi
}

###############################
# End of function definitions #
###############################

# Script execution will begin here.

# If this script is switched back to being sourced, we'll need to change the "exit"s below to returns.

if [ ! -f "${LUS_PROGRESS}" ]; then
	echo 'Please run the "learn" script first.'
	exit 1
fi

source "${LUS_PROGRESS}"

LUS_HOME=${LUS_HOME:-"$HOME/lus"}

if [ -z "${RANK:-}" ] || [ -z "${EXERCISE:-}" ]; then
	fmt -u --width=$luc_width <<EOL
Please run the "learn" script first.
EOL
	exit 1
fi

# luc = Learn Unix Check
luc_width=`expr $2 - 5`

if [[ ! "${RANK}" =~ ^(white|yellow|green|blue|red|black)_(stripe|belt)$ ]]; then
	fmt -u --width=$luc_width <<EOL
It looks like the ${LUS_PROGRESS} file has become corrupted.  If it can't be repaired, you may have no choice but to delete it
and start over.  Sorry about that.
EOL
	exit 2
fi

if [[ ! "${EXERCISE}" =~ ^[0-9]+$ ]]; then
	fmt -u --width=$luc_width <<EOL
It looks like the ${LUS_PROGRESS} file has become corrupted.  If it can't be repaired, you may have no choice but to delete it
and start over.  Sorry about that.
EOL
	exit 2
fi

luc_regex="'"
luc_regex+="${RANK}_exercise_.*\(\)"
luc_regex+="'"
luc_num_exercises=$(bash -c "grep -E ${luc_regex} ~/bin/learn | wc -l")

exercise_name=${exercises["${RANK}_${EXERCISE}"]:-}

if [ -z "$exercise_name" ]; then
	fmt -u --width=$luc_width <<EOL
There are no more exercises at this time.  If you like, you can review exercises you've already completed by executing
"learn white belt", "learn yellow stripe", or "learn white belt 6" to start review at a particular exercise.
EOL

	exit 1
fi

function_name="${RANK}_exercise_${exercise_name}"
eval $function_name

if [ "${EXERCISE:-}" == "${SAVED_EXERCISE:-}" ] && [ "${SAVED_RANK:-}" == "${RANK:-}" ]; then
	SAVED_RANK=""
	SAVED_EXERCISE=""
	updateDotFile

	fmt -u --width=$luc_width <<EOL
You were reviewing past exercises and you've caught up to where you were.  Execute "learn" to continue.
EOL
fi

if (($EXERCISE > $luc_num_exercises)); then
	new_belt_number=`expr 1 + ${belt_to_number[$RANK]}`
	new_belt=${number_to_belt[$new_belt_number]}

	if [[ "$new_belt" == "${SAVED_RANK:-}" && "${SAVED_EXERCISE:-}" == "1" ]]; then
		printf "\nYou have reviewed all the exercises in `getBeltWithColours $RANK`.\n"
		printf "You're all caught up.\n"
		printf "Execute \"learn\" to begin the `getBeltWithColours $new_belt` exercises.\n"

		RANK=$SAVED_RANK
		EXERCISE=1
		SAVED_RANK=""
		SAVED_EXERCISE=""

		updateDotFile

		exit 0
	fi

	if [ $RANK == "white_belt" ]; then
		echo ""

		if [ -z "${SAVED_RANK:-}" ]; then
			printf "Congratulations!  You have now attained your `getBeltWithColours yellow_stripe`.\n"
			printf "You are now working toward your `getBeltWithColours yellow_belt`.\n\n"

			fmt -u --width=$luc_width <<EOL
If you don't consider yourself to be detail oriented, the last few yellow stripe exercises may be challenging.  If you need
caffeine, a good night's sleep, or a hearty breakfast to be on top of your game, consider doing that.  If you're a morning
person (or a night owl) and you can do the exercises in the morning (or at night), consider doing that.

From here on out, only the first exercise of each belt will prompt you to execute "learn" and ". check", unless it's needed
for clarity.
EOL

			RANK=yellow_stripe
			EXERCISE=1
		else
			printf "You have reviewed all the exercises in `getBeltWithColours white_belt`.\n"
			printf "Execute \"learn\" to start reviewing the `getBeltWithColours yellow_stripe` exercises.\n"

			RANK=yellow_stripe
			EXERCISE=1
		fi
	elif [ $RANK == "yellow_stripe" ]; then
		belt_complete
	elif [ $RANK == "yellow_belt" ]; then
		belt_complete
	else
		rank_exercises_completed=$RANK
		rank_attained=$(getNextBelt $RANK)
		rank_working_towards=$(getNextBelt $rank_attained)

		RANK=$rank_attained
		EXERCISE=1

		if [ -z "${SAVED_RANK:-}" ]; then
			printf "Congratulations!  You have now attained your `getBeltWithColours $rank_attained`.\n"
			printf "You would be working toward your `getBeltWithColours $rank_working_towards`, but there are no more exercises.\n\n"
		else
			printf "You have reviewed all the exercises in `getBeltWithColours $rank_exercises_completed`.\n"
			printf "There are no more exercises at this time.\n\n"

			SAVED_RANK=""
			SAVED_EXERCISE=""
		fi
	fi
fi

updateDotFile

