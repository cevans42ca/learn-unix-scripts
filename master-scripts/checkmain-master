#!/bin/bash -i

# This script was developed in a 130x30 terminal.

# The "learn-unix-scripts" project is free software: you can redistribute it and/or modify it under the terms of the GNU
# General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# The "learn-unix-scripts" project is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with this project; if not, write to the
# Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA, 02111-1307, USA.
#
# Copyright (C) 2021 Christopher Evans

# replace start b2074508-dd08-48be-bc6c-346c26349e4e (see below for what this line does)

# This script is the master script for the checkmain script.  If you have site-specific changes that you don't want to share,
# you can add a GUID in this script and use the "replace" script to merge this script with your site-specific changes
# (in checkmain-replace) and create a site-specific learn script.  You can insert or replace portions of this code.

# If we didn't replace this text when we created the "checkmain" script, it would seem as though people should be making
# the changes to the "checkmain" script and not this one.  See the replacement for 1acc396a-02a2-40b8-a427-f4685c20320e in
# checkmain-replace for more.

# Insert exercises or elements that are specific to your site with "# insert <GUID>".  If you put a space after the GUID,
# you can add comments.  Replace parts with "# replace start <GUID>" and "# replace end <GUID>".  To remove sections,
# replace the content with nothing.  Put the replacements in the learn-replace file.
#
# replace end b2074508-dd08-48be-bc6c-346c26349e4e

# In case this script needs to be moved back to being sourced, use a prefix on the environment variables to avoid messing
# up other programs (Learn Unix Check or luc_).

set -e -o nounset

# insert 17fa07e6-24b8-4e35-bc1a-094427fd8699

if [ `whoami` == "root" ]; then
	echo "Run this script as yourself, not the root user."
	exit 1
fi

if [ -z "${1:-}" ]; then
	echo "This script is not meant to be run directly."
	echo "Please execute '. check' to invoke the wrapper script."
fi

luc_history=()
while read i; do
	luc_history+=("$i")
done

# insert ffa9e74e-2b02-4d72-9c82-9f9db2915c62 associative arrays for exercises and belt levels

luc_tty=$1

luc_stty_rows=$(bash -c "stty -a -F$1 | grep -Po '(?<=rows )[0-9]*(?=;)'")
luc_stty_columns=$(bash -c "stty -a -F$1 | grep -Po '(?<=columns )[0-9]*(?=;)'")
luc_width=`expr $luc_stty_columns - 5`

luc_good_work_array[0]="Good work!"
luc_good_work_array[1]="Excellent!"
luc_good_work_array[2]="Well done!"
luc_good_work_array[3]="Brilliant!"
luc_good_work_array[4]="Terrific!"

luc_continue_array[0]="Keep going!"
luc_continue_array[1]="Keep at it!"
luc_continue_array[2]="Keep it up!"

luc_sorry_array[0]="Better luck next time."
luc_sorry_array[1]="Unfortunately, no."
luc_sorry_array[2]="Sorry, that's not it."
luc_sorry_array[3]="That's not it.  Try again."

good_work() {
	size=${#luc_good_work_array[@]}
	index=$(($RANDOM % $size))
	echo ${luc_good_work_array[$index]}

	EXERCISE=`expr $EXERCISE + 1`
}

keep_going() {
	size=${#luc_continue_array[@]}
	index=$(($RANDOM % $size))
	echo ${luc_continue_array[$index]}

	EXERCISE=`expr $EXERCISE + 1`
}

sorry() {
	size=${#luc_sorry_array[@]}
	index=$(($RANDOM % $size))
	echo ${luc_sorry_array[$index]}
	echo "Run the learn script again if you need to."
}

process_choice() {
	luc_processed_choice=0

	if [[ -z "${luc_choice:-}" ]]; then
		return
	fi

	# That's right, Roman numerals!  Inspired by Starship Titanic.

	# Use the ${ ,,} syntax to lowercase.
	if [[ "${luc_choice,,}" =~ ^[\ ]*(one|1|i)[\ ]*$ ]]; then
		luc_processed_choice=1
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(two|2|ii)[\ ]*$ ]]; then
		luc_processed_choice=2
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(three|3|iii)[\ ]*$ ]]; then
		luc_processed_choice=3
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(four|4|iiii|iv)[\ ]*$ ]]; then
		luc_processed_choice=4
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(five|5|v)[\ ]*$ ]]; then
		luc_processed_choice=5
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(six|6|vi)[\ ]*$ ]]; then
		luc_processed_choice=6
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(seven|7|vii)[\ ]*$ ]]; then
		luc_processed_choice=7
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(eight|8|viii)[\ ]*$ ]]; then
		luc_processed_choice=8
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(nine|9|ix)[\ ]*$ ]]; then
		luc_processed_choice=9
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(ten|10|x)[\ ]*$ ]]; then
		luc_processed_choice=10
	fi
}

# insert 37333148-8746-4468-826e-544e532f1ebc updateDotFile, getBeltWithColours

handle_answer() {
	luc_shuffled_answers=()
	while read -r item; do
	    luc_shuffled_answers+=("$item")
	done < <(shuf -e "${luc_answers[@]}")

	luc_num=1
	for item in "${luc_shuffled_answers[@]}"
	do
		echo "(${luc_num}) $item"
		if [[ "$item" == "${1}" ]]; then
			luc_correct_answer=$luc_num
		fi
		luc_num=$((luc_num+1))
	done

	echo ""

	while true
	do
		# Stdin has been redirected to pull in the command history, so we need an extra step to read from the terminal.
		# There must be no space between < and /.
		read -p "Your answer (1-${#luc_answers[@]})?  " luc_choice </dev/tty

		process_choice

		echo ""

		if [[ "$luc_processed_choice" == "$luc_correct_answer" ]]; then
			luc_correct_answers=$((luc_correct_answers+1))
			break
		elif [[ "$luc_processed_choice" == "0" ]]; then
			echo "Your answer should be a number from 1 to 6."
		else
			break
		fi
	done
}

white_belt_exercise_what_execute_means() {
	# For this exercise, we're only confirming this script was run, so there's nothing to check.
	good_work
	echo ""
	fmt -u --width=$luc_width <<EOL
For each exercise, you'll run the learn and check scripts.  Execute "learn" for your next task or to pick up where you left off.
EOL
}

white_belt_exercise_stuck() {
	# For this exercise, we're only confirming this script was run, so there's nothing to check.
	good_work
	echo ""
	fmt -u --width=$luc_width <<EOL
Execute "learn" for your next task or to pick up where you left off.
EOL
}

white_belt_exercise_cd_root() {
	if [[ `pwd` == "/" ]]; then
		good_work
		echo ""
		echo $'Execute "learn" when you\'re ready for the next exercise.'
	else
		sorry
	fi
}

white_belt_exercise_ls_root() {
	# Chances are, "ls" is going to be in the history, so cheaters will get a pass on this one.
	# We could generate history with a smaller size for this exercise, but it doesn't seem worthwhile.
	# The list command is so basic that I'm not really concerned that something will be missed here.

	good_work
	echo ""
	echo $'Execute "learn" when you\'re ready for the next exercise.'
}

white_belt_exercise_common_root_directories() {
	if [[ `pwd` == "$HOME" ]]; then
		good_work
		echo ""
		echo $'Execute "learn" when you\'re ready for the next exercise.'
	else
		sorry
	fi
}

white_belt_exercise_set() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*set([ ]|$) ]]; then
			good_work
			echo ""
			echo $'Execute "learn" when you\'re ready for the next exercise.'
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

white_belt_exercise_frozen() {
	fmt -u --width=$luc_width <<EOL
Question 1/1

Your terminal is frozen!  What is the next thing you should try after typing Ctrl+c?

EOL

	luc_correct_answers=0
	luc_answers=( 'Give up and go back to Windows' 'Type Ctrl+q' 'Type Ctrl+s' 'Type Ctrl+u' 'Scream in panic' 'Open another terminal' )

	handle_answer "Type Ctrl+q"

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
		echo ""
		echo $'Execute "learn" when you\'re ready for the next exercise.'
	else
		sorry
		echo ""
		echo $'Execute "learn white belt 2" to review a specific white belt exercise.'
	fi
}

white_belt_exercise_set_more() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*set[\ ]*\|[\ ]*more[\ ]*$ ]]; then
			good_work
			echo ""
			echo $'Execute "learn" when you\'re ready for the next exercise.'
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

white_belt_exercise_set_less() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*set[\ ]*\|[\ ]*less[\ ]*$ ]]; then
			good_work
			echo ""
			echo $'Execute "learn" when you\'re ready for the next exercise.'
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

white_belt_exercise_path_and_sourcing() {
	# For this exercise, we're only confirming this script was run, so there's nothing to check.
	good_work
}

yellow_stripe_exercise_pwd() {
	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*pwd([ ]|$) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
}

yellow_stripe_exercise_cd_dot_dot() {
	luc_req_1=0
	luc_req_2=0

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*pwd([ ]|$) ]]; then
			luc_req_1=1
		fi

		if [[ "$item" =~ ^[\ ]*cd( )*\.\.( )*$ ]]; then
			luc_req_2=1
		fi
	done
	unset IFS

	if [ $luc_req_1 == "1" ] && [ $luc_req_2 == "1" ] && [[ `pwd` == "/" ]]; then
		good_work
	else
		sorry
	fi
}

yellow_stripe_exercise_no_news_is_good_news() {
	fmt -u --width=$luc_width <<EOL
Question 1/1

Your coworker is confused that they input a command to create a directory and only got a prompt back.

EOL

	fmt -u -s --width=$luc_width <<EOL
user@example:~/lus$ mkdir one
user@example:~/lus$ 
EOL

	fmt -u --width=$luc_width <<EOL

What happened here?
EOL

	luc_correct_answers=0
	luc_answers=( 'The directory was created.' 'Nothing happened.' 'Something went wrong.' 'A stray cosmic ray flipped a bit in memory.  Reboot!' )

	handle_answer 'The directory was created.'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

yellow_stripe_exercise_mkdir_and_relative_paths() {
	if [ ! -d $LUS_HOME/parent ]; then
		sorry
	fi

	if [ ! -d $LUS_HOME/parent/one ] || [ ! -d $LUS_HOME/parent/two ] || [ ! -d $LUS_HOME/parent/three ]; then
		sorry
	fi

	good_work
}

yellow_stripe_exercise_rmdir() {
	if [ ! -d $LUS_HOME/parent ]; then
		good_work
	else
		sorry
	fi
}

yellow_stripe_exercise_special_characters() {
	if [ -f $LUS_HOME/yellow ]; then
		good_work
	else
		sorry
	fi
}

yellow_stripe_exercise_file() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*file( )*yellow[\ ]*$ ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

yellow_stripe_exercise_cat_less() {
	luc_req_1=0
	luc_req_2=0

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*cat( )*yellow([ ]|$) ]]; then
			luc_req_1=1
		fi

		if [[ "$item" =~ ^[\ ]*less( )*yellow([ ]|$) ]]; then
			luc_req_2=1
		fi
	done
	unset IFS

	if [ $luc_req_1 == "1" ] && [ $luc_req_2 == "1" ]; then
		good_work
	else
		sorry
	fi
}

yellow_stripe_exercise_quotes() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*echo.*HOME ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
}

yellow_stripe_exercise_escaping_quotes() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*echo.*HOME ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
}

yellow_stripe_exercise_quote_finale() {
	luc_correct_answers=0

	fmt -u --width=$luc_width <<EOL
Question 1/3

A misbehaving process has created a file called "!@#$".  What is the shortest command line that will successfully rename it?

EOL

	luc_answers=( 'mv !@#$ newname' 'mv !@#'"'"'$'"'"' newname' 'mv '"'"'!@#$'"'"' newname' 'mv "!@#$" newname' 'Open Windows Explorer, click the file, and press F2.' )
	handle_answer 'mv '"'"'!@#$'"'"' newname'

	fmt -u --width=$luc_width <<EOL
Question 2/3

A cat walked across your keyboard while you had a Unix terminal open.  Due to bad luck, you had typed part of a command
line and a single quote before the cat struck.  Due to worse luck, it pressed the single quote key and then Enter.
You now have a file called "kASjiczkskflopd;[f".  Which command will successfully rename it?

EOL

	luc_answers=( 'mv '"'"'kASjiczkskflopd;[f'"'"' newname' 'mv "kASjiczkskflopd;[f" newname' 'mv kASjiczkskflopd\;\[f newname' 'All the mv command lines will work' 'Impossible!  Cats are banned from my workstation.' )
	handle_answer 'All the mv command lines will work'

	fmt -u --width=$luc_width <<EOL
Question 3/3

You need to deal with a file that has multiple spaces and one single quote.  What's the shortest way to quote it that
will work?

EOL

	luc_answers=( '"Monday'"'"'s TPS Report for John"      (30 characters)' '"Monday\'"'"'s TPS Report for John"     (31 characters)' 'Monday\'"'"'s\ TPS\ Report\ for\ John   (33 characters)' 'Funny answer TBD                    (16 characters)' )
	handle_answer '"Monday'"'"'s TPS Report for John"      (30 characters)'

	if [ "$luc_correct_answers" == "3" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers/3 correct"
		echo ""
		sorry
	fi
}

yellow_belt_exercise_speed_and_lists() {
	if [[ `pwd` == "$LUS_HOME/complete" ]]; then
		good_work
		echo ""
		echo $'Execute "learn" when you\'re ready for the next exercise.'
	else
		sorry
	fi
}

yellow_belt_exercise_unquoted_tab_completion() {
	fmt -u --width=$luc_width <<EOL
Question 1/1

What kind of file is Monday's TPS Report for John?

EOL

	luc_correct_answers=0
	luc_answers=( 'empty' 'Microsoft Word' 'text file' 'Martian cartographic data' )

	handle_answer 'empty'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

yellow_belt_exercise_unquoted_tab_completion_two_options() {
	fmt -u --width=$luc_width <<EOL
Question 1/1

What kind of file is Monday's TPS Report for Fred?

EOL

	luc_correct_answers=0
	luc_answers=( 'empty' 'Microsoft Excel' 'ASCII text' 'Open Office Presentation' )

	handle_answer 'ASCII text'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

yellow_belt_exercise_quoted_tab_completion() {
	fmt -u --width=$luc_width <<EOL
Question 1/1

What's inside Monday's TPS Report for Fred?

EOL

	luc_correct_answers=0
	luc_answers=( 'TBA' 'TBD' 'TBW' 'Top-secret Space Station Plans' )

	handle_answer 'TBW'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

yellow_belt_exercise_tab_is_context_sensitive() {
	keep_going
}

yellow_belt_exercise_up() {
	keep_going
}

yellow_belt_exercise_home_end_and_pound() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*# ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
}

yellow_belt_exercise_ctrl_r() {
	keep_going
}

yellow_belt_exercise_history_bang() {
	keep_going
}

yellow_belt_exercise_command_line_options() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*man( )*ls([ ]|$) ]]; then
			good_work
			echo ""
			echo $'Execute "learn" when you\'re ready for the next exercise.'
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

###############################
# End of function definitions #
###############################

# Script execution will begin here.

# If this script is switched back to being sourced, we'll need to change the "exit"s below to returns.

if [ ! -f ~/.learnUnix ]; then
	echo 'Please run the "learn" script first.'
	exit 1
fi

source ~/.learnUnix

if [ -z "${LUS_HOME:-}" ]; then
	LUS_HOME=$HOME/lus
fi

if [ -z "${RANK:-}" ] || [ -z "${EXERCISE:-}" ]; then
	fmt -u --width=$luc_width <<EOL
Please run the "learn" script first.
EOL
	exit 1
fi

if [[ ! "${RANK}" =~ ^(white|yellow|green|blue|red|black)_(stripe|belt)$ ]]; then
	fmt -u --width=$luc_width <<EOL
It looks like the ~/.learnUnix file has become corrupted.  If it can't be repaired, you may have no choice but to delete it
and start over.  Sorry about that.
EOL
	exit 2
fi

if [[ ! "${EXERCISE}" =~ ^[0-9]+$ ]]; then
	fmt -u --width=$luc_width <<EOL
It looks like the ~/.learnUnix file has become corrupted.  If it can't be repaired, you may have no choice but to delete it
and start over.  Sorry about that.
EOL
	exit 2
fi

luc_regex="'"
luc_regex+="${RANK}_exercise_.*\(\)"
luc_regex+="'"
luc_num_exercises=$(bash -c "grep -E ${luc_regex} ~/bin/learn | wc -l")

exercise_name=${exercises["${RANK}_${EXERCISE}"]:-}

if [ -z "$exercise_name" ]; then
	fmt -u --width=$luc_width <<EOL
There are no more exercises at this time.  If you like, you can review exercises you've already completed by executing
"learn white belt", "learn yellow stripe", or "learn white belt 6" to start review at a particular exercise.
EOL

	exit 1
fi

function_name="${RANK}_exercise_${exercise_name}"
eval $function_name

if [ "${EXERCISE:-}" == "${SAVED_EXERCISE:-}" ] && [ "${SAVED_RANK:-}" == "${RANK:-}" ]; then
	SAVED_RANK=""
	SAVED_EXERCISE=""
	updateDotFile

	fmt -u --width=$luc_width <<EOL
You were reviewing past exercises and you're now caught up to where you were.  Execute "learn" to continue.
EOL
fi

if (($EXERCISE > $luc_num_exercises)); then
	if [ $RANK == "white_belt" ]; then
		echo ""

		if [ -z "${SAVED_RANK:-}" ]; then
			printf "Congratulations!  You have now attained your `getBeltWithColours yellow_stripe`.\n"
			printf "You are now working toward your `getBeltWithColours yellow_belt`.\n\n"

			fmt -u --width=$luc_width <<EOL
If you don't consider yourself to be detail oriented, the last few yellow stripe exercises may be challenging.  If you need
caffeine, a good night's sleep, or a hearty breakfast to be on top of your game, consider doing that.  If you're a morning
person (or a night owl) and you can do the exercises in the morning (or at night), consider doing that.

From here on out, only the first exercise of each belt will prompt you to execute "learn" and ". check".
EOL

			RANK=yellow_stripe
			EXERCISE=1
		else
			printf "You have reviewed all the exercises in `getBeltWithColours white_belt`.\n"
			if [ "${SAVED_EXERCISE:-}" == "1" ] && [ "${SAVED_RANK:-}" == "yellow_stripe" ]; then
				printf "You're all caught up.\n"
				printf "Execute \"learn\" to begin the `getBeltWithColours yellow_stripe` exercises.\n"

				SAVED_RANK=""
				SAVED_EXERCISE=""
			else			
				printf "Execute \"learn\" to start reviewing the `getBeltWithColours yellow_stripe` exercises.\n"
			fi

			RANK=yellow_stripe
			EXERCISE=1
		fi
	elif [ $RANK == "yellow_stripe" ]; then
		RANK=yellow_belt
		EXERCISE=1

		echo ""

		if [ -z "${SAVED_RANK:-}" ]; then
			printf "Congratulations!  You have now attained your `getBeltWithColours yellow_belt`.\n"
			printf "You're working toward your `getBeltWithColours green_stripe`.\n\n"
		else
			printf "You have reviewed all the exercises in `getBeltWithColours yellow_stripe`.\n"
			printf "Execute \"learn\" to start reviewing the `getBeltWithColours green_stripe` exercises.\n\n"
		fi
	elif [ $RANK == "yellow_belt" ]; then
		if [ -z "${SAVED_RANK:-}" ]; then
			printf "Congratulations!  You have now attained your `getBeltWithColours green_stripe`.\n"
			printf "You would be working toward your `getBeltWithColours green_belt`, but there are no more exercises.\n\n"
		else
			printf "You have reviewed all the exercises in `getBeltWithColours yellow_belt`.\n"
			printf "There are no more exercises at this time.\n\n"

			SAVED_RANK=""
			SAVED_EXERCISE=""
		fi
	fi
fi

updateDotFile

