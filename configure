#!/bin/sh

rm -f config.status
rm -f docker/config.status
touch config.status
touch docker/config.status
mkdir -p flags

if [ "${BASH_VERSINFO:-0}" -le "4" ]; then
	if [ -f /usr/local/bin/bash ]; then
		homebrew=$(/usr/local/bin/bash -c 'echo ${BASH_VERSINFO[0]}')
		echo "/bin/bash too old, checking Homebrew version:  $homebrew"
		if [ "$homebrew" -le "4" ]; then
			echo "Associative array support, added in Bash 4.0, is required.  Homebrew bash not found either."
			echo "If you have a Mac, install Homebrew, then install bash."
			exit 2
		else
			sed 's/\/bin\/bash/\/usr\/local\/bin\/bash/' replace-master > replace
			chmod ug+x replace
			HOMEBREW_BASH=1
		fi
	else
		echo "Associative array support, added in Bash 4.0, is required."
		echo "If you have a Mac, install Homebrew, then install bash."
		exit 2
	fi 
else
	cp replace-master replace
fi 

# TODO:  Figure out how to do relative dates to ensure files created by touch are recent
#date --date="3 months ago" +"%Y%m%d"
#date -v-3m +"%Y%m%d"

echo "What would you like to do?"
echo "(1) Check to see if the scripts will work on this host without Docker."
echo "(2) Generate the scripts for audit or review (don't install)."
echo "(3) Create a Docker container for a single user and run it."
echo "(4) Create a Docker container that can share a volume (INCOMPLETE)."
echo "(5) Prepare the scripts to run directly (without docker) on this host."

read -p "Please answer (1-5)?  " luc_choice

custom_install=0
luc_choice_2=0

# A case statement might be overkill, but it allows for extra spaces in the
# input.

case "${luc_choice}" in
*1*)
	echo "Please run the "./verify" script.  It can't be run directly from this script"
	echo "as it checks for an interactive bash shell."
	exit 0
	;;
*2*)
	sed 's/^run:.*/run: configure replace/' Makefile-master > Makefile
	echo "export DOCKER=0" >> config.status
	;;
*3*)
	sed 's/^run:.*/run: configure dockerrun/' Makefile-master > Makefile
	DOCKER=1
	echo "export DOCKER=1" >> config.status
	;;
*4*)
	echo "This option isn't ready yet."
	;;
*5*)
	sed 's/^run:.*/run: configure flags\/replacetarget/' Makefile-master > Makefile
	if [ -n "${HOMEBREW_BASH:-}" ]; then
		echo "export HOMEBREW_BASH=1" >> config.status
	fi

	if echo "Test" | fmt -u 2>/dev/null; then
		echo "export FMT_OPTIONS=-u --width=" >> config.status
	else
		echo "export FMT_OPTIONS=-" >> config.status
	fi

	echo "export DOCKER=0" >> config.status

	echo "Where would you like to install the scripts?"
	echo "(1) Install for you only (~/bin/)."
	echo "(2) Install for everyone (/usr/local/bin/)."
	echo "(3) Custom"

	read -p "Please answer (1-3)?  " luc_choice_2
	case "${luc_choice_2}" in
	*1*)
		echo 'export INSTALL_PATH="${HOME}/bin"' >> config.status
		# Simplify it to a single number.
		luc_choice_2=1
		;;
	*2*)
		echo 'export INSTALL_PATH="/usr/local/bin"' >> config.status
		luc_choice_2=2
		;;
	*3*)
		echo 'export INSTALL_PATH="/usr/local/bin"' >> config.status
		luc_choice_2=3
		custom_install=1
		;;
	esac
	;;
*)
	echo "Your answer should be a number between 1 and 3."
	exit 1
esac

# Query a property from the terminal, e.g. background color.
#
# XTerm Operating System Commands
#     "ESC ] Ps;Pt ST"
#
# Copied and adapted from blueyed's answer to:
# https://stackoverflow.com/questions/2507337/how-to-determine-a-terminals-background-color

oldstty=$(stty -g)

# What to query?
# 11: text background
Ps=${1:-11}

echo "During background colour detection, the terminal may flash or beep, and"
echo "you may see some strange characters."

sleep 2

stty raw -echo min 0 time 0
# stty raw -echo min 0 time 1
printf "\033]$Ps;?\033\\"
# xterm needs the sleep (or "time 1", but that is 1/10th second).
sleep 0.01
read -r answer
result=${answer#*;}
stty $oldstty

case "${result}" in
*rgb*)
	echo
	echo "Detected RGB " $result

	colours=$(echo ${result} | sed 's/rgb://' | sed 's/[^[:print:]]//g')

	redhex=$(echo $colours | cut -f1 -d'/')
	greenhex=$(echo $colours | cut -f2 -d'/')
	bluehex=$(echo $colours | cut -f3 -d'/')

	red=$(printf "%d" $((16#$redhex)))
	green=$(printf "%d" $((16#$greenhex)))
	blue=$(printf "%d" $((16#$bluehex)))

	total=$(echo "$red + $green + $blue" | bc)

	if [ "$total" -gt "150000" ]; then
		echo "Enabling light mode."
		echo "export DARK_MODE=0" >> config.status
		echo "export DARK_MODE=0" >> docker/config.status
	else
		echo "Enabling dark mode (traditional white on black)."
		echo "export DARK_MODE=1" >> config.status
		echo "export DARK_MODE=1" >> docker/config.status
	fi
;;
*)
	echo "Colour detection failed."
	echo "Enabling dark mode (traditional white on black)."
	echo "export DARK_MODE=1" >> config.status
esac

if [ ! -f docker/Makefile ]; then
	cp docker/Makefile-master docker/Makefile
fi

if [ "${DOCKER:-0}" -eq "1" ]; then
	echo "export SHUF_BIN=shuf" >> config.status
	echo "export GREP_BIN=grep" >> config.status
else
	if which gshuf > /dev/null; then
		echo "export SHUF_BIN=gshuf" >> config.status
	elif which shuf > /dev/null; then
		echo "export SHUF_BIN=shuf" >> config.status
	else
		echo "Neither shuf or gshuf were found.  On Mac with Homebrew, brew install coreutils."
		exit 1
	fi

	if [ -x /usr/local/bin/grep ]; then
		echo "export GREP_BIN=/usr/local/bin/grep" >> config.status
	elif which ggrep > /dev/null; then
		echo "export GREP_BIN=ggrep" >> config.status
	fi
fi

touch flags/configuretarget

su_command=sudo
if which dzdo; then
	su_command=dzdo
fi

echo
if [ "${luc_choice_2}" -eq "0" ]; then
	echo "Run make with no arguments."
elif [ "${luc_choice_2}" -eq "1" ]; then
	echo "Run make install."
elif [ "${luc_choice_2}" -eq "2" ]; then
	echo "Run make with no arguments, then run ${su_command} make install."
else
	echo "(1) Update the config.status with the INSTALL_PATH that you want."
	echo "(2) Run make with no arguments."
	echo "(3) Run ${su_command} make install."
fi
