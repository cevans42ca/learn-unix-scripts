#!/bin/sh

# This file is part of the "learn-unix-scripts" project.
#
# This script prepares the other scripts to be run natively or with Docker.
#
# The "learn-unix-scripts" project is free software: you can redistribute it and/or modify it under the terms of the GNU
# General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# The "learn-unix-scripts" project is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with this project; if not, write to the
# Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA, 02111-1307, USA.
#
# Copyright (C) 2021 Christopher Evans

# This verify script's purpose is to help in confirming that all features and dependencies that the scripts use are
# available.  This script should be run the same way students are expected to run these scripts (for example, if students
# are expected to run these scripts by using PuTTY to SSH into an on-campus server, this script should be run the same
# way).

# This script was developed in a 130x30 terminal.

verify_grep() {
	output=$(echo ":test:" | "${1}" -Po "(?<=:)test(?=:)" 2>/dev/null)
	if [ $? == "0" ]; then
		if [ "$output" == "test" ]; then
			echo "${1} has a working -P."
			echo "export GREP_BIN=${1}" >> config.status
			grep_found=1
		fi
	else
		echo "A grep was found in the PATH but it doesn't support -P."
	fi
}

rm -f config.status
rm -f main/docker/config.status
touch config.status
touch main/docker/config.status
mkdir -p flags

if which bash > /dev/null; then
	bash_bin=$(which bash)
	bash_version_info=$(bash -c 'echo ${BASH_VERSINFO[0]}')
	if [ "$bash_version_info" -lt "4" ]; then
		if [ -f /usr/local/bin/bash ]; then
			homebrew=$(/usr/local/bin/bash -c 'echo ${BASH_VERSINFO[0]}')
			echo "/bin/bash too old, checking Homebrew version:  $homebrew"
			if [ "$homebrew" -lt "4" ]; then
				echo "Associative array support, added in Bash 4.0, is required.  Homebrew bash not found either."
				echo "If you have a Mac, install Homebrew, then install bash."
				exit 2
			else
				sed 's:#!/bin/bash:#!/usr/local/bin/bash:' main/replace-master > main/replace
				chmod ug+x main/replace
				BASH_BIN=/usr/local/bin/bash
			fi
		else
			echo "Associative array support, added in Bash 4.0, is required."
			echo "If you have a Mac, install Homebrew, then install bash."
			exit 2
		fi 
	else
		sed "s:#!/bin/bash:#!${bash_bin}:" main/replace-master > main/replace
		chmod ug+x main/replace
		BASH_BIN=$(which bash)
	fi 
else
	echo "Bash not found."
	echo "Associative array support, added in Bash 4.0, is required."
	echo "If you have a Mac, install Homebrew, then install bash."
fi

# TODO:  Figure out how to do relative dates to ensure files created by touch are recent
#date --date="3 months ago" +"%Y%m%d"
#date -v-3m +"%Y%m%d"

echo "This configure script is intended for system administrators."
echo "If you aren't one, please use the Docker container instead by following"
echo "the steps at the following link."
echo
echo "https://github.com/cevans42ca/learn-unix-scripts#try-them-out-in-docker"
echo
echo "What would you like to do?"
echo "(1) Check to see if the scripts will work on this host without Docker."
echo "(2) Generate the scripts for audit or review (don't install)."
echo "(3) Create a Docker container for a single user and run it."
echo "(4) Create a Docker container that can share a volume (INCOMPLETE)."
echo "(5) Prepare the scripts to run directly (without docker) on this host."
echo "(6) Prepare the scripts to run directly (without docker) on another host."

read -p "Please answer (1-6)?  " luc_choice

custom_install=0
luc_choice_2=0

# A case statement might be overkill, but it allows for extra spaces in the
# input.

case "${luc_choice}" in
*1*)
	echo "Please run the "./verify" script.  It can't be run directly from this script"
	echo "as it checks for an interactive bash shell."
	exit 0
	;;
*2*)
	sed 's/^run:.*/run: configure replace/' main/Makefile-master > Makefile
	echo "export DOCKER=0" >> config.status
	;;
*3*)
	sed 's/^run:.*/run: configure dockerrun/' main/Makefile-master > Makefile
	DOCKER=1
	echo "export DOCKER=1" >> config.status
	echo "export SHARED_VOLUME=single" >> main/docker/config.status
	;;
*4*)
	sed 's/^run:.*/run: configure dockerrun/' main/Makefile-master > Makefile
	DOCKER=1
	echo "export DOCKER=1" >> config.status
	echo "export SHARED_VOLUME=shared" >> docker/config.status

	# Remove any spaces.
	luc_choice=4
	;;
*5*)
	sed 's/^run:.*/run: configure flags\/replacetarget/' main/Makefile-master > Makefile

	if [ -n "${BASH_BIN:-}" ]; then
		# This variable will be used by make, so we can't include quotes.
		echo "export BASH_BIN=${BASH_BIN}" >> config.status
	fi

	if echo "Test" | fmt -u >/dev/null 2>&1; then
		echo "export FMT_OPTIONS=-u --width=" >> config.status
	else
		echo "export FMT_OPTIONS=-" >> config.status
	fi

	echo "export DOCKER=0" >> config.status

	echo "Where would you like to install the scripts?"
	echo "(1) Install for you only (~/bin/)."
	echo "(2) Install for everyone (/usr/local/bin/)."
	echo "(3) Custom"

	read -p "Please answer (1-3)?  " luc_choice_2
	case "${luc_choice_2}" in
	*1*)
		echo 'export INSTALL_PATH="${HOME}/bin"' >> config.status
		# Simplify it to a single number.
		luc_choice_2=1
		;;
	*2*)
		echo 'export INSTALL_PATH="/usr/local/bin"' >> config.status
		luc_choice_2=2
		;;
	l3*)
		echo 'export INSTALL_PATH="/usr/local/bin"' >> config.status
		luc_choice_2=3
		custom_install=1
		;;
	esac
	;;
*6*)
	echo "Please run these scripts on that host."
	exit 1
	;;
*)
	echo "Your answer should be a number between 1 and 6."
	exit 1
esac

# Query a property from the terminal, e.g. background color.
#
# XTerm Operating System Commands
#     "ESC ] Ps;Pt ST"
#
# Copied and adapted from blueyed's answer to:
# https://stackoverflow.com/questions/2507337/how-to-determine-a-terminals-background-color

oldstty=$(stty -g)

# What to query?
# 11: text background
Ps=${1:-11}

echo "During background colour detection, the terminal may flash or beep, and"
echo "you may see some strange characters."

sleep 2

stty raw -echo min 0 time 0
# stty raw -echo min 0 time 1
printf "\033]$Ps;?\033\\"
# xterm needs the sleep (or "time 1", but that is 1/10th second).
sleep 0.5
read -r answer
result=${answer#*;}
stty $oldstty

case "${result}" in
*rgb*)
	echo
	echo "Detected RGB " $result

	colours=$(echo ${result} | sed 's/rgb://' | sed 's/[^[:print:]]//g')

	redhex=$(echo $colours | cut -f1 -d'/')
	greenhex=$(echo $colours | cut -f2 -d'/')
	bluehex=$(echo $colours | cut -f3 -d'/')

	red=$(printf "%d" $((16#$redhex)))
	green=$(printf "%d" $((16#$greenhex)))
	blue=$(printf "%d" $((16#$bluehex)))

	total=$(echo "$red + $green + $blue" | bc)

	if [ "$total" -gt "150000" ]; then
		echo "Enabling light mode."
		echo "export DARK_MODE=0" >> config.status
		echo "export DARK_MODE=0" >> main/docker/config.status
	else
		echo "Enabling dark mode (traditional white on black)."
		echo "export DARK_MODE=1" >> config.status
		echo "export DARK_MODE=1" >> main/docker/config.status
	fi
;;
*)
	echo "Colour detection failed."
	echo "Enabling dark mode (traditional white on black)."
	echo "export DARK_MODE=1" >> config.status
esac

if [ ! -f main/docker/Makefile ]; then
	cp main/docker/Makefile-master main/docker/Makefile
fi

if [ "${DOCKER:-0}" -eq "1" ]; then
	echo "export GREP_BIN=grep" >> config.status

	if [[ "${luc_choice}" == "4" ]]; then
		( cd main/docker && make createsharedvolume )
	fi
else
	grep_found=0
	if which grep > /dev/null 2>&1; then
		verify_grep grep
	else
		echo "Couldn't find grep."
	fi

	if [ "${grep_found}" = "0" ]; then
		if which ggrep > /dev/null 2>&1; then
			verify_grep ggrep
		fi
	fi

	if [ "${grep_found}" = "0" ]; then
		if [ -x /usr/local/bin/grep ]; then
			verify_grep /usr/local/bin/grep
		fi
	fi
	
	# Try perl
	perl_found=0
	if [ "${grep_found}" = "0" ]; then
		echo "Unable to find a usable grep."
		if which perl >/dev/null 2>&1; then
			if which perldoc >/dev/null 2>&1; then
				if perldoc -lm Term::ANSIColor >/dev/null 2>&1; then
					echo "Found perl."
					perl -e "$(cat <<'EOF'
use Term::ANSIColor;

if (":test:" !~ /(^|.*:)(\Qtest\E)(:.*|$)/)
{ exit 1; }
EOF
)"
					if [ $? = "0" ]; then
						perl_found=1
					else
						echo "Unable to run a perl heredoc."
					fi
				else
					echo "Please install perl's Term::ANSIColor module."
				fi
			else
				echo "perl found but perldoc not found.  Please install or reinstall perl."
			fi
		fi
	fi

	if [ "${perl_found}" = "0" ]; then
		echo "Unable to find a grep that supports -P, or perl."
		echo "On FreeBSD, you can either:"
		echo "(1) install a grep that supports -P"
		echo "    (a) as ggrep"
		echo "    (b) as /usr/local/bin/grep"
		echo "    (c) as /usr/local/bin/ggrep"
		echo
		echo "OR"
		echo
		echo "(2) install Perl 5 or later (pkg install perl5)"
		exit 20
	fi
fi

touch flags/configuretarget

su_command=sudo
if which dzdo > /dev/null 2>&1; then
	su_command=dzdo
fi

echo
if [ "${luc_choice_2}" -eq "0" ]; then
	echo "Run make with no arguments."
elif [ "${luc_choice_2}" -eq "1" ]; then
	if [ ! -d "${HOME}/bin" ]; then
		echo "Creating ${HOME}/bin."
		echo "It may already be in your path, you may need to login again to add it to your"
		echo "path, or you may need to add it to your path manually."
		mkdir -p "${HOME}/bin"
	fi

	if which make > /dev/null 2>&1; then
		echo "Run make install."
	else
		echo "Run make install with your version of make, or:"
		echo "cd main"
		echo "./replace-all"
		echo "cp dist/bin/* ~/bin/"
	fi
elif [ "${luc_choice_2}" -eq "2" ]; then
	if which make > /dev/null 2>&1; then
		echo "Run make with no arguments, then run ${su_command} make install."
	else
		echo "Run make with no arguments, then run ${su_command} make install."
		echo "Or, if you don't have a version of make:"
		echo "cd main"
		echo "./replace-all"
		echo "${su_command} cp dist/bin/* /usr/local/bin/"
	fi
else
	echo "(1) Update the config.status with the INSTALL_PATH that you want."
	echo "(2) Run make with no arguments."
	echo "(3) Run ${su_command} make install."
fi
