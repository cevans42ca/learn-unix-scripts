#!/bin/bash

# This file is part of the "learn-unix-scripts" project.
#
# The "learn-unix-scripts" project is free software: you can redistribute it and/or modify it under the terms of the GNU
# General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# The "learn-unix-scripts" project is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with this project; if not, write to the
# Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA, 02111-1307, USA.
#
# Copyright (C) 2021 Christopher Evans

# This script was developed in a 130x30 terminal.

# replace start 1acc396a-02a2-40b8-a427-f4685c20320e (see below for what this line does)
#
# This script is the master script for the learn script.  If you have site-specific changes that you don't want to share,
# you can add a GUID in this script and use the "replace" script to merge this script with your site-specific changes
# (in learn-replace) and create a site-specific learn script.  You can insert or replace portions of this code.
#
# If we didn't replace this text when we created the learn script, it would seem as though people should be making the changes
# to the learn script and not this one.  See the replacement for 1acc396a-02a2-40b8-a427-f4685c20320e in learn-replace for more.
#
# Insert exercises or elements that are specific to your site with "# insert <GUID>".  If you put a space after the GUID,
# you can add comments.  Replace parts with "# replace start <GUID>" and "# replace end <GUID>".  To remove sections,
# replace the content with nothing.  Put the replacements in the learn-replace file.
#
# Make sure to keep the exercises in order in this file and in the checkmain script, or the list argument won't work.
#
# replace end 1acc396a-02a2-40b8-a427-f4685c20320e

# insert 4c02f3dc-1640-11ed-baa4-1511ebd0a2d1 check tput

# Setting nounset is worth having to sometimes reference variables as ${VAR:-}.
set -e -o nounset

# DARK_MODE Replacement Tag:  if not running in Docker, replace this line with DARK_MODE=0 for black text on white

# insert 17fa07e6-24b8-4e35-bc1a-094427fd8699

if [ "$(whoami)" == "root" ]; then
	echo "Run this script as yourself, not the root user.  (Don't use dzdo or sudo.)"
	exit 1
fi

less_prompt_move_on="Press h for help;?e: Enter for more (line %lb of %L).?e q to move on."
less_prompt_quit="Press h for help;?e: Enter for more (line %lb of %L).?e q to quit."

# insert bef71a69-5f8d-43d4-af29-60608e9b56c7 temp file clean up
# insert 1a88ef09-bbc8-4f7e-ac03-a1849fd03166 stty options
# insert ffa9e74e-2b02-4d72-9c82-9f9db2915c62 associative arrays for exercises and belt levels

# Top of file script definitions (Start vim fold) {{{

FMT_OPTIONS="-u --width="
GREP_BIN=grep
LUS_PERL=0

get_rows_and_columns() {
	STTY_ROWS=$(stty ${stty_options} | head -1 | sed 's/.*; \([0-9][0-9]*\) rows.*/\1/;s/.*; rows \([0-9][0-9]*\).*/\1/')
	STTY_COLUMNS=$(stty ${stty_options} | head -1 | sed 's/.*; \([0-9][0-9]*\) columns.*/\1/;s/.*; columns \([0-9][0-9]*\).*/\1/')
	if (($STTY_ROWS > 50)); then
		WIDTH=`expr $STTY_COLUMNS - 5`
	else
		WIDTH=$STTY_COLUMNS
	fi
}

get_rows_and_columns

resize_to_default() {
	printf "\033[s\033[8;24;80t\033[u"

	echo -n "Resizing..."
	sleep 1

	get_rows_and_columns

	if (($STTY_ROWS < 24)) || (($STTY_COLUMNS < 80)); then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
It looks like the automatic resize didn't work.  Continue anyway (y/N)?
EOL

		if [[ ! "$CHOICE" =~ ^\s*[Yy].* ]]; then
			exit 1
		fi
	fi
}

# The following function deals with matters relating to the terminal size.
size_matters() {
	get_rows_and_columns

	# PuTTY uses a default size of 80x24, though 80x25 tends to be more of a standard (because of VT100 terminals).
	standard_rows=0
	if [ "$STTY_ROWS" == 24 ] || [ "$STTY_ROWS" == 25 ]; then
		standard_rows=1
	fi

	if [ "$STTY_COLUMNS" == 80 ] && [ "$standard_rows" -eq "1" ] && [ -z "${RESIZED_ALREADY:-}" ]; then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
It looks like your terminal is set to the default size of 80 columns and $STTY_ROWS rows.  This script is capable of
using more.  If you're able to change the size of the terminal, please do so, then press Enter to continue.
EOL

		echo ""
		read

		get_rows_and_columns

		if (("$STTY_COLUMNS" < "80")) || (("$STTY_ROWS" < 24)); then
			fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
Oh!  A wise guy!  How about we change that back to the default (Y/y)?
EOL

			read CHOICE

			# We already know the terminal can support 80x24.  Time for a bit of fun.
			if [ -n "${CHOICE:-}" ] && [[ ! "${CHOICE:-}" =~ ^\s*[Yy].* ]]; then
				echo "That's a funny way to spell it but that will do just fine."
			fi

			resize_to_default
			echo ""
		else
			TERM_SIZE="${STTY_COLUMNS}x$STTY_ROWS"

			FMT_STRING=""

			if (("$STTY_COLUMNS" >= "200")) && (("$STTY_ROWS" >= 40)); then
				FMT_STRING="What, $TERM_SIZE?!  Seriously?  Now you're just showing off."
			elif (("$STTY_COLUMNS" >= "170")) && (("$STTY_ROWS" >= 35)); then
				FMT_STRING="Wow, $TERM_SIZE?  Luxurious!  There's plenty of room now."
			elif (("$STTY_COLUMNS" >= "130")) && (("$STTY_ROWS" >= 30)); then
				FMT_STRING="Wow, $TERM_SIZE?  Very spacious!"
			elif (("$STTY_COLUMNS" >= "120")) && (("$STTY_ROWS" >= 30)); then
				FMT_STRING="OK, $TERM_SIZE.  That's very respectable."
			elif (("$STTY_COLUMNS" >= "120")) && (("$STTY_ROWS" >= 25)); then
				FMT_STRING="Alright, $TERM_SIZE.  That will do just fine."
			fi	

			if [ -n "${FMT_STRING:-}" ]; then
				fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
$FMT_STRING
EOL
			fi

			echo ""
		fi
	fi
}

# Run "grep" on this file and pipe it to "wc" to count the number of exercises for the current belt.
set_num_exercises() {
	regex="'"
	regex+="${RANK}_exercise_.*\(\)"
	regex+="'"
	NUM_EXERCISES=$(bash -c "grep -E ${regex} ~/bin/learn | wc -l | tr -d '[:blank:]'")
}

set_num_exercises_for_review() {
	regex="'"
	regex+="${new_rank}_exercise_.*\(\)"
	regex+="'"
	NUM_REVIEW_EXERCISES=$(bash -c "grep -E ${regex} ~/bin/learn | wc -l | tr -d '[:blank:]'")
}

print_rank() {
	# Use an extra ${nc} to fix an issue with PuTTY.
	if [ -n "${SAVED_RANK:-}" ]; then
		if [ "$SAVED_RANK" == "white_belt" ]; then
			printf "Your current rank is `getBeltWithColours white_belt`.\n"
			printf "You are working toward your `getBeltWithColours yellow_stripe`.\n\n"
		elif [ "$SAVED_RANK" == "yellow_stripe" ]; then
			printf "Your current rank is `getBeltWithColours yellow_stripe`.\n"
			printf "You are working toward your `getBeltWithColours yellow_belt`.\n\n"
		elif [ "$SAVED_RANK" == "yellow_belt" ]; then
			printf "Your current rank is `getBeltWithColours yellow_belt`.\n"
			printf "You are working toward your `getBeltWithColours green_stripe`.\n\n"
		fi

		belt=$(getBeltWithColours $RANK)
		printf "You are reviewing the exercises for ${belt}.  "
		printf 'To return to where you were, execute "learn --return".\n\n'
	else
		if [ "$RANK" == "white_belt" ]; then
			printf "Your current rank is `getBeltWithColours white_belt`.\n"
			printf "You are working toward your `getBeltWithColours yellow_stripe`.\n\n"
		elif [ "$RANK" == "yellow_stripe" ]; then
			printf "Your current rank is `getBeltWithColours yellow_stripe`.\n"
			printf "You are working toward your `getBeltWithColours yellow_belt`.\n\n"
		elif [ "$RANK" == "yellow_belt" ]; then
			printf "Your current rank is `getBeltWithColours yellow_belt`.\n"
			printf "You are working toward your `getBeltWithColours green_stripe`.\n\n"
		fi
	fi
}

complete_exercise() {
	less -R -P "$less_prompt_quit" $fmt_file

	# Print the exercise (or the last part of the exercise) to the terminal.  Since "less" cleans up after itself, if we
	# don't do this, the user has nothing to reference to finish the task.
	cat $fmt_file
}

# insert 37333148-8746-4468-826e-544e532f1ebc updateDotFile, getBeltWithColours

prepareLusHome() {
	if [[ "${INSIDE_DOCKER:-0}" == "0" ]]; then
		if [ ! -d "${LUS_HOME}" ]; then
			mkdir -p "${LUS_HOME}"
			if [[ "${SHARED_VOLUME:-}" == "1" ]]; then
				chmod go-rwx
			fi
		fi
	else
		if [ ! -d "$LUS_DOCKER_BASE/lus" ]; then
			mkdir -p "${LUS_DOCKER_BASE}"/lus
		fi
	fi
}

show_script_path_in_path() {
	if [ "${LUS_PERL:-}" == "0" ]; then
		# Use positive lookbehind and positive lookahead to match the exact path, whether it's at the beginning of the
		# $PATH, the end, or in the middle.  This way, we can both highlight the exact path and show the entire $PATH.
		# It won't work if the path in $PATH has a trailing slash, but trailing slashes shouldn't be there.
		printf '%s\n' "$PATH" | ${GREP_BIN} -P --color=always "(?<=^|:)${script_path}(?=:|\$)" >> $fmt_file
	else
		perl -e "$(cat <<'EOF'
use Term::ANSIColor;
$script_path=$ARGV[0];

open(FH, ">>$ARGV[1]") or die "Unable to open $ARGV[1].";

if ($ENV{"PATH"} =~ /(^|.*:)(\Q${script_path}\E)(:.*|$)/)
{ print FH $1 . color('bold red') . $2 . color('reset') . $3 . "\n"; }
else
{ print FH "Unable to find ${script_path} in " . $ENV["PATH"] . ".\n"; }

close(FH);
EOF
)" "${script_path}" "${fmt_file}"
	fi
}

blue_stripe_lorem_ipsum() {
	prepareLusHome

	cat <<EOL > "${LUS_HOME}/blue-stripe/vi-intro.txt"
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum malesuada ut
quam at ullamcorper. Praesent cursus tellus in convallis pulvinar. Sed
facilisis, urna nec venenatis mattis, orci ex consequat nibh, id aliquet diam
lectus at turpis. Morbi porttitor bibendum sem ut faucibus. Interdum et
malesuada fames ac ante ipsum primis in faucibus. Morbi ac sagittis dui. Aliquam
fermentum magna nec faucibus imperdiet. In hac habitasse platea dictumst.
Curabitur imperdiet lorem fringilla leo pellentesque, quis fermentum augue
vestibulum. Nunc pellentesque in massa et cursus. Suspendisse at euismod leo, ac
volutpat ex. Phasellus vel finibus diam.

Pellentesque malesuada felis in justo pretium feugiat. Vivamus lobortis, urna
nec rhoncus viverra, nulla quam semper ante, non vehicula orci tortor vitae
eros. Donec eget eros faucibus, tristique sem non, condimentum arcu. Morbi quis
bibendum magna. Ut bibendum purus nunc, non porta justo aliquam eget. Praesent
vel odio quis tellus feugiat viverra. Pellentesque mollis et mauris in sagittis.

Quisque suscipit efficitur nisi in tempor. Donec nulla quam, pretium ut dapibus
vestibulum, iaculis ac ante. Ut facilisis ante ac imperdiet viverra. Vivamus
lectus lectus, fermentum non turpis quis, facilisis congue metus. Nullam ut
tellus vulputate, mattis est vitae, dapibus orci. Integer condimentum quis risus
ac fringilla. Quisque efficitur posuere eleifend. Cras eget neque eget ante
scelerisque imperdiet. Proin lorem lorem, malesuada non condimentum eu, accumsan
at odio. Integer laoreet venenatis lacus, at iaculis massa venenatis ac.

Vivamus iaculis et neque eu porta. Duis quam felis, placerat eu rhoncus a,
feugiat nec neque. Duis rhoncus justo non lectus sollicitudin vulputate. Vivamus
ac libero finibus, commodo lacus a, suscipit mi. Praesent lacinia ex arcu, at
elementum eros ornare sed. Curabitur non nisi sapien. Suspendisse vehicula ex id
congue laoreet. Duis posuere tortor a quam blandit, vel molestie ex aliquet.
Vestibulum tempus lacus in diam viverra, sit amet semper lorem consectetur.
Donec leo quam, tincidunt sed ipsum ac, posuere interdum felis. Nunc quis metus
sit amet nunc feugiat consequat sit amet eget urna. Nullam bibendum convallis
enim eu luctus. Aliquam vitae scelerisque augue, a ullamcorper enim. Nam
hendrerit dui in nibh ornare, ut consequat lectus suscipit.

Vestibulum molestie pellentesque sodales. Nunc tincidunt ipsum eu viverra
tincidunt. Nulla facilisi. Etiam consequat finibus nibh, fermentum imperdiet
libero dictum in. Sed erat ex, laoreet ut aliquam et, dapibus eu magna.
Vestibulum at posuere arcu. Mauris a ligula at nisl tincidunt imperdiet. Quisque
dapibus, turpis et ornare venenatis, tortor diam pretium ipsum, vitae semper
lectus arcu ac est. Maecenas vestibulum risus eu lacinia blandit. Sed vel est
sapien. Vestibulum et ullamcorper est, fermentum elementum sem. Aliquam et
placerat sapien.
EOL
}

# (End vim fold) }}}

# White belt exercises (Start vim fold) {{{
white_belt_exercise_what_execute_means() { # What "Execute" Means, and Your Prompt
	yellow_stripe="${yellow_on_black}yellow ${nc}${bright_white_on_black}stripe${nc}"
	printf "${underline}The Bare Essentials${no_underline}\n\n" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
In the United States and Canada, grammar rules say to put the period inside the double quotes.

    He told me, "You need to go to the store."

We will follow https://en.wikipedia.org/wiki/Quotation_marks_in_English#Logical_quotation
rules (also called British practice, British style, and logical punctuation).

If this script says to execute "set", that means to type the letters s, e, t, and press Enter.  Don't type the double quotes.

If an exercise asks you to execute "scp bcompcd101:/tmp/file.txt ." then the space and dot at the end, before the final
double quote, are important and must be typed before pressing Enter.

At the end of a sentence, you will see: "scp bcompcd101:/tmp/file.txt .".

To see the overview of what is covered in each belt, execute "learn --welcome".

The exerices leading to your yellow stripe will have more reading and rote completion.  As you rise through the ranks,
fewer steps will be directly stated.  This script will provide resources for you to reference to finish the exercises.
In particular, this exercise has the most reading and the least to do.
EOL

	printf "\n\n${underline}Your Prompt${no_underline}\n\n" >> $fmt_file
		x="$(PS1=\"${PS1:-}\" echo -n | bash -i 2>&1 | sed $'s/.*\007//' | tr -d '\r' | sed 's/stdin: is not a tty//')"
		# If the prompt starts with "bash", it's probably a default prompt, and not the real one.
		# Checking if $PS1 is set doesn't seem to work in all cases.
		if [[ "${x}" =~ ^bash.* ]]; then
			fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Here are some examples of prompts.  Real prompts will have 'user', 'host', and 'directory' filled in with the real
values based on who is logged in, what directory they're in, and what host they're using.
EOL
			echo >> $fmt_file
			echo "[user:host directory]$" >> $fmt_file
			echo "host:directory user$" >> $fmt_file
			echo "user@host directory$" >> $fmt_file
			echo
			echo "They usually end with a dollar sign ( $ )."
		else
			fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Your current prompt is as follows.

${x%exit}
EOL
		fi

		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

When you see your prompt, that means that the previous commands have completed and your shell is ready for another command.
(We'll be going into more detail on shells later.)  Prompts are one of the most heavily customized aspects of Unix, ranging
from a simple dollar sign to multi-line creations.  You should expect your prompt to look similar across different computers
(or hosts) run by the same people, but different as you move elsewhere.
EOL

	printf "\n\n${underline}I'm Stuck!${no_underline}\n\n" >> $fmt_file
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
It's always a good idea to take notes, because it helps with recall.  But there a few things this script will specifically
call out for you to make a note of, things you're always going to want to have handy.  Take them down in whatever style you
like (Evernote, a personal wiki, on your phone, Microsoft OneNote, a mind map, or good old pen and paper) but make sure it
will be available whenever you're at a Unix terminal.

Characters include letters, numbers, and punctuation.  Space is a character.  There are non-printable characters like
tab, carriage return, and Ctrl+a through Ctrl+z.  We're not going to get into Chinese, Japanese, and Korean, where things
are even more complicated.

Your interrupt character is Ctrl+c (don't type it now, but in order to type it, hold one of the Ctrl keys down and press
the "c" key.  Do not use either Shift key.)  There are only a few cases where typing Ctrl+c will not stop what's happening
and return you to a prompt.  We will be covering two of these soon.  Make a note of it.

For now, it's a good thing that Ctrl+c will get you out of most situations.  Later, you will learn to be more careful
about using Ctrl+c, and we will go over other things you might want to try first.

EOL

	printf "\n\n${underline}Moving On${no_underline}\n\n" >> $fmt_file
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
After reading the text for each exercise, you will need to do three things.  For white belt, you only need to remember
the first step.  All the white belt exercises will tell you what to do for step 2 and will remind you to do step 3.

(1) Quit the lesson by pressing "q" (which will return you to your prompt).

(2) Complete anything the exercise asked you to do.  For this exercise, there isn't anything to do for this step.
Almost all the other exercises will ask you to something for this step.

(3) Execute ". check".

Do these now.  There was a lot of text since we covered what execute means.  If you're not sure on this one, press the Up
Arrow key to go back.  If the Up Arrow key doesn't work, you can press the k key to go back.
EOL

	complete_exercise
}

white_belt_exercise_stuck() { # Freezing and Unfreezing the Terminal
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
The first thing you don't want to be caught by is Ctrl+q and Ctrl+s.  If you accidentally type Ctrl and "s", the terminal will
freeze.  Ctrl+s is easy to type and is in common use in Windows programs as a keyboard shortcut for saving the current file.
Depending on your background, it may be second nature to you to type it when you want to save something.

If you find that your terminal is locked, frozen, or in a weird state, the first thing you should do is type Ctrl+c.
The second thing you should try is typing Ctrl+q (Ctrl with a lowercase "q", or equivalently:  Ctrl and "q" but not
including shift).

Ctrl+q and Ctrl+s are holdovers of an ancient age when it was more common to print output to a printer than a screen.
Printers were much slower and needed time to catch up.  These continued to be used with displays to freeze the screen so
that users could read something that was quickly scrolling by.  Ctrl+q and Ctrl+s can still be used that way, but there are
generally better options available now that allow programs to continue to run while the user is looking at something.

Please make a note of these now.  There will be a question later about it.  (The history lesson is not on the test.)

Execute ". check".
EOL

	complete_exercise
}

white_belt_exercise_cd_root() { # The Root Directory
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Now that you know how to recover from your terminal getting frozen and how to get a prompt back, you need to know how to
navigate.

All files and directories have a path which tells the operating system how to retrieve them.  You may be familiar with
Microsoft Windows-style paths such as C:\\Windows\\System\\.  When you insert a USB stick, Windows usually assigns the
drive letter D: or E: to the new drive, unless it's already taken.  Unix doesn't have drive letters.  Instead, all drives
(local drives, shared drives, and removable drives) are in one unified filesystem.

Where it makes sense to distinguish between the part of a computer that reads a USB stick and the USB stick itself, we
will call USB sticks, SD cards, and similar things "removable media".  We'll use the term "drive" to refer to hard
drives and the part of a computer that reads removable media like SD cards and USB sticks.

Before disk drives, there were tape drives.  (Tape drives remain today for very long-term archival storage of large
amounts of data, but it's rare.)  If you've seen old movies or an old projector, you may have seen a reel-to-reel tape.
The drive mechanism that moved the tape back and forth became the name for the whole thing.  Later, there were spinning
disks, and there was a mechanism that drove the disks around.  Now, it's becoming more and more uncommon for drives in a
computer system to have anything that's driving some kind of motion.  They retain the name "drive" anyway.  It's like
the floppy disk icon, still ubiquitous in software as what you click on to save what you're working on.

In a future exercise, we'll look at how data is brought in from network drives and removable drives.

In Unix, paths use forward slashes ( / ) instead of backslashes.  The path to your home directory is $HOME.  Your home
directory contains everything that's only for you.  It will be mostly configuration settings, but more generally,
anything you're working on that isn't shared with other users will be in $HOME.

You may have a $HOME/bin directory for programs that are only for you.  There are multiple directories called "bin" on a
Unix system.  The one in your home directory contains programs (compiled binaries, scripts, and anything else that can
be run) for your use only.  For example, some people set up a particular version of a common program that has different
features.  You may want to have scripts that automate certain tasks that are too specific for other users to use, and
they should go in $HOME/bin.

Windows usually uses the term "folder" as an equivalent term for "directory".

When you ran this script, you were in the `pwd` directory.

Let's begin at the beginning:  the root directory.  (Not to be confused with the /root directory.)
EOL

	echo >> $fmt_file
	echo 'Execute "cd /".' >> $fmt_file
	echo 'Then execute ". check"' >> $fmt_file

	less -R -P "$less_prompt_move_on" $fmt_file

	# Print the exercise to the terminal to retain context.
	cat $fmt_file
}

white_belt_exercise_ls_root() { # What Does the Root Look Like?
	# If the user is coming back after needing to look at something else, they may now be in another directory.
	if [[ `pwd` == "/" ]]; then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
It's time to take a look around.  Execute "ls", read the names of the directories, and execute ". check".
EOL
	else
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
It's time to take a look around.  Execute "cd /", execute "ls", read the names of the directories, and execute ". check".
EOL
	fi

	complete_exercise
}

white_belt_exercise_common_root_directories() { # Explanation of Directories Under Root
	# The existence of /opt can't be counted on, but it's hard to imagine the rest would be missing on any modern
	# Unix derivative.  Maybe this script is being run in a Docker container.  Handling missing directories, formatting
	# to the TTY size, and paging the whole thing was a chance to sharpen my skills.
	# It's also a good reference for redirecting output from a program that already has a heredoc coming in.

	set +e
	ROOT_USERNAME=$(bash -c 'getent passwd "0" 2> /dev/null | cut -d: -f1')
	set -e
	ROOT_TEXT=""

	if [ -n "${ROOT_USERNAME:-}" ] && [ "$ROOT_USERNAME" != "root" ]; then
		ROOT_TEXT="On this system, the administrator account is called $ROOT_USERNAME."
	fi

	# $ROOT_TEXT should be at the end of the line so the formatting works out.
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
For the following notes, keep in mind that the root user (usually simply called "root") is the administrator account.  $ROOT_TEXT
The root user has access to everything and is allowed to do everything, unless permissions have been deliberately given up.
A simple example is making a file read only.  The root user can put up blocks to make things more difficult to do, but the
root user could remove them at any time.
EOL

	printf "\nHere are some of the things you saw.\n" >> $fmt_file

	if [ -d "/bin" ]; then
		printf "\n${underline}/bin${no_underline}\n" >> $fmt_file
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Stands for BINaries (programs that aren't scripts).  The core binaries are here, like "ls". 
EOL
	fi

	if [ -d "/etc" ]; then
		printf "\n${underline}/etc${no_underline}\n" >> $fmt_file
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  You'll find all system wide configuration here.
EOL
	fi

	if [ -d "/home" ]; then
		printf "\n${underline}/home${no_underline}\n" >> $fmt_file
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Each user's home directory is under here.  Your home directory (${HOME}) contains everything that's only for you,
  especially configuration files.  In most Unix enviroments, your home directory is shared across multiple servers so your
  configuration settings are available across multiple servers.  On Macs, this directory (if it exists) will usually be
  empty, and all the users' home directories will be in /Users instead.
EOL
	fi

	if [ -d "/opt" ]; then
		printf "\n${underline}/opt${no_underline}\n" >> $fmt_file
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Sometimes seen on Red Hat Linux servers, the /opt directory is for OPTional software that's not part of the distribution.
  (If you want, you can look up what a Linux distribution is.)  You might find an Oracle DB instance or a Dynatrace OneAgent
  installed here.
EOL
	fi

	if [ -d "/root" ]; then
		printf "\n${underline}/root${no_underline}\n" >> $fmt_file
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  The root user's home directory (set aside for the root user's personal use).  Depending on the installation, the /root
  directory can sometimes be used in emergencies if other parts of the filesystem are full.
EOL
	fi

	if [ -d "/sbin" ]; then
		printf "\n${underline}/sbin${no_underline}\n" >> $fmt_file
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Stands for Secure BINaries.  Binary programs (not scripts) that are run only by privileged users go here.  For example,
  the programs that change network configurations are here, as well as programs for other system maintenance and starting up the
  operating system.
EOL
	fi

	if [ -d "/tmp" ]; then
		printf "\n${underline}/tmp${no_underline}\n" >> $fmt_file
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Short for TeMP, this directory is where any temporary files are created.  Well-behaved programs should clean up after
  themselves.  Most systems are configured to delete any files that haven't been modified in a week (two weeks is also common).
EOL
	fi

	if [ -d "/Users" ]; then
		printf "\n${underline}/Users${no_underline}\n" >> $fmt_file
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Each user's home directory is under here.  On most flavors of Unix, home directories are under /home instead.
  Your home directory ($HOME) contains everything that's only for you, particularly configuration files.  In most
  Unix enviroments, your home directory is shared across multiple servers so your configuration settings are available
  across multiple servers.
EOL
	fi

	if [ -d "/usr" ]; then
		printf "\n${underline}/usr${no_underline}\n" >> $fmt_file
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Short for "user", i.e. for "regular" users and not the root user.  Most programs are under here somewhere (/usr/bin,
  /usr/local/bin, /usr/sbin, /usr/local/sbin).
EOL
	fi

	if [ -d "/var" ]; then
		printf "\n${underline}/var${no_underline}\n" >> $fmt_file
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Short for VARiable, this directory is for things that are constantly changing, particularly:  log files, caches, mail, and
  printer queues.
EOL
	fi

	echo "" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
For a full list, see https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard.

EOL
	

	if [[ `pwd` == "$HOME" ]]; then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
This exercise was going to ask you to go back to your home directory, but you're already there.  Use a "cd" command (a
command that begins with "cd") to change directory (like "cd /").  You can any one of the following commands to return
to your home directory.  Since you're already in your home directory, you can run them, but they won't have any effect.

If your home directory ($HOME) has a space in it (possible in Windows with Cygwin, Git Bash, MinGW, etc.) then you'll
need to quote it.  If you have a space in your user name on a Windows machine and you plan to install some Unix-like
software for Windows (like Cygwin, Git Bash, MingGW, etc.) you might want to keep that in mind.  In these cases, you'll
want to stick to the first two.  We'll look at quoting in the next belt.

EOL

cat <<EOL >> $fmt_file
cd
cd ~
cd $HOME
cd ${HOME}/
EOL

		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

Then execute ". check".
EOL
	else
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Let's return to your home directory.  The following commands are equivalent.

If your home directory ($HOME) has a space in it (possible in Windows with Cygwin, Git Bash, MinGW, etc.) then you'll
need to quote it.  If that's the case, stick to the first two for now.  We'll look at quoting in the next belt.

EOL

cat <<EOL >> $fmt_file
cd
cd ~
cd $HOME
cd ${HOME}/
EOL

		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Execute one of them, then execute ". check".
EOL
	fi

	complete_exercise
}

white_belt_exercise_set() { # The "set" Command
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Usually, programs need some information from us on what they need to do.  The "cp" (CoPy) program needs to know what we
want to copy and where to put the copy.  Sometimes, programs don't need anything else.  The "clear" program clears the
screen.  You don't need to give it anything more.  The "pwd" program doesn't need anything either.  If you execute "pwd"
it will tell you the full path of your current directory.

In a previous exercise we executed "cd /".  We passed "/" as an argument to "cd" to create the command "cd /".

Many references will use the term "command" to refer to a program.  In the case of a program that has no arguments, they
are essentially the same thing.  Technically, a command is a program possibly followed by arguments.  These terms are
often used interchangeably because it rarely causes confusion.

There are four ways to pass settings to programs:  environment variables, arguments, standard input, and configuration
files.

We will be looking at environment variables next.  Environment variables are good if you have settings that you want to
always use.  One commonly used environment variable is "EDITOR".  Many programs (like crontab and git) automatically
open a text editor for you to make changes to something.  By setting an environment variable in your profile file, you
can permanately set your preference.  (It's an example.  We're not going to be doing that right now.)

The "set" command will show you the current environment variables.  If you run it as is, most of the output will scroll
past, but go ahead anyway and execute "set".

Remember to execute ". check" after.
EOL

	complete_exercise
}

white_belt_exercise_frozen() { # The First Test
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
It's time for the first test.  Make sure your notes are handy and execute ". check".
EOL

	complete_exercise
}

white_belt_exercise_set_more() { # The "more" Command
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
To go page by page, add "| more" to a command.  The pipe ( | ) can be used to send the output of one command to the
input of another command.  They are separate commands.  The pipe is not an argument to "set".  Our shell runs both
programs and connects them together.  We'll be going into more detail on pipes much later.  The pipe character is rarely
used outside of technical fields.  On many keyboard layouts, you can type it with Shift+Backslash.

When you execute "set | more", you will be able to move a page at a time by pressing Space.  Move a line at a time by
pressing Enter.  To quit before the end, press "q".  With some flavours of Unix, if you quit before the end, you will see
a warning about a broken pipe.  Execute "set | more" now and remember to execute ". check" after.
EOL

	complete_exercise
}

white_belt_exercise_set_less() { # The "less" Command
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
The "more" command will only give you more.  If you want to back up, add "| less" to a command.  In many cases (but depending
on your terminal settings) you will be able to move up and down with the cursor keys and use the Page Up and Page Down keys.
As before, Space will go a page forward, Enter will show one more line, and "q" will quit.

Most commands will quit when you type Ctrl+c, but "less" doesn't quit by default with Ctrl+c.  When you press Ctrl+c in
"less", it will stop whatever you're doing within "less".  For example, when you have "less" open you can search
for something, which might take a long time if it's a big file.  You can stop the search by pressing Ctrl+c.  You will need
to press "q" to quit.  Take a note.  If you miss it, you will be stuck, just as with Ctrl+s.

Execute "set | less" and remember to execute ". check" after.
EOL

	complete_exercise
}

white_belt_exercise_path_and_sourcing() { # $PATH, Sourcing, Processes, Final Exam
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
We're going to look at one specific environment variable now:  \$PATH.  Environment variables are usually printed with a
dollar sign ( \$ ) in front of them.  Currently, \$PATH is set to the following value.

$PATH
EOL

	echo "" >> $fmt_file

	# I copied this code from Stack Overflow.  It's probably overkill.
	# https://stackoverflow.com/questions/4774054/reliable-way-for-a-bash-script-to-get-the-full-path-to-itself
	script_name=`basename $0`
	# Don't resolve symlinks, as /home is symlinked to /usr/home on FreeBSD.
	script_path=$(dirname "${0}")

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
\$PATH contains a list of paths where programs might be found (scripts, binaries, and anything that can be run).

This script is in $script_path and the full path to it is $script_path/$script_name.  
EOL

	echo "" >> $fmt_file
	show_script_path_in_path
	echo "" >> $fmt_file

	less -R -P "$less_prompt_move_on" $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL > $fmt_file
The \$PATH environment variable lists all the directories where programs can be found.  On Windows, the current directory
is always checked first for commands, operable programs, or batch files.  On Unix, typically the current directory is never
in the \$PATH.

Consider the case where a friend or coworker has made their own /home/user/bin directory available for you to look at.
If they prefer different versions of common tools, like "ls" to get a directory listing, then you will unwittingly run their
version if you are in their /home/user/bin directory.  Normally, such cases are not malicious, but they may be surprising
or confusing.  Unix and all its derivatives are known for a philosophy that prioritizes consistency and security over
convenience.

If you want to run a command in the current directory and you have the appropriate permissions, you can add "./" to the
beginning of it, but we're not going to do that right now.

You've run the "learn" and "check" scripts from two different places (the root directory and your home directory) and
neither one is where the scripts are.  The \$PATH environment variable provides your bin directory as one place to look
for programs, so you can run anything found in your \$PATH wherever you are.
EOL

	echo "" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
The last thing to teach you before you get your yellow stripe is why you need to add the dot and space at the beginning
of the "check" script.  Normally, when you run a program, it runs in its own process, but the dot changes that.  Let's
go more into detail about what a process is.

Unix systems allow many people to do work on the same computer at the same time.  At any point in time, multiple people
might be running an "ls" command.  We don't want these to get mixed up.  A process is a running* copy of a program.
Processes allow Unix to keep the different running copies (or instances) of programs straight.

Unix creates an entry in the process table for each copy or instance of all running programs.  You can think of the
process table as a spreadsheet or work sheet, where each process has a row.  There are many columns:  a unique ID, the
user ID that started it, what directory it was started in, and many other details.  The process table is stored in
memory.

* If a program has finished running, it will have an exit code, which is stored in the process table.  Processes
stick around until their parent (the program that started them) requests their exit code:  these are called zombie
processes.  In Unix, zombies are part of the normal lifecycle of processes, but in a properly functioning system, they
don't last long.

Let's go back to environment variables.

All modern operating systems allow you to run multiple instances of the same program, which can work on different inputs
at the same time.  Each new instance of the program (the child) gets a copy of some of the environment variables.
Environment variables in scripts need to be "exported" to show up in child processes.  Any environment variables that
are changed while the child runs are not reflected in the parent.

Carefully controlling environment variables results in programs that are cleaner and more resilient.

You will only need to understand these details about environment variables when writing bash (and similar) scripts,
however, being aware of these factors is important if most of your previous experience is with Microsoft Windows (see
below).

The dot (.) in ". check" is a short form for the built-in command "source", so executing ". check" is a short form for
"source check".  When you source a script, the script runs as if it was typed in.  (If you're familiar with Windows
batch files, all batch files run as if they were typed in.  Another way to say it is that Windows batch files are always
sourced.)  This "sourcing" trick is how we can have scripts that set environment variables for other scripts.  It can
also be used to get an up-to-date command history (which is normally inaccessible).  Since running the "set" command
doesn't change anything that can be checked directly, accessing the command history is the only way that the check
script can verify that the correct command was issued.

Further belts may ask you to source the check script, which means to execute "source check" (or equivalently execute
". check").  Make a note of it so you can refer to it later.

Once you have read and understood this text, execute ". check" for your (short) final exam.
EOL

	complete_exercise
}

# (End vim fold) }}}

# Yellow stripe exercises (Start vim fold) {{{
yellow_stripe_exercise_pwd() { # The "pwd" Command
	if [[ `pwd` == "/" ]]; then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
To begin this exericse, you can't be in the root directory.  Execute "cd", then execute "learn".
EOL
		complete_exercise
		exit 0
	fi

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
The theme of the yellow stripe exericses is creating files and directories, and in particular, characters that should be avoided.
We will also be looking at the special directories "." and "..".

As you rise through the ranks, fewer steps will be directly stated.  You should be familiar with pressing "q" to quit the
lesson so you can go back to a prompt and continue, and executing ". check" to confirm that you can go on to the next
exercise.  In between will be whatever the lesson requires, which will generally be to execute a command of some sort.

In these exercises, you'll be creating files and directories under $LUS_HOME.  Please leave this directory for the exercises.
If you want to try out the commands you're learning and it's not part of an exercise, please do it in a different directory.

Before we move around, you should have a better sense of where you are.  The "pwd" command stands for "Print Working
Directory" and tells you the full path to your current working directory.  Try it now.  When you're done, remember to execute
". check".
EOL

	complete_exercise
}

yellow_stripe_exercise_cd_dot_dot() { # Parent Directories, ".", and ".."
	if [[ `pwd` == "/" ]]; then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
To begin this exericse, you can't be in the root directory.  Execute "cd", then execute "learn".
EOL
		complete_exercise
		exit 0
	fi

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
The directory "." is a special directory that refers to the current directory.  All directories have a "." directory and
it cannot be removed.  The following paths all reference the same directory.

EOL

	echo "$HOME" >> $fmt_file
	echo "$HOME/." >> $fmt_file
	echo "$HOME/./." >> $fmt_file
	echo "$HOME/././." >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

The "." directory can be useful to provide as a source or destination.

For example, the secure copy "scp" program securely copies files and folders between computers.  It requires at least one
source and exactly one destination.

scp user@othercomputer:/home/user/fileToGet .

The command above copies the file /home/user/fileToGet into the current directory.
EOL

printf "\n\n${underline}The Parent Rescue${no_underline}\n\n" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
The special directory ".." refers to the parent directory.  The following paths point to the same directory.

EOL

	echo "/home/" >> $fmt_file
	echo "/home/example/.." >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

All of these following paths also point to the same directory (a different one than the one above).

EOL

echo "/home/example/" >> $fmt_file
echo "/home/example/../example/" >> $fmt_file
echo "/home/example/../example/../example/" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

In the white belt exercises, you went from your home directory to the root directory, then back.  This
time, we'll look at each step along the way.  To go one directory up, execute "cd ..".  In many cases,
"cd.." will also work.  Execute "pwd", then "cd ..", then "pwd", then "cd ..".  If you're not in the root directory by
then, continue until you are.
EOL

	complete_exercise
}

yellow_stripe_exercise_no_news_is_good_news() { # No News is Good News
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
When it comes to Unix, always remember:  no news is good news.

The oldest and most core programs ("cp, "mv", "rm", etc.) will only print something if there was a problem.
If you get a prompt and nothing more, the program did as you asked.  If something went wrong, the program
or your shell would've told you.

Although this point is easy to explain, it's quite important, and so it has its own exercise.

Execute ". check" for a one question quiz.
EOL

	complete_exercise
}

yellow_stripe_exercise_mkdir_and_relative_paths() { # The "mkdir" Command and Relative Paths
	prepareLusHome

	if [ -d $LUS_HOME/parent ]; then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
This exercise involves creating the directory $LUS_HOME/parent, which already exists.  You will need to move it or rename
it by executing "mv $LUS_HOME/parent newname", then executing "learn" again.
EOL

		less -R -P "$less_prompt_move_on" $fmt_file

		exit 2
	fi

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Before we make directories, you should be aware of the differences between Unix and Windows.  Older versions of Windows
allowed a file and a directory in the same place to have the same name.  That's no longer allowed, and was never allowed
in Unix.  Unix (except for Mac) is case sensitive, so a file called "File" is not the same file as a file called "file".
These two examples can be in the same directory at the same time (but not on Mac).

The "mkdir" command creates directories.  Given what you know about "." and "..", think about the following commands.

EOL

	echo "cd $LUS_HOME" >> $fmt_file
	echo "mkdir parent" >> $fmt_file
	echo "cd parent" >> $fmt_file
	echo "mkdir one" >> $fmt_file
	echo "cd one" >> $fmt_file
	echo "mkdir ../two" >> $fmt_file
	echo "mkdir ../three" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

Once you've thought about it, execute the commands.  Please be careful when entering them.  If you get it wrong, you'll
have to rename the parent directory and start from the beginning.  You can delete your attempts later when you have
more experience.

Use "cd" and "ls" to go through the directories and take a look at what you've done.  See if you were right about what
they would look like.  If they look different than you expected, think about why.  (And when you're all done with all of that,
execute ". check".)
EOL

	complete_exercise
}

yellow_stripe_exercise_rmdir() { # The "rmdir" Command
	if [ ! -d "$LUS_HOME" ]; then
		mkdir "$LUS_HOME"
	fi

	if [ ! -d "$LUS_HOME/parent" ] || [ ! -d "$LUS_HOME/parent/one" ] || [ ! -d "$LUS_HOME/parent/two" ] || [ ! -d "$LUS_HOME/parent/three" ]; then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
This exercise involves removing directories created in a previous exercise.  At least one of them doesn't exist.  Create them (y/n)?
EOL

		read CHOICE

		if [[ "${CHOICE:-}" =~ ^\s*[Yy].* ]]; then
			mkdir -p $LUS_HOME/parent/one
			mkdir -p $LUS_HOME/parent/two
			mkdir -p $LUS_HOME/parent/three
		else
			exit 2
		fi
	fi

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
The "rmdir" command removes directories.  The directory must be empty for "rmdir" to work.  We will look at deleting
whole trees of directories later.  If you want to delete a directory, and it's empty, use "rmdir" as it's safer.  Read
these commands and see if you can follow what they do.

EOL

	echo "cd $LUS_HOME" >> $fmt_file
	echo "rmdir parent/one" >> $fmt_file
	echo "cd parent" >> $fmt_file
	echo "rmdir two" >> $fmt_file
	echo "rmdir three" >> $fmt_file
	echo "cd .." >> $fmt_file
	echo "rmdir parent" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

Once you've thought about it, execute the commands.  Please be careful when entering them.  If you get it wrong, when you
run "learn" again, you can choose to create any missing directories so you can try again.
EOL

	complete_exercise
}

yellow_stripe_exercise_special_characters() { # Special Characters in Filenames and Directory Names
	prepareLusHome
	
	if [ -f $LUS_HOME/yellow ]; then
		less -R -P "$less_prompt_move_on" $fmt_file
	
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
This exercise involves creating the file $LUS_HOME/yellow, which already exists.  Delete it (y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			rm -f $LUS_HOME/yellow
		else
			exit 2
		fi
	fi

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
We're going to switch focus to filenames, file types, and how to look at file contents.

Windows is up front about the characters that you're not allowed to use in a file or directory name.  They are as follows.

\ / : * ? " < > |

Unix will let you use any character on the keyboard in a file or directory name, except for forward slash "/", which is
used to create paths.  Problems crop up later.

If you use a colon ":" in a file or directory name, you won't be able to add it to your \$PATH, though it's not a big
deal in most cases.  Historically, Macs used colon ":" for the same purpose as Unix uses forward slash "/", so various
programs will accept one and not the other.  Programs will convert between them.  Avoid colons on Macs.  If a Mac
program lets you use a forward slash "/" in a file or directory name, don't.

Spaces in file and directory names can also be problematic.  It takes more effort to write scripts that handle files
with spaces in them, so it's not hard to find scripts that were never written to handle them.  It's better to stick to
underscores "_" or hyphens "-" instead of spaces.

Files starting with a dash are particularly difficult to handle.  Unix programs almost always take options that start
with a dash.  For example, the copy command "cp" takes an argument "-R" for copying a directory and everything under it
to a new location.  The "R" stands for recursive.  Recursion is a problem solving technique where we split a request
into slightly smaller requests until we have everything we need to answer the question, solve the problem, or finish the
request.  Each directory we recurse into is a slightly smaller part of the overall request.  When we ask a program
to recurse into a directory, it keeps recursing until there are no more directories to recurse into.

Getting back on track, with "cp", we use the "-R" option for that.  The source is first and the destination is second.

cp -R /tmp/foo /tmp/bar

If you want to copy a file called "-R" and a file called "foo" in "/tmp/" to "/tmp/bar" then you could use the following
command.

cp -- -R /tmp/foo /tmp/bar

The core tools (like copy "cp", move "mv", and remove "rm") support the "--" argument to indicate all the options
are done and everything after that is a file or directory.  Don't expect other programs will be able to work with files
that start with a dash.

The other special characters that aren't allowed on Windows are a little easier to work with, though you'll need to put the
file name in single quotes (not double quotes).  We'll do more with single quotes and double quotes soon.

Remember that Unix filesystems are usually case sensitive.  If you create a file called test and try to open a file
called Test, you should expect to receive an error that the file cannot be found.  (Unless it's a Mac.)

Execute the following commands, remembering that Unix is (usually) case sensitive.  It will create a new file with the
filename "yellow".

EOL

	echo "cd $LUS_HOME" >> $fmt_file
	echo 'echo "Hello world." > yellow' >> $fmt_file

	complete_exercise
}

yellow_stripe_exercise_file() { # The "file" Command and Magic
	prepareLusHome
	
	if [ ! -f $LUS_HOME/yellow ]; then
		less -R -P "$less_prompt_move_on" $fmt_file
	
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
The previous exercise involves creating the file $LUS_HOME/yellow, but it doesn't exist.  Create it (y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			echo "Hello world." > $LUS_HOME/yellow
		else
			exit 2
		fi
	fi

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Now that you've created the file $LUS_HOME/yellow, let's look at ways to see what's in it.

Windows popularized the idea of file extensions (foo.bat is a batch file, foo.txt is a text file, foo.doc is a Microsoft
Word document, etc.)  Unix doesn't require extensions, though it's quite common to see them.  Instead of using file
extensions, Unix uses the first few bytes of a file to tell what kind of file it is.  This file type detection process is
called "file magic" or sometimes "magic".  The file that stores a list of all the bytes and what file types they signify
is usually named "magic".  If you're interested in more details, you can check "man magic".

The program that can check a file's type is named "file".

Execute "cd $LUS_HOME", then execute "file yellow".
EOL

	complete_exercise
}

yellow_stripe_exercise_cat_less() { # Comparing "cat" and "less"
	prepareLusHome
	
	if [ ! -f $LUS_HOME/yellow ]; then
		less -R -P "$less_prompt_move_on" $fmt_file
	
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
A previous exercise involves creating the file $LUS_HOME/yellow, but it doesn't exist.  Create it (y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			echo "Hello world." > $LUS_HOME/yellow
		else
			exit 2
		fi
	fi

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
The simplest way to see what's in a file is with the "cat" command (which is short for conCATenate).  Before you use "cat",
you need to know that it's a small file.  (We'll look at file sizes later.)  If you accidentally "cat" a large file, your
terminal may be stuck for a while, even if you type Ctrl+c.

In a previous exercise, you executed "set | less", but you can also provide an argument to "less" to use "less" to look at a file.
It's safe to use "less" on large files.  Remember that you need to press "q" to quit less.

Execute "cd $LUS_HOME", then execute "cat yellow", then execute "less yellow".
EOL

	complete_exercise
}

yellow_stripe_exercise_quotes() { # Introduction to Quoting
	set +o nounset
	x="$(PS1=\"$PS1\" echo -n | bash -i 2>&1)"
	PS2=$(bash -ci 'echo $PS2')
	set -o nounset

	non_default_PS2=""
	if [ "$(simple_trim $PS2)" != ">" ]; then
		non_default_PS2="(On your system, it's different.)  "
	fi

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
We're going to change focus one more time and look at single and double quotes.

Double quotes are one way to work with filenames that have spaces in them.  Single quotes are one way to work with filenames
that have special characters in them.  But before we look at how they can be helpful, let's look at what can happen when
things go wrong.

For example, let's assume you've typed "echo", followed by a space, and then a double quote, and finally press Enter.
You'll see the following.

${x%exit} echo "
EOL

	echo "$PS2" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

In most cases, the character on the second line is a right angle bracket ( > ).  ${non_default_PS2}Single quotes
and double quotes must have a matching single or double quote.  (Experts:  we'll look at escaping shortly.)  The right
angle bracket or other prompt tells you that you started some quoted text but didn't finish it.  The shell is letting you
finish it.  The Enter you typed will be part of the final string you're making.  In most cases, this situation is a mistake.
Ctrl+c to the rescue!

We're going to use the "echo" command for these examples, but remember that you can use these strings of characters in a
lot of different situations.  Try out the following.

EOL

	cat <<EOL >> $fmt_file
echo "HOME"
echo "\$HOME"
echo '\$HOME'
EOL

	complete_exercise
}

yellow_stripe_exercise_escaping_quotes() { # Escaping Characters
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Double quotes let you use environment variables.   If you want to work with a file that has a dollar sign, you need to
use single quotes.  Now is a good time to talk about literals.  Your shell treats a lot of characters in a special way.
The pipe ( | ) is used to connect two programs together.  The right angle bracket ( > ) sends a program's output to a file.
But what if you want to use them exactly as they are?  Then you need them to be literals.  A literal pipe is a pipe that
means exactly what it is (and not a direction to the shell to connect two programs together).  If you're using double quotes
and you need to put a literal double quote, then you use the backslash character ( \\ ).  On most keyboards, it's above the
Enter key.  It's usually on the same key as pipe ( | ).

You should expect pretty much every punctuation character to have some kind of special meaning to your shell.

You can also turn spaces into literal spaces with a backslash.  If you're working with a file that has spaces in it,
you can escape the spaces with backslashes rather than putting the whole thing in double quotes.  For example,
the following two command lines produce the same result.
EOL

	fmt ${FMT_OPTIONS:-} -s --width=$WIDTH <<EOL >> $fmt_file

echo "Hello world." > "file with spaces"
echo "Hello world." > file\\ with\\ spaces

EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
You can try them out, but keep in mind that you won't be told if you're overwriing an existing file.  Make sure you're not
overwriting anything important first.

Try the following just before executing ". check".

EOL

	fmt ${FMT_OPTIONS:-} -s --width=$WIDTH <<EOL >> $fmt_file
echo "\"HOME\""
echo "\"\$HOME\""
echo "'\$HOME'"
EOL

	complete_exercise
}

yellow_stripe_exercise_quote_finale() { # Quoting:  Final Lesson
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
You might think that you could also escape a single quote to use it inside single quotes.  There are some shells that handle
it, but you shouldn't expect it.  What you can do instead is end the single quote, put a single quote in double quotes, and
then start the single quote again.

When it's broken out, it looks like this.

'First section' "'" 'Second section'

But that's a list of three arguments.  If you need to refer to a filename, you'll need to remove the spaces.  (Yes, it's
difficult to read.)

'First section'"'"'Second section'

If you need to work with a filename that has single quotes, it's best to put the whole thing in double quotes.

"First section'Second section"

If you have single quotes, double quotes, and other special characters like dollar sign ( $ ), you may be better off using
the trick above.

Execute ". check" for your final exam.
EOL

	complete_exercise
}

# (End vim fold) }}}

# Yellow belt exercises (Start vim fold) {{{
yellow_belt_exercise_speed_and_lists() { # More Speed!  Using Asterisk
	if [ ! -d "$LUS_HOME/complete" ]; then
		mkdir -p "$LUS_HOME/complete"
	fi

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
To get your green stripe, we will be looking at two things:  speed, and more about file listings.

The speed part will be partly up to you, for a few reasons.  It's not possible for a script to check that you're doing them
correctly.  It's time for you to take it on yourself.  All the exercises so far will work on many different versions and
flavours of Unix with different terminals and different shells, but some of these exercises may not work the same way for you.

Since it's not possible to build a check script to check the things you're doing in this belt, be extra careful that you
don't execute ". check" multiple times in a row, or you could skip exercises.  Not all the exercises have something to
be checked.  If you accidentally skip an exercise, you can review a previous exercise with "learn yellow belt 4" for
exercise 4 (for example).  You can also see a list of exercises with "learn yellow belt list".  If you complete all the
exercises up to the one you're on, you'll see a message, and your progress will be tracked from that point.

We've been using the words "terminal" and "shell" without defining them, since the exact meaning wasn't necessary to understand.
Perhaps you looked them up.  In the 1970s, it was easy to tell the difference between a terminal and a shell, because
the terminal was a big box that sat on a desk with a keyboard and screen.  Now, both are software.

Your terminal:
EOL

set_color=""
clear_color=""
underline_code=""
no_underline_code=""
if [ "${enable_tput}" == "1" ]; then
	set_color="$(tput setaf 2)"
	clear_color="$(tput sgr0)"
	underline_code="$(tput smul)"
	no_underline_code="$(tput rmul)"
fi

	fmt ${FMT_OPTIONS:-} --prefix="  * " --width=$WIDTH <<EOL >> $fmt_file
  * Has a size measured in rows and columns

  * Controls the font and font size (how the characters look)

  * Sends what you type to your shell and displays the output from your shell

  * Accepts special sequences of characters that change the ${set_color}colour${clear_color} or ${underline_code}formatting${no_underline_code}

Your shell:
  * Accepts characters from your terminal and figures out what you're asking it to do

  * Runs any programs you asked it to run

  * Sends the output from those programs to your terminal so you can see it (or gives you another prompt if there was no output)

Different shells are almost always available, but these scripts only work with the "bash" shell (short for "Bourne Again
Shell").  Depending on what Unix system you're using and how you're connecting to it, you may have a choice of terminal.

What you type is interpreted by your terminal before it gets to your shell.  Since these scripts require you to use the
bash shell, if these don't work, it's likely due to your terminal or your terminal settings, so you will need to find someone
knowledgable in the terminal you're using or have to use.

The first way to boost your speed is tab completion.  In many cases, tab completion can eliminate the need for quoting a
file name.  After going through those tricky questions in the last belt, are you angry?  Annoyed?  Relieved?  Always be
ready to properly quote a filename.  If you need notes for it, keep them with you.  It could come up when you least expect it.

You can use tab completion to complete filenames, directory names, program names, and in a few cases, command line arguments.

Before we do tab completion of a filename, we'll look at what you can do if it's not available.

Go to $LUS_HOME and execute "ls".  From there you're going to cd to the "complete" directory, but you're not going
to type all the letters.  Type "cd", a space, the letter "c", and an asterisk ( * ) which is usually Shift+8.  Press Enter.
You can use this trick with files and directories (but not commands or command line arguments).

The asterisk is often called a "star".

If there are other directories that start with "c" and you type "cd c*", then your shell will change your current directory
to the first one in alphabetical order.  Tab is better than asterisk, because you get to see where you're going before you
go and change your mind.

Here, we're using an asterisk to speed up typing a single file name.  Later, we'll look at using it for multiple filenames.

After trying all that out, remember to execute ". check".
EOL

	complete_exercise
}

yellow_belt_exercise_unquoted_tab_completion() { # Introduction to Tab Completion
	if [ ! -d "$LUS_HOME/complete" ]; then
		mkdir -p "$LUS_HOME/complete"
	fi

	touch "$LUS_HOME/complete/Monday's TPS Report for John"

	files=$(ls -1 "$LUS_HOME/complete"/Mon* | wc -l)
	if [ ! "$files" == "1" ]; then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
There are extra files in $LUS_HOME/complete.  Is it OK to delete them (y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			rm -f "$LUS_HOME/complete"/Mon*
			touch "$LUS_HOME/complete/Monday's TPS Report for John"
		else
			exit 2
		fi
	fi

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Now that you know how to speed up no matter the circumstances (with asterisk), let's see if tab completion works for you.

Make sure you're in $LUS_HOME/complete.  Type "file Mon" (without the quotes).  Press Tab.

If nothing happened when you pressed Tab, type an asterisk.

If you saw some garbage characters show up when you pressed Tab, press Backspace until the garbage characters are gone,
then type an asterisk.

If you saw your shell escape the filename with backslashes, breathe a sigh of relief.

Whatever happened, press Enter and read the results of the command you executed.  Do you remember what the "file" command
does?  What does this output mean?  As usual, source the check script to move on.
EOL

	complete_exercise
}

create_two_TPS_reports() {
	touch "$LUS_HOME/complete/Monday's TPS Report for John"

	if [ -f "$LUS_HOME/complete/Monday's TPS Report for Fred" ]; then
		chars=$(cat "$LUS_HOME/complete/Monday's TPS Report for Fred" | wc -c)
		if [ ! "$chars" == "4" ]; then
			fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
Monday's TPS Report for Fred has been modified.  Is it OK to overwrite it (y/n)?
EOL

			read CHOICE

			if [[ ! "$CHOICE" =~ ^\s*[Yy].* ]]; then
				exit 2
			fi
		fi
	fi

	echo "TBW" > "$LUS_HOME/complete/Monday's TPS Report for Fred"

	files=$(ls -1 "$LUS_HOME/complete"/Mon* | wc -l)
	if [ ! "$files" == "2" ]; then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
There are extra files in $LUS_HOME/complete.  Is it OK to delete them (y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			rm -f "$LUS_HOME/complete"/Mon*
			touch "$LUS_HOME/complete/Monday's TPS Report for John"
			echo "TBW" > "$LUS_HOME/complete/Monday's TPS Report for Fred"
		else
			exit 2
		fi
	fi
}

yellow_belt_exercise_unquoted_tab_completion_two_options() { # Tab Completion with Two Options
	if [ ! -d "$LUS_HOME/complete" ]; then
		mkdir -p "$LUS_HOME/complete"
	fi

	create_two_TPS_reports

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Make sure you're in $LUS_HOME/complete.  Type "file Mon" (without the quotes).  Press Tab.  This time, if tab completion
is working, part of the file will be filled in.  That's because there are now two files that start with "Mon".

If tab completion is working, press Tab and press Tab again to see the options.  Type F, then Tab, then Enter.

If you saw some garbage characters show up when you pressed Tab, press Backspace until the garbage characters are gone,
then type an asterisk, then type "Fred" (without the quotes).  You should now have "file Mon*Fred" ready to execute.
Press Enter to execute it.

If nothing happened, type an asterisk, then type "Fred" (without the quotes).  You should now have "file Mon*Fred"
ready to execute.  Press Enter to execute it.

Read the results of the command you executed.
EOL

	complete_exercise
}

yellow_belt_exercise_quoted_tab_completion() { # Tab Completion with a Quote
	create_two_TPS_reports

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
When you pressed Tab before, you had typed part of a filename but you didn't use a single or double quote.  In this
exercise, you're going to see what happens if you do.

If you start a filename with a single or double quote, it's likely that your shell won't help you finish the filename like
it did before, nor will it tell you what the valid options are.  In other words, if you start with a double quote, your
shell won't be as helpful.  Worse, if you put an asterisk ( * ) inside a quotation, your shell will treat it as a literal
asterisk, so you can't use it as a filename short cut unless you first close the quotation you started with another quote.

That's what you should do if you run into that situation.

If you start the filename with a single or double quote and press Tab, and your shell fills in part of the filename,
you should type a matching quote and press Tab.  Your shell will convert the quotation to a series of escapes instead,
and now your shell will be a little more helpful letting you finish the filename.

If pressing Tab hasn't done anything at all, you can use an asterisk to complete part of the filename, just make sure it's
not in either kind of quotes.

Make sure you're in $LUS_HOME/complete.  Type in each command line below and then press Tab three times.  To go onto the
next one, hold down Backspace until it's all gone or press Ctrl+c.

EOL

			echo "file Mon" >> $fmt_file
			echo "file "'"'"Mon" >> $fmt_file
			echo "file 'Mon" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

Do you see how starting with a quote will finish part of the filename but won't help you after that?

Try the two kinds of quotes again, but this time, if you started with a double quote, use another double quote at the end
to close the quotation (and the same for single quotes).  Then try pressing Tab again.  Press Tab two more times to see
your options.  Suddenly, your shell is helpful again, offering options and finishing it off once you indicate which
one you want (with an "F" or a "J").

When you execute any of these commands, you'll see the file's type again.  If you run any of them with a starting quote and no
finishing quote, the shell won't give you another standard prompt until you end the quote or press Ctrl+c.  That's how you
create filenames with line breaks in them (please don't).

Now, use what you've learned to take a look at what's inside the file "Monday's TPS Report for Fred" without typing the
whole filename and letting your shell do all the work.  This time, instead of getting the file's type, we're looking for
the file's contents.  (Hint:  the file is very small.)
EOL

	complete_exercise
}

yellow_belt_exercise_tab_is_context_sensitive() { # Tab is Context Sensitive:  What are you Completing?

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
It matters where in the command line you press Tab.  The first thing on a command line must be a program or alias (we'll look
at aliases later).

Let's say you have a program called "myprogram" in your home directory.  Let's say your home directory is not in your \$PATH
(it usually isn't).  If you type "myprog" and press Tab, nothing will happen, because the first thing on a command line must
be a program, and "myprogram" isn't in your \$PATH, so it doesn't count.

But if you type "file myprog" and press Tab, then your shell will complete it, because in this case, any file is good here.

If you type "cd myprog" and press Tab, nothing will happen, because "myprogram" is not a directory.

For your shell to complete something at the beginning of a command line (assuming it's not an alias) it needs to be in your
path and you need to have permission to read it and run it.

If you have permission to read it and run it, you can get around the \$PATH issue by starting with "./".  If you type
"./myprog" (with or without the quotes) and Tab, your shell will complete it for you.  

If you're trying to run a program and the shell is not completing the name for you, it's an indication that it's not in
your \$PATH or the permissions could be wrong.  We'll look at permissions later.  If you're trying to "cd" to a directory
and your shell is not completing it, it might not be a directory, or you might have the name wrong.

There's nothing to complete for this exercise before executing ". check".
EOL

	complete_exercise
}

yellow_belt_exercise_up() { # Finding and Running Previous Commands one Line at a Time
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
There are a few ways you can run a previous command.  The simplest way is with the up arrow.  Depending on your
terminal settings, the most likely thing to happen is that you'll see the previous command you ran (which will
be "learn").  If that works, you can press Up or Down to go through your previous commands.  You'll also be
able to press Left and Right, Del, Backspace, and make any changes you want to.  Press Enter to execute your
current command (even if you're not at the end).

The second most likely thing to happen is that you'll see this: "^]]A".  There are a couple of things you can do.  You can
try to get help from someone who knows the kind of terminal you're using and fix your terminal settings, you can use Ctrl+p
for the previous command and Ctrl+n for the next one, or there are other alternatives, which we'll get to.

If nothing happens, you can try Ctrl+p and Ctrl+n as above.  We'll look at other options shortly.

After you press "q" to quit (as usual) try typing Up, Down, Left, and Right.

If they don't work, try Ctrl+p and Ctrl+n.  Ctrl+f moves forward one character.  Ctrl+b goes backward one character.  If a
single one works, you can hold down the Control key and type the letter multiple times.

If you get lost in your history and don't want to execute anything, you have a few options.  (1) You can go to the end of the
line, then hold down Backspace to wipe everything out.  (2) You can type Ctrl+c, your trusty get-me-out-of-here key combination.
(3) You can hold the Down key until you get out of your history (which may not always work, and in some cases, if you hold
it too long, you'll get a stream of noise from your terminal).  (4) You can go to the beginning of the line, type a pound
sign ( # ) and press Enter. 
EOL

	complete_exercise
}

yellow_belt_exercise_home_end_and_pound() { # The "Home" key, "End" key, and What "#" Does
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
We're going to look at two more keys before we look at other ways to run previous commands.  These are Home and End.
If you have a terminal with the right settings, pressing Home will take you to the beginning of your command line,
and End will take you to the end.

If not, Home will dump ^[[H into your command line and End will dump ^[[F into your command line.  In that case, use Ctrl+a
to go to the beginning of the command line ("a" is the first letter in the alphabet).  Use Ctrl+e to go to the end.

There are more key combinations to go to the beginning and end of words, to delete to the beginning and end of words,
and more.  We do not recommend memorizing them.

We recommend memorizing Ctrl+a and Ctrl+e, for two reasons:  speed and compatibility.  They are much faster than picking
up your hands, finding the Home or End key, pressing it, and returning your hands to the home row.  In some cases, you
may need to use a misconfigured or old terminal, and Home and End won't work.  Home and End don't usually work by
default on Macs either, so it's good to have options.

If you're used to moving quickly back and forth between the cursor keys and the home row, memorizing Ctrl+f and Ctrl+b
may not be of much use.  In the worst case, if you have no choice but to use a misconfigured terminal, you'll still be
able to enter commands, but you'll be slower.  It might never come up.  You might look them up if and when you need them.
If takes a long time for you to move your hands to the cursor keys and back, you might benefit from memorizing Ctrl+f and
Ctrl+b.

You could memorize Ctrl+p and Ctrl+n, but we'd rather you memorize Ctrl+r, which we'll get to shortly.  Ctrl+r will do what
Ctrl+p and Ctrl+n will do and more.

Pound signs ( # ) and everything after them are ignored (unless the pound sign is quoted or escaped).  Using a pound sign at
the beginning of a line is a good way to keep something in your recent command history if you aren't ready to execute it yet.
If you're familiar with Windows Batch files, putting a pound sign at the beginning of a command line is exactly like putting
REM at the beginning of a line of a batch file.  If you're familiar with a programming language, the pound sign starts a comment.
 
To keep something in your recent history without executing it, press Home (or Ctrl+a), then a pound sign, then Enter.
The pound sign is usually typed with Shift+3.

Try Home, End, Ctrl+a, and Ctrl+e now with everything you learned in the previous exercise.  Try the pound trick in the
previous paragraph with a command from your history, and immediately execute ". check".
EOL

	complete_exercise
}

yellow_belt_exercise_ctrl_r() { # Using Ctrl-r to Search for and Run Previous Commands
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
It's time to look at Ctrl+r.  This keystoke lets you search for a command that's in your history, make changes to it if
you want, and then save it for later or execute it.  If you execute it, it will also be added to your history.

To search for a command you've already run, type Ctrl+r.  Then type as many keystrokes as you need to to find what you're
looking for.  If you make a mistake, you can press Backspace.  You don't have to start at the beginning.  If you're looking
for the command line "cat Monday's\\ TPS\\ Report\\ for\\ Fred" in your history, you can type Ctrl+r and then type "Fred"
(without quotes).

Once you've found the command you want, you have multiple options.

EOL

	fmt ${FMT_OPTIONS:-} -c --width=$WIDTH <<EOL >> $fmt_file
  * You can run the command as is right now (which will also add it to your history as the last command run).  To do that,
    simply press enter.

  * You can add the command line as the last command line in your history (to make it easier to find) and without running
    it by making it a comment.  To do that, go to the beginning of the line, type the pound sign, and press Enter.
    When you find it later, if you want to run it, you'll need to remove the pound sign with the Delete key or the Backspace
    key.

  * You can make changes to it.  Type any keystroke that will let you move around (without going up or down) like Left, Right,
    Ctrl+a, Ctrl+e, Ctrl+f, or Ctrl+b.  After you do that you'll be out of search mode and you can change anything you like.
    To execute it, press Enter.  To save it for later, go the beginning of the line, type a pound sign, and press Enter.

  * You can change your mind.  Type Ctrl+c and the search will stop, whatever you found so far will be gone, and you'll
    get a fresh new prompt.  You can also get out of search mode with Ctrl+g, but Ctrl+c is easier to remember.
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

You can also type Ctrl+r again (and again).  Each time you type it, you'll see the previous command line that matches what
you typed.  You can search forward again with Ctrl+s, but if you start over, you only have to remember Ctrl+r.

Try all of these things with Ctrl+r now.  You can execute "learn" to see the current lesson as many times as you want.
EOL

	complete_exercise
}

yellow_belt_exercise_history_bang() { # "!"
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
There are a truly staggering number of ways to speed up typing things.  For example, you can refer to the third
argument of the fifth last command you typed.

EOL

	fmt ${FMT_OPTIONS:-}$WIDTH -s <<EOL >> $fmt_file
[user@host:~]$ echo 100 98 96
100 98 96
[user@host:~]$ echo 94 92 90
94 92 90
[user@host:~]$ echo 88 86 84
88 86 84
[user@host:~]$ echo 82 80 78
82 80 78
[user@host:~]$ echo 76 74 72
76 74 72
[user@host:~]$ echo !-5:3
echo 96
96
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

Your shell will print the full command (in this case, "echo 96") then execute it.

We would not expect very many people in the world to know how to do that.  The depth of what's available to speed up typing
is staggering, and you're likely to use only a fraction of it even if you become a Unix admin as a career.

What we've gone through so far will speed up pretty much any situation, although there's one last thing that comes up often
enough to make it into these exercises.  There's a way to refer to the last argument of the last command line that's quite
short, though it's hard to remember.  It can be helpful when you create a directory and then want to "cd" to it, especially
if the directory name is long or it's a full path (which is long).

EOL

	fmt ${FMT_OPTIONS:-}$WIDTH -s <<EOL >> $fmt_file
[user@host:~]$ mkdir dirname
[user@host:~]$ cd !$
cd dirname
[user@host:dirname]$
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

The exclamation point ( ! ) means you want to fill something in from your history.  The dollar sign ( $ ) means you want
the last argument filled in.  It can be tricky to remember, and you can always fall back on Ctrl+r, Ctrl+p, or Up and then
change "mkdir" to "cd".

If you want to check it first, use "echo !$".  Since the last argument is the same, you can still use "cd !$" after "echo !$".

Try out "!$" now.  If you create any directories under $LUS_HOME, please remove them before continuing.

When you're done, execute ". check" for your final exam.
EOL

	complete_exercise
}

# (End vim fold) }}}

# Green stripe exercises (Start vim fold) {{{
green_stripe_exercise_command_line_options() { # Short Options, Long Options, and Man(ual) Pages
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Before we get into the various ways you can list files, we'll have to go through short options and long options.
Short options are single characters.  Long options are full words, and sometimes multiple words.

We looked at "cp -R" earlier.  The single letter "R" is a short option.  It comes after a hyphen ( - ).  Sometimes, a
hyphen is used as a negative sign or as a dash.

cp -R source destination

Here's an example of a long option.  Long options start with two dashes.

cp --version

The "version" long option tells "cp" to print information about when it was made (and by who).

Who made it can give you some insight into how it can be used.  It's time for a (very short) history lesson.  (Don't
worry, it's not on the test.)

The Mac OS X operating system is based on NeXTSTEP, which is based on BSD, which is based on research at Bell Labs (which
is where Unix came from).

BSD also "gave birth" to FreeBSD, NetBSD, and OpenBSD, which are still popular.  They're also free.  NeXTSTEP has been
discontinued.

All of the operating systems above are "BSD or BSD-like".

Next, we'll list the commercial non-BSD Unixes (the ones you have to pay for).  All of these were based on the original
work on Unix at Bell Labs and are still around as of this writing:  Solaris, HP-UX, IBM AIX.  To use the Unix trademark,
a vendor (the company selling it) must pay a licensing fee and annual trademark royalties to a group of companies called
"The Open Group".  That means, in general terms, that a vendor is allowed to officially call their operating system Unix
as long as they pay (and continue to pay) The Open Group for the privilege.  Vendors (who don't pay) call their
operating systems "Unix-like", or don't say that it's Unix at all, officially.  For the sake of simplicity, when we
refer to Unix going forward, that will include "Unix-like" operating systems as well.

Last (but certainly not least) is Linux in all of its many shapes and sizes.  It runs phones (Android) and supercomputers
(all of the fastest 500 as of November 2017).  Linux cannot trace its ancestry back to the original Unix because that was the
whole point.  When it was written, Unix cost a lot of money.  All of the core tools ("cp", "mv", "ls", etc.) were provided
by GNU to make Linux a complete and fully--functioning operating system.

GNU, BSD, and the commerical Unixes do things differently.

The history lesson ends now.

If you're using a Mac (now, or you plan to fully immerse yourself in using the command line) this would be a good time to
take note that Macs are based on BSD and won't work the same way Linux does.  In particular, long options don't appear very
often in the core BSD tools.  If you don't want to use the command-line features of Macs, that's certainly an option as well.

No matter which platform you're using or will be using, programmers can still do short and long options however they want.
Some Linux programs don't have any short options and long options have one dash, not two (like Java).  Some programs
don't have any options at all and only take mandatory arguments (like most scripts).  Some programs only have long options
(like this script).  A lot of programs require you to put all the options first, but some let you put them anywhere.

As we mentioned quite a bit earlier, some programs allow you to give "--" as an argument.  Anything after that will be
treated as a filename and not an option, which lets you use filenames that start with a hyphen.  For programs that don't
support "--", you can't use them with filenames that start with a hyphen, or you need to use tricks like asterisk (unless
they don't support options at all, in which case it doesn't matter).

The tool that shows what programs are running is "ps".  Many versions of "ps" behave more like the BSD version when you don't
start with a hyphen and more like the GNU version when you do.  (Although, BSD did and does have hyphens on short options.
The full story is not really important here.)

Even though programmers can write programs to take arguments however they want, there is a lot of standarization.  You will
need to remember the programs you use on a regular basis that are different, or at least remember how to get the basic help
information.  GNU tools accept the "--help" long option.  Many other tools support "-h" for basic help.

If you have a BSD-like system, chances are, "ls --version" and "ls --help" are not going to work.

It's time to use your first resource.  You can access the manual page (or "man page") for the "ls" command by executing
"man ls".  Just like this script, "man" automatically uses the "less" program so you can see a page of information at a time.
The "ls" command supports a truly staggering number of options.  It's unlikely that anyone would know all of them.  For now,
get some experience using the "man" command.  The check script looks at your last few commands, so make sure you execute
"man ls" and ". check" without too many commands in between.
EOL

	complete_exercise
}

create_lists() {
	prepareLusHome
	
	if [ -f $LUS_HOME/list ]; then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
This exercise involves creating the directory $LUS_HOME/list, which already exists.  You will need to move it or rename
it by executing "mv $LUS_HOME/list newname", then executing "learn" again.
EOL

		less -R -P "$less_prompt_move_on" $fmt_file

		exit 2
	fi

	if [ ! -d "$LUS_HOME/list/ord" ]; then
		mkdir -p "$LUS_HOME/list/ord"
		touch "$LUS_HOME/list/ord/first"
		touch "$LUS_HOME/list/ord/second"
		touch "$LUS_HOME/list/ord/third"
	fi

	if [ ! -d "$LUS_HOME/list/count" ]; then
		mkdir -p "$LUS_HOME/list/count"
		# I'd like to make these relative to the time they're made, but it's hard to do that in a portable way.
		touch -t 202203010000 "$LUS_HOME/list/count/one"
		touch -t 202203020000 "$LUS_HOME/list/count/two"
		touch -t 202203030000 "$LUS_HOME/list/count/three"
	fi
}

green_stripe_exercise_ls() { # Getting Directory Lists Different Ways
	create_lists

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
List the files in $LUS_HOME/list/ord and $LUS_HOME/list/count.  There a ton of different ways to do that.  You can "cd"
to these directories a bunch of different ways, you could list the contents of these directories without "cd" by providing
each directory as an argument to "ls", either one at a time, or together on the same command line.  You could also try
using the copy and paste features of your terminal.  Explore different ways to list these files without using any options.
We'll look at options for "ls" in the next few exercises.
EOL

	complete_exercise
}

# TODO:  show ls -l with files at different dates in the past?

green_stripe_exercise_ls_dash_l() { # Introduction to "ls -l"
	create_lists

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Before we look at long directory listings, you'll need some idea of size.  If you've sent emails with attachments, you
may already have some sense of the size of information.  The size of attachments is usually shown, and you may have
seen an error that that your attachment was too large.

Outside of the United States, the basic unit of length is the metre, the basic unit of mass is the gram, and the basic
unit of time is the second.  Similarly, the basic unit of information is the byte.  A byte is made up of eight bits,
which can be 0 or 1.  One byte can hold a single character like "a", "1", or "$", or a number from 0 to 255.  A kilobyte
(1 KB) is 1024 bytes.  A page of text or a short email with no pictures or attachments can be stored in a kilobyte or
two.  (If you try it yourself, make sure to save the file in text format.)

Unix doesn't write to drives byte by byte, but instead groups bytes together into blocks.  You can think of a block like
a shipping container.  Most of the time, the block size is 4 KB (4,096 bytes).  Each one is a standard size, and they can
be placed in any order, which makes it easier to organize and move them.  A shipping container might have papers,
packing peanuts, a car, or priceless antiques.  It could be full or empty.  The same is true of a block, which might
contain a part of a larger text file, a small text file with empty space, or a tiny piece of a PhD thesis.  A block
might also contain nothing at all.  Read on for what empty files can be used for.

Only experimental and research file systems allow more than one file to be stored in a block.  If a file only has
100 bytes of data in it, it will take up one block.

We'll look at the "-l" option for "ls" now.  The "-l" option shows the long listing format.

Here's an example.

EOL

	echo '[user@host:~/example]$ ls -l' >> $fmt_file
	echo 'total 4' >> $fmt_file
	echo 'drwxrwxr-x 2 user ug 4096 Nov  8 08:40 zero' >> $fmt_file
	echo '-rw-rw-r-- 1 user ug    0 Jan  1  2021 one' >> $fmt_file
	echo '-rw-rw-r-- 1 user ug    0 Jan  2  2021 two' >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

The first thing that "ls -l" prints is a total, in this case, "total 4".  That means that the files and directories here
take up 4 blocks.  The size of a block can vary from filesystem to filesystem, but is rarely more than 4 KB (4,096
bytes), and very rarely less than 512 bytes (1/2 KB).  We will be looking at more helpful ways to display this "total"
later.

The next three lines tell us information about what's in this directory.

We'll begin at the end.  On the far right are the file and directory names:  "zero", "one", and "two".

We'll go through the rest of the fields from left to right.  The first part of the output shows the permissions
(drwxrwxr-x).  We'll be looking at what these mean and how to change them quite a bit later.  Right now, look at the
first character.  If it's a directory, the first character will be "d".  If it's a regular file, it will be a hyphen.
So "zero" is a directory, and "one" and "two" are not directories.

The next part is who owns the file.  In this example, the user ID is "user".

The part after that is what group owns the file.  In this case, that's "ug".

Fourth, we have the size of the file.  The files "one" and "two" have a size of 0, so they're empty files.  Empty files
can serve as flags to indicate something has been completed, and to provide a timestamp of when it completed.  The
"zero" directory is taking up 4,096 bytes of space.  Directories always take up at least one block (which may be larger
or smaller than 4,096 bytes).  If the number of files in a directory grows so large that the list of files can't fit
inside one block, then the size of the directory will grow.  A directory's size is based on the number of files and the
lengths of their filenames, and doesn't have to do with the size of the files.

Second last, we have the date (and maybe the time).  If a file is very recent, you'll see a date and time.  If it's older,
you'll see a month, day, and year.

For the sake of completion, the file (or directory) name is last.

The "ls -l" command line is typed so frequently that in many cases there's an "ll" alias.  You can see whether it's aliased
on your system with the command "type ll".

In the example below, ll is aliased to "ls -l" (plus two more options, "a", and "F").

EOL

	fmt ${FMT_OPTIONS:-} -s --width=$WIDTH <<EOL >> $fmt_file
[user@host:~]$ type ll
ll is aliased to \`ls -alF'
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

In the following example, ll is not aliased.

EOL
	fmt ${FMT_OPTIONS:-} -s --width=$WIDTH <<EOL >> $fmt_file
[user@host:~]$ type ll
bash: type: ll: not found

Check to see if you have the "ll" alias.  List the files in $LUS_HOME/list/ord and $LUS_HOME/list/count with the "-l" option.
EOL

	complete_exercise
}

green_stripe_exercise_ls_explore() { # Searching in a Man(ual) Page
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
It's time to use the man pages again.  This time, you'll be looking for something specific.

When you're using "less", you can look for something specific with slash ( / ).  Type a slash, type what you're looking
for, and press Enter.  You're using "less" right now, but everything is probably on one page in your terminal, so
searching for something is likely to be a bit boring.  (But nothing's stopping you.)

Use the question mark ( ? ) to go back.  Type the letter "h" for more ways to move around.

You know from the previous exercises that the files "one", "two", and "three" have different modification dates.  Open
the man page for "ls" by executing "man ls".  You may want to skim the man page for "ls" so you can appreciate the sheer
number of options.  While it's open, use slash to search through the options to find the right arguments that will list
the files in order.  Once you've found some options that will help, close the man page with "q" as usual and try them
out.  Once you have a listing of the files in $LUS_HOME/list/count in numerical order, execute ". check".

Only the short options will be considered correct, as they work with both BSD and GNU "ls".  Also, please put the options before
the directory name (if you use one).
EOL

	complete_exercise
}

green_stripe_exercise_ls_dash_h() { # Introducing "ls -h":  Human-Readable Numbers
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Try out "ls -lh" in or on different directories.  If you're on a BSD or GNU system, it will give you file listings in long
format with "human readable" file sizes.

If you're not, it's anyone's guess.  It may give you an error, do nothing, or do something else.  If you like, check the
man page before you try it.
EOL

	complete_exercise
}

green_stripe_exercise_ls_dash_f() { # Using "ls -f" on Directories with Numerous Files
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
The last option we'll be looking at for "ls" is the "-f" option.

If a runaway process has created tens of thousands of files in a directory, getting a listing can take a while.  Most of
the time is used to sort the files alphabetically (which is the default).  To help in finding all the files in
such a directory, you can add an option to print the files in whatever order they're listed in the directory, instead of in
alphabetical order.  You do that with the "-f" option.  We don't recommend memorizing it, but you should be aware that
it exists so you can check the man page when you need it.
EOL

	complete_exercise
}

green_stripe_exercise_df() { # Using "df" to Look at Drive Space
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
The next thing to cover is the "df" command.  But before we go into what it does, we'll have to go over mounts.

Some time ago, we showed how Windows has drive letters, but in Unix, everything is in one filesystem.  In order to bring
local drives, network shares, USB sticks, and everything that has files in it into one place, they are "mounted" onto the
base filesystem.  How that works isn't important for these lessons.  The important thing is that each "mount" has a bunch
of files and each one has a maximum size.

Just as a USB drive E: in Windows has a maximum size, and the hard drive C: has a maximum size, each mount in Unix can
get filled up.  That means that /var/log can be full of log files, but /home still has room.  That's a good thing.  It
means one problem won't bring down the whole system.

In many cases, mounts will have some space reserved that only root can use.  This space can be used for emergencies, and
also, having a nearly full mount can cause performance problems.  All you need to do to use this space is to switch to
the root user (we'll look at how to do that later).

The command to see how much space is being taken up for each mount is "df".  The "df" command usually defaults to either
512-byte or 1K blocks, which is not very readable for new users.  To see the sizes in "human" units, use the "-h" option.

Here are some examples of what you might see on different platforms.  First, Linux Mint.  Some parts are shown in red
to draw your eye to them.  This colour is not in the original.

EOL

	${GREP_BIN} --color=always "\(\/dev\/sda[1-9]\|\)" <<EOL >> $fmt_file
Filesystem      Size  Used Avail Use% Mounted on
udev            445M     0  445M   0% /dev
tmpfs            99M  1.2M   98M   2% /run
/dev/sda5        29G  8.0G   20G  30% /
tmpfs           491M     0  491M   0% /dev/shm
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
tmpfs           491M     0  491M   0% /sys/fs/cgroup
/dev/sda1       511M  4.0K  511M   1% /boot/efi
tmpfs            99M   36K   99M   1% /run/user/1000
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

The "/dev/sda1" and "/dev/sda5" devices are partitions on the first SCSI drive (SCSI drive A, partition 1).
Partitons allow you to break up a physical drive into smaller pieces for more flexibility, and to isolate issues if
one partition gets full.  You may also need different partitions for different things:  a boot drive, a place to store
regular files, and swap space.  These exercises don't get into swap space, so you'll need to take a look online if
you're interested.  If you see /dev/sda, it's basically guaranteed that you're dealing with some kind of Linux.  All the
mounts that don't start with /dev/sda aren't hard drives, stick drives, or SD cards, but rather something internal to
Linux.

In the cloud, you might not see a partition number.

Here's what you might see on a FreeBSD system:

EOL

	${GREP_BIN} --color=always "\(100.\|\)" <<EOL >> $fmt_file
Filesystem         Size    Used   Avail Capacity  Mounted on
/dev/gpt/rootfs    9.7G    5.5G    3.4G    62%    /
devfs              1.0K    1.0K      0B   100%    /dev
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

If you're not familiar with FreeBSD, you might think there's a problem here, as one of the mounts is 100% full.  However, it's
normal.  The "/dev" mount is a special, internal mount.  It isn't a drive.  You'll notice that there are only two
filesystems listed, which is common, but Linux has several.

The following output is from running "df -h" on a Mac.  Some of the original lines from the output have been removed for
clarity.

EOL

	if (($STTY_COLUMNS < 98)); then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Unfortunately, it won't all fit with your current terminal settings, so some or all of the lines are going to wrap.

EOL
	fi

	${GREP_BIN} --color=always "\(%iused\|iused\|ifree\|\)" <<EOL >> $fmt_file
Filesystem       Size   Used  Avail Capacity iused      ifree %iused  Mounted on
/dev/disk1s6s1  466Gi   22Gi  227Gi     9%  501138 2383102400    0%   /
devfs           199Ki  199Ki    0Bi   100%     690          0  100%   /dev
/dev/disk1s5    466Gi  2.0Gi  227Gi     1%       2 2383102400    0%   /System/Volumes/VM
/dev/disk1s3    466Gi  256Mi  227Gi     1%     814 2383102400    0%   /System/Volumes/Preboot
/dev/disk1s7    466Gi  100Mi  227Gi     1%     441 2383102400    0%   /System/Volumes/Update
/dev/disk1s1    466Gi  201Gi  227Gi    47% 1250938 2383102400    0%   /System/Volumes/Data
map auto_home     0Bi    0Bi    0Bi   100%       0          0  100%   /System/Volumes/Data/home
/dev/disk1s6    466Gi   22Gi  227Gi     9%  502049 2383102400    0%   /System/Volumes/Update/mnt1
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

The Mac shows three additional columns with "df -h", which list the number of inodes used, the number of inodes free,
and the percentage of inodes used.  Inodes (or index nodes) are used to keep track of where files are on a drive,
as well as permissions and many other attributes.  If we run out of inodes, we will not be able to store any more
files even if there's space for them (but it's rare).

Like before, there's a devfs filesystem that's full.  Likewise, it's not an issue.

You may have noticed that there are six filesystems that have the same capacity, inodes used, and inodes free.  We're seeing
a feature Macs have that allow multiple partitions to share the same space on the same physical drive.  Right now,
it's merely a curiosity.

In the output from the Mac, we see that most of the filesystems start with "/dev/disk" followed by a device number and
partition number.  These are real drives, as opposed to the "devfs" filesystem, which is internal.  We can also see that
most of the entries in the last column have full English words like "System" and "Volumes", which is a distinguishing
feature of Macs.

In summary, the FreeBSD volume that represented a real drive that could get full was /dev/gpt/rootfs.  For Linux, they
were /dev/sda1 and /dev/sda5.  For the Mac, they all started with /dev/disk1.  In general, the smaller the amount of
available space, the more likely the filesystem is something internal.  As you gain experience, you'll have a better
idea of which filesystems are usually internal.  It'll become easier to distinguish the internal filesystems from the
"real" ones.  Keep in mind that Linux systems tend to show internal filesystems as having space available, but FreeBSD
and Mac don't.

Execute "df -h".
EOL

	complete_exercise
}

green_stripe_exercise_dev_and_mount() { # The /dev Filesystem and Mounting
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
In this belt, we looked at several special devices across multiple platforms.

EOL

	echo "/dev/sda1" >> $fmt_file
	echo "/dev/sda5" >> $fmt_file
	echo >> $fmt_file
	echo "/dev/gpt/rootfs" >> $fmt_file
	echo >> $fmt_file
	echo "/dev/disk1s6s1" >> $fmt_file
	echo "/dev/disk1s1" >> $fmt_file
	echo "/dev/disk1s3" >> $fmt_file
	echo "/dev/disk1s5" >> $fmt_file
	echo "/dev/disk1s6" >> $fmt_file
	echo "/dev/disk1s7" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

These files don't exist on a drive, but are instead provided by the operating system.  If you were the root user and
wrote to these files with "echo", or another program, it would corrupt the contents of the corresponding drive.  If or
when you are the root user, it is of paramount importance that you work with these special files carefully.

When these special files are mounted, a new filesystem overlays the existing one, allowing you to work with the files on
that drive.  Modern Unixes automatically mount drives, including when removable media is inserted.  Mounts that need to
be present when the system is booted are put in /etc/fstab (FileSystem TABle).

Here is an example mount command.  It's for context.  We won't be mounting anything in this course.

mount -t ext4 /dev/sdb1 /mnt/sdb1

The -t or type parameter specifies the filesystem type.  For drives, that determines how data is stored on the drive.
Different operating systems use different filesystems.  The ext4 filesystem is the most popular on Unix.  It's possible to
mount something that isn't a drive, for example, a Windows or Unix file share.

In the beginning, only the root user could mount filesystems.  FUSE (Filesystem in USErspace) was invented to allow non-admin
users to mount filesystems, which allows for more flexibility.  Popular uses of FUSE include setting up encrypted mounts and
making remote filesystems (that can be accessed with SSH) look like local ones.  Not all systems have FUSE.

Execute ". check" for your final exam.
EOL

	complete_exercise
}

# (End vim fold) }}}

# Green belt exercises (Start vim fold) {{{
green_belt_exercise_ctrl_c() { # What Does Ctrl+c Actually Do?
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Welcome to the advanced ranks!  It's time to revisit Ctrl+c and explain what happens when you type it.  It's important that you
have a full understanding of what's going on.  The better your understanding, the better your choices will be when things
go wrong.  Depending on your background, some of the following may be review.

We're going to take a brief look at a few of the layers of a Unix operating system as we go, especially the kernel.
We're going to go deeper than that, though.  What is a computer?  What picture comes to your mind?  Depending on
your experience with computers, you might think of a laptop, or a desktop.  You might have seen pictures or a
short video clip of an aisle between rows of clear cabinets housing thousands of small, twinkling blue lights and
many thick wires.  You might not think of a modern phone or a smart watch, but these are also computers.  They also
likely run some kind of Unix.  A computer might be a server, in which case it probably doesn't have a monitor,
keyboard, or mouse, but receives requests from a network (perhaps for a webpage) and replies over the network.

When reduced to the essentials, a computer is a machine that follows instructions.  The part that carries out those
instructions is the CPU or Central Processing Unit.  The CPU is hardware, which means it's a physical component that
can't easily be changed.  To change it, you would need to buy a new one and have it installed, and that's assuming
everything else in the computer would work with the new one.  Software is easily changed.  You can upgrade or install
new software in minutes.  

A computer also has several places to put information, from the tiny but fast caches, to the large but slow drives.
RAM (Random Access Memory) is in the middle between the caches and the drives, often simply called "memory".
An operating system's kernel is usually described (and shown in diagrams) as running on top of the hardware.
It acts as a personal assistant to the hardware, drawing up a schedule of meetings (determining who gets how much
CPU time) and making sure the hardware isn't too heavily loaded.  The kernel decides who gets access to how much
memory and swap space.  Swap space is dedicated space on a drive used to improve efficiency.

There's one last thing to cover before we look at Ctrl+c again, and that's signals.  In Unix, a process can send a
signal to another process (which goes through the kernel).  The operating system can also send a signal to a process
(that didn't come from another process).  Signals are the easiest and simplest way one process can tell another that
something happened.  We'll be going into more detail about signals in red belt.  For now, a signal is a single number
between 1 and 33, and what each number means is well established.  (Mac has 31, Linux has 30, and FreeBSD has 33.)

These signal numbers also have names starting with "SIG", because humans remember words more easily than numbers.
Signal 2 (SIGINT) is sent to a program when the user types Ctrl+c (and in other cases).  Although signal handling
follows a general pattern, programs can do whatever they like with these signals, except for 9 (SIGKILL), which
kills the process.  Programs never actually receive SIGKILL:  the operating system handles it.  Only a program
running as the same user as the running program, the operating system, or root can send SIGKILL to a process.

At some point, perhaps soon, you're going to need to stop a process that's taking too long, or perhaps you realized that
you didn't actually want to run it.  If we were getting a file listing, and it was taking too long because there were
too many files, stopping it with Ctrl+c would be no problem.  (Though stopping a long file listing with Ctrl+c can take
some time.)  The worst case is having to stop something that's changing files on a filesystem.  We're going to look at
the copy command, cp.  All of the core utilities, including cp, don't give us any progress information.  System
administrators get a sense of how long things will take as they work with a system, and they'll learn patience.  There
are ways to see how a copy is proceeding, but looking at it will slow the copy down.

Let's say that we need to stop a copy.  We type Ctrl+c.  Our terminal interprets that keystroke and sends signal 2
(SIGINT, or interrupt) to the currently running process, which is "cp".  Chances are, cp is in the middle of copying
a block of data, because the drive access is what takes most of the time for the copy.  Programs don't write to
devices themselves.  If every program that needed to print something knew how to communicate with every printer, that
would be a mess.  So the kernel of the operating system takes care of the details (in this example, printer drivers,
but the example extends to all devices).  So the "cp" command asked the kernel to write some data, and it's waiting
for that to finish.  The "cp" command can't take messages at the moment.  Once the block of data is written, the
kernel notices that there's a pending signal for "cp", and sends it.  The "cp" command processes the signal and quits.

Now, we have a partially written file, possibly with many other files that finished already.  If we were only copying
one file, that wouldn't be too bad.  We could simply run the command again when it makes sense.  Perhaps we needed
to bring the system down for a kernel update.  If we were copying a large directory, it would be best to start at
the beginning, and have the "cp" command overwrite any files that it already copied.  The "rsync" command may be
of some use in completing an unfinished copy, but that's out of the scope of these exercises.

This exercise introduced a lot of material, so execute ". check" for a small quiz.
EOL

	complete_exercise
}

green_belt_exercise_ctrl_l() { # Ctrl+l
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
In the previous exercise, we looked at an example of when you don't want to type Ctrl+c.  Another handy keystroke to
keep a note of is Ctrl+l (lowercase L).  It tells your terminal to clear the screen, which can be helpful in a lot
of cases.  You should type Ctrl+l in all of the following cases.

EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL | sed '/^$/d'  >> $fmt_file
* You find yourself able to backspace over part of your prompt.

* You think you should see a prompt but you don't.

* You already typed Ctrl+q and you still can't see what you're typing.

* You see a prompt but your cursor isn't next to it.

* You typed some stuff but can't backspace over it.

* There's stuff you didn't type between your prompt and your cursor.

* You simply want to clear the screen.
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

Unlike Ctrl+c, Ctrl+l is safe.  Make a note of it and plan to memorize it.

Like Ctrl+c, Ctrl+l has no easy way to remember it.  Typing Ctrl+l produces a character with the ASCII code of 12, which
is equivalent to a form feed, which was originally a control code for printers.  A form feed would cause the printer to
go to the next page.  This idea of a "next page" was brought into a terminal window as meaning "clear the screen" from
the world of printer terminals, before terminals had screens.

Ctrl+c is even more esoteric.  Check it out on Wikipedia* if you care.  The reasons why Ctrl+c and Ctrl+l are what they
are don't connect with a modern audience.  It's harder to remember why they are what they are than to simply memorize
them.

* https://en.wikipedia.org/wiki/Control-C#In_command-line_environments

Try out typing part of a command and then type Ctrl+l.  Try Ctrl+l without typing a command first.  If you type nothing
at a command prompt and press Enter, you'll get another prompt.  That will help you fill up the screen so you can see
something happen when you clear it.  Remember:  if you have part of a command and you don't want to execute it and/or
you want to save it for later, type Ctrl+a, #, Enter.

This time, the check script doesn't check anything.  It's up to you how much you want to try out Ctrl+l.
EOL

	complete_exercise
}

green_belt_exercise_ls_a_alias() { # Is ls aliased?
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
We're going to use the term "hidden files" as a short form for "hidden files and hidden directories".
In many cases, directories are considered to be a special type of file.  For maximum clarity, tests and
quizzes will spell this phrase out fully as "hidden files and hidden directories".  We will also use
the full phrase in the lesson text in a few key spots for clarity.

Before we look at how to show hidden files, we need to check if your settings show hidden files by default.
That's normally done with an alias.

Let's take a look at some examples of what you might see when you execute "type ls" and what they mean, then
you'll do it.

EOL

	cat <<EOL >> $fmt_file
user@host [~]# type ls
ls is /bin/ls
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

The previous output shows that "ls" is not aliased, which means that no extra arguments are automatically added.
Since no arguments are added, the defaults are used, which means hidden files will be hidden unless you ask to
see them (with the "-a" option).

EOL

	cat <<EOL >> $fmt_file
user@host [~]# type ls
ls is aliased to \`ls -F'
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

The output above shows that the "ls" command has been aliased to "ls -F".  The "-F" option shows a symbol at the
end of each file indicating what kind of file it is.  The "-a" option isn't here, so the default for hidden files
will be used, which means files will be hidden unless you ask to see them (with the "-a" option).

EOL

	cat <<EOL >> $fmt_file
user@host [~]# type ls
ls is aliased to \`/bin/ls \$LS_OPTIONS'
user@host [~]# echo \$LS_OPTIONS
--color=tty -F -a -b -T 0
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

In this one, the options are coming from an environment variable, so we need to echo \$LS_OPTIONS to see
the options.  In tnis example, "-a" is included, which means that hidden files will be shown by default.

You may also see "-A", which means hidden files will be shown except for the special directories "." and "..".

Execute "type ls".
EOL

	complete_exercise
}

green_belt_exercise_hidden_files() { # Hidden files and globs
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
In this exercise, we'll show how to work with hidden files.  We'll also take a look at globs, and how using globs with
hidden files can be problematic.  These concepts are best covered together, so this exercise will be longer than most.

If a period ( . ) is at the beginning of a file or directory name, the file or directory will be hidden by
default.  The period is also called a dot, full stop, or full point.

We looked at the special directories "." and ".." in a previous belt.  As a quick review, the "." directory refers
to the current directory, and the ".." directory refers to the parent directory.  These special directories are
hidden by default (because they start with a dot).

Files and directories are hidden in two important ways.  First, the "ls" command won't show them by default.
We'll look at the second one in more detail now.

Let's imagine that you had a USB stick mounted on /mnt/usb and you wanted to copy some files in ${HOME}/abc
to the stick.

EOL

	cat <<EOL >> $fmt_file
[user@host ~]$ cp ${HOME}/abc/* /mnt/usb
[user@host ~]$ ls ${HOME}/abc/
one  three  two
[user@host ~]$ ls /mnt/usb
one  three  two
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

Looks like all three files were copied, doesn't it?  What about hidden files, shown with ls -a?

EOL

	cat <<EOL >> $fmt_file
[user@host ~]$ ls -a ${HOME}/abc/
.  ..  .hiddenOne  .hiddenTwo  one  three  two
[user@host ~]$ ls -a /mnt/usb
one  three  two
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

Oops.  The hidden files weren't copied.  If you forgot about hidden files when you copied the directory, you'd see
the same files in both places and think everything was fine, but one would have hidden files and the other wouldn't.

On your system there may be an alias that adds the -a option to ls automatically.  However, you should always
keep hidden files in mind as most systems don't automatically show hidden files.

If you look around a bit online, you might try to add hidden files to our copy command as follows.

cp ${HOME}/abc/* ~/.* /mnt/usb

Unfortunately, ".*" will also match the special directory "..".  It can be disastrous if you use ".*" with the "rm"
command (which deletes files and directories) so it's a good idea to avoid ".*" entirely.  As is usual for Unix, there
are lots of other options.  We'll look at one.

The easiest way around this issue is to copy the whole directory with the -R (recursive) option, which we looked
at before.  As a quick review, The -R option will copy all the directories and any directories they have until
they're all done.

The cp command copies one or more sources to a target (or destination).  Sources can be files or directories.
The target can be a file or directory.  If the target is a file, there must be one source, and it must be a file.
(You can't copy a directory to a file.)

Let's look at two very similar commands and what they do.

cp -R ${HOME}/abc/ /mnt/usb

EOL

	cat <<EOL >> $fmt_file
user@host [~]# cp -R ${HOME}/abc /mnt/usb
user@host [~]# cd /mnt/usb
user@host [usb]# ls
abc
user@host [usb]# cd abc
user@host [abc]# ls
one  three  two
user@host [abc]# ls -a
.  ..  .hiddenOne  .hiddenTwo  one  three  two
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

The command above copies all the files and directories in your ${HOME}/abc directory into /mnt/usb including
the "abc" directory.  (Hopefully you can read the output above and see that it shows that as well.)

cp -R ${HOME}/abc/. /mnt/usb

The command above is the same as the previous one, except for a slash and dot on the source.  When these are present,
the directory itself is not copied.  In other words, there will not be a /mnt/usb/abc directory, and everything
will be under /mnt/usb.  Let's see what that looks like.

EOL

	cat <<EOL >> $fmt_file
user@host [~]# cp -R ~/abc/. /mnt/usb/
user@host [~]# cd /mnt/usb
user@host [/mnt/usb]# ls
one  three  two
user@host [/mnt/usb]# ls -a
.  ..  .hiddenOne  .hiddenTwo  one  three  two
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

We looked at two sources:  "${HOME}/abc" and "${HOME}/abc/.".  You can also specify a source with a slash and no
dot (${HOME}/abc/) but that can be dangerous when dealing with symbolic links.  (Symbolic links are out of scope
for this course.)  Start forming the habit now to avoid slashes at the end of a source for "cp", "mv", and "rm".

Let's say we copied some files and included the directory by mistake.  Moving the non-hidden files and directories
up one directory level is easy.

mv * ..

Now we need to move all the hidden files up one level.  To do that, we need to be able to match only the hidden
files without matching the parent directory.  We can do that with a special glob.  You've probably used globs
like * and *.* before on Unix or Windows without knowing what they were called.  Globs are special sequences of
characters that match filenames.  The glob "abc*" matches all filenames that start with abc.  The Windows Command
Prompt only supports ? and * as special characters in globs.  The bash shell has a richer syntax for globs, some
of which you will probably never use.

The special glob .[^.]* (dot open-bracket caret dot close-bracket star) matches all files that start with a dot
that don't have a dot as the second character.  Make a note of it.

Continuing on what we had above, to move all files that start with a dot that don't have dot as the second
character one directory level up, use the following command.

mv .[^.]* ..

In the very unlikely event that you have to deal with several files that start with two dots, they won't be moved by
the previous command.  If there are only a few, you might want to rename them so that they start with only one dot,
then move them.  But the bash shell will let you match files that start with two dots without matching the parent
directory as well.  The following command moves all files that start with two dots and contain at least one more
character, one directory level up.

mv ..?* ..

For this one, rememeber that it's possible and look up the syntax for globs if you need to later.

Experiment with hidden files and listing them now.  Remember that you can create new files with the following command.

echo "Test text" > filename

You can create hidden files the same way.  As a quick review, create a dirname directory with "mkdir dirname".  Remove
an empty directory named dirname with "rmdir dirname".  The "rmdir" command only removes empty directories, so it's
safer than other ways to delete directories.  Use it when you can.  If you start the dirname with a dot, it will be
hidden.

If your "ls" is aliased and includes "-a", you may want to unalias "ls" by executing "unalias ls" so you can
experiment with "ls" and "ls -a".  The alias will return the next time you login.  On most systems, hidden files
are hidden by default.

When you login to a new Unix system, it's a good idea to check your aliases by executing "alias" (i.e. with no
arguments).  Another thing to watch out for is if "cp", "mv", and "rm" are aliased with with "-i" option, which will
ask you before overwriting files.  If you're used to being asked if you're sure on one system, you should be prepared
that on some systems you won't be asked.  Most commands have pairs of opposite options so you can set an alias (or
an environment variable in some cases) and then override it at the command line without needing to unalias the command.

When you're done experimenting with "ls -a" and hidden files and hidden directories, execute ". check" as usual.
EOL

	complete_exercise
}

green_belt_exercise_pushd() { # Introducing pushd
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
It's quite common to have to change the working directory with "cd", do something there, and then come back.
To make that easier, bash has the pushd and popd commands.  You can use the pushd command in place of cd.

Make sure you're not already in the root directory, then execute "pushd /".
EOL

	complete_exercise
}

green_belt_exercise_popd() { # Introducing popd
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
If you just did the previous exercise, execute "popd" to return to where you were.

If you didn't just execute "pushd /" because you came back to this exercise later, please execute "pushd /" and then
"popd".
EOL

	complete_exercise
}

green_belt_exercise_dir_stacks() { # Directory stacks
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Most of the time, you'll use "cd" to change directories.  Every once in a while, you might want to use "pushd" and
"popd".

This exercise is about what happens when you execute "pushd" multiple times before executing "popd".  You may never
want to do that, so this exercise is optional.  If you want to skip it at any point, press "q" and source the check
script as usual to move on to the final exam.


If You're a Programmer

The "pushd" and "popd" commands work with a directory stack.  If you're still getting into programming and haven't
gotten into stacks yet, look up stacks online or continue reading below.


If You're Not a Programmer

Dinner plates are a very common way to teach how stacks work.

Imagine a worker in a restaurant opening a dishwasher and taking out dinner plates.  We'll call him Tom.

Tom sets the first plate on the counter.  The next plate goes on top of the first one.  When Tom is done, the last
plate is on top.  The first plate he took out of the dishwasher is on the bottom.

Jane takes the stack of plates and puts them on a cart.  The other stacks of plates on the cart aren't important.
She rolls the cart out to the dining hall and leaves it next to the buffet.

The dining hall, the food, and the people there aren't important, except for the customers taking plates off
the stack.  Fred picks up the first plate, which is the last plate Tom put down.  One by one, plates are taken by
customers in the opposite order of the way they were set down.  Susan takes the last plate in our stack, which was
the first one Tom set down.  This stack of plates is now gone.

The "pushd" and "popd" commands work on a directory stack the same way Tom and the diners worked with the stack
of plates.  Each push adds a directory to the stack, and each pop removes a directory from the stack.  To see
the list, use the "dirs" command.  The directories will be listed with spaces between them.  To see it as a
stack, execute "dirs -p".
EOL

	complete_exercise
}
# }}}

blue_stripe_exercise_archive_files() { # Archive files
	prepareLusHome

	if [ -f "${LUS_HOME}"/blue-stripe ]; then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
This exercise uses the directory ${LUS_HOME}/blue-stripe, which already exists as a file.  You will need to move it or
rename it by executing "mv $LUS_HOME/blue-stripe newname", then executing "learn" again.
EOL

		complete_exercise
		exit 1
	fi

	mkdir -p "${LUS_HOME}/blue-stripe/to-archive/dir1"
	mkdir -p "${LUS_HOME}/blue-stripe/to-archive/dir2"

	echo "file1" > "${LUS_HOME}/blue-stripe/to-archive/file1"
	echo "file2" > "${LUS_HOME}/blue-stripe/to-archive/file2"
	echo "file3" > "${LUS_HOME}/blue-stripe/to-archive/file3"
	echo "file4" > "${LUS_HOME}/blue-stripe/to-archive/dir1/file4"
	echo "file5" > "${LUS_HOME}/blue-stripe/to-archive/dir1/file5"
	echo "file6" > "${LUS_HOME}/blue-stripe/to-archive/dir2/file6"

	set +e
	diff <( cd ~/lus/blue-stripe/to-archive && find . -print | sort ) <(cat <<EOL
.
./dir1
./dir1/file4
./dir1/file5
./dir2
./dir2/file6
./file1
./file2
./file3
EOL
)
	if [[ $? == "1" ]]; then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Unexpected files found in ${LUS_HOME}/blue-stripe/to-archive.  Please move or rename this directory with
mv "${LUS_HOME}/blue-stripe/to-archive" newname.
EOL

		complete_exercise
	fi
	set -e

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
An archive file is a file that contains the data from multiple files.  Archive files make it easier to move files
between computers and are easier to back up.  ZIP is the most common archive file type on Windows, with RAR files
arguably second.  On Unix, the most common archive file format is a tar.gz (or tgz) file, often called a tarball.

To make a tar.gz (or tgz) file, we need to use both the "tar" command and the "gzip" command.  The way they work
together is one simple example of the differences between Unix and Windows.  Tar creates one file out of multiple files.
Gzip compresses one file.  In Windows, these are done with a single program.  Unix has more programs that each have a
smaller set of responsibilities, leading to more flexibility.  Modern versions of Windows have changed the trend of
larger programs that do more with software like PowerShell.

Unlike cp and rm, which require the -R option, tar is recursive by default.  In fact, tar comes from a time before
options were standardized, so it works differently.  Most versions of tar support both the old and the new way of
specifying options, and there are some surprises.

The "rm" command, which can delete a whole filesystem, is obviously dangerous, and so you want to triple check any
command line with rm in it before you run it.  What's more dangerous is the gun you don't think is loaded.
Most versions of tar have an "interactive" mode (usually enabled with -w) that checks with you before doing
various things.  Even in interactive mode, tar will wipe the file that it determines is the destination file with
no warning.  The zip program is usually no different.

Shifting metaphors, you should consider the tar and zip commands the same as you would a very sharp kitchen knife.  One
or the other may be exactly the right tool for the job, but that doesn't mean they won't hurt you if you use them
incorrectly.

There are two main ways to recover files on Unix:  from backups, and from specialized recovery tools. (It's the same for
Windows, but the tools are different.  Windows also has the Recycle Bin, which is easier to use, but would not be
involved when a system program is making the changes at the user's request.)  Backups, assuming they were already set
up, can still be a pain to use.  With some, you need to extract the backup into (or over top of) a working system or
test system.  Specialized recovery tools don't require backups to work, but they require expert knowledge, they require
that you bring down the system (so users can't use it while you're trying to recover something) and they may not be able
to recover what you need if you weren't fast enough in kicking everyone off the system.

Let's look at some potential pitfalls, and then we'll provide a recommended way to avoid them.

Most versions of tar support the old way of doing arguments (without a dash) and the new way (with a dash).
The most common options are as follows.

EOL

	fmt ${FMT_OPTIONS:-}$WIDTH -s <<EOL >> $fmt_file
"-c":  create an archive file from a bunch of files
"-x":  extract an archive, recreating all the files in it
"-f":  specify the archive file name
"-v":  list every file added or extracted
"-z":  compress when creating the archive; decompress when extracting the archive

EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Arguments provided the old way and the new way don't do the same thing.  For example, the two commands:

EOL

	cat <<EOL >> $fmt_file
     tar cfz archive.tar.gz file
     tar -cfz archive.tar.gz file

EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
are quite different.  The first example uses "archive.tar.gz" as the value for option "f" and recognizes the option "z"
(so it will compress the data and store it in archive.tar.gz).

The second example uses "z" as the value for option "f": which means the data will be stored in a file called "z", and
it won't be compressed.  Next, tar will try to add "archive.tar.gz" to the "z" archive.  If "archive.tar.gz" doesn't
exist, then tar will fail with an error.

Another common mistake is to use the "f" option but put the destination file last (the same way most commands work).
Consider the following command line.

tar cvzf one two three archive.tar.gz

This situation is the worst one to be in.  We told tar to use the file called "one" as the archive file, because it's
after the "f" option.  Tar wipes out the data in the "one" file, adds "two" and "three" to a new archive called "one",
and crashes, as archive.tar.gz doesn't exist.

If no file is provided and the output isn't piped to another command (we'll look at pipes next belt) the archive
could be dumped to the terminal (which may force you to terminate your terminal).

That's enough fear mongering.  How do we safely use tar?

Start with your operation: "c" to create a new archive or "x" to extract an archive back into individual files.
If you want to see each file get added or extracted, add "v".  Keep in mind that verbose mode can significantly
increase the time it takes to create or extract large archives.  For the time being, always use "z", then "f".
There are four possibilities.  Make a note of what they are and what they do.  These will work with any version of tar.

EOL

	cat <<EOL >> $fmt_file
tar cvzf ...
tar czf ...
tar xvzf ...
tar xzf ...
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

Always put the archive file next.  If you're creating an archive, follow that with one or more directories.  Don't add
files (without a directory) to a tar archive:  that's called a tarbomb.  It can also lead to the first file getting
wiped if you're not careful.  Well constructed tar files are expected by the community to have one or more directories
(ideally one) so if an unsuspecting person untars your archive and finds a bunch of files mixed in, it's a pain to move
them all where they need to go.  (Especially if there are other files already in the directory.)  If you don't have a
directory where all the files are, make one.  If you have a lot of large files that you don't want to move or copy into
a directory to tar them, check tar's man page for options.

Your current directory matters.  Let's say you're in /home/user/ and you want to add /home/user/abc/def to an archive.
The "abc" directory will be added too, so when you unarchive the file, you'll get an "abc" directory with a "def"
directory inside.  If you only want the "def" directory:  cd to /home/user/abc/ first, or execute "man tar" to get a
list of options for your version of tar.

If all of these warnings seem to be a bit too much, you're not alone in thinking that (see the link below).

https://www.explainxkcd.com/wiki/index.php/1168:_tar

Modern versions of tar do have some checks to prevent the destruction of data.  For example, consider the following
command line.

tar cvzf archive.tar.gz

What we probably want to do with one archive file is extract it, but the "c" option was given instead of the "x" option.
Older tars would create a new archive called archive.tar.gz, destroying the data that was in the file.  Newer tars
give the error "Cowardly refusing to create an empty archive" or "no files or directories specified".  Do not depend
on tar giving you a warning.

You might be asking yourself, why hasn't anyone come up with a replacement?

In 1989, Mark H. Colburn published the first public implementation of a utility called "pax" (1).  Pax was intended to
provide a portable replacement to tar.  Portable means that it would run on a variety of operating systems the same way
with the same options.

(1) According to Wikipedia as of Sep. 9, 2022

As of the time of this writing, pax enjoys relatively little popularity or adoption.

Now, it's time for you to make a tar file.  Be patient and think it through.

We created some files and directories in "${LUS_HOME}/blue-stripe/to-archive".  Use tar to archive them into a file
called "${LUS_HOME}/blue-stripe/archive-one.tar.gz".  Compress the archive when you make it.  Don't mess up any of the
files and don't create a tarbomb.  The archive should contain one directory called "to-archive" that contains the rest
of the files and directories.

Don't be discouraged if this task takes you multiple attempts.  The check script will give you hints if you don't get
it right.
EOL

	complete_exercise
}

blue_stripe_exercise_archive_files_extract() { # Extracting archive files
	prepareLusHome

	if [ -f "${LUS_HOME}"/blue-stripe ]; then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
This exercise uses the directory ${LUS_HOME}/blue-stripe, which already exists as a file.  You will need to move it or
rename it by executing "mv $LUS_HOME/blue-stripe newname", then executing "learn" again.
EOL

		complete_exercise
		exit 1
	fi

	mkdir -p "${LUS_HOME}/blue-stripe/from-archive-tmp/from-archive/dir1"
	mkdir -p "${LUS_HOME}/blue-stripe/from-archive-tmp/from-archive/dir2"

	echo "file7" > "${LUS_HOME}/blue-stripe/from-archive-tmp/from-archive/file7"
	echo "file8" > "${LUS_HOME}/blue-stripe/from-archive-tmp/from-archive/file8"
	echo "file9" > "${LUS_HOME}/blue-stripe/from-archive-tmp/from-archive/file9"
	echo "file10" > "${LUS_HOME}/blue-stripe/from-archive-tmp/from-archive/dir1/file10"
	echo "file11" > "${LUS_HOME}/blue-stripe/from-archive-tmp/from-archive/dir1/file11"
	echo "file12" > "${LUS_HOME}/blue-stripe/from-archive-tmp/from-archive/dir2/file12"

	set +e
	diff <( cd ~/lus/blue-stripe/from-archive-tmp && find . -print | sort ) <(cat <<EOL
.
./from-archive
./from-archive/dir1
./from-archive/dir1/file10
./from-archive/dir1/file11
./from-archive/dir2
./from-archive/dir2/file12
./from-archive/file7
./from-archive/file8
./from-archive/file9
EOL
)
	if [[ $? == "1" ]]; then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Unexpected files found in ${LUS_HOME}/blue-stripe/from-archive-tmp.  Please move or rename this directory with
mv "${LUS_HOME}/blue-stripe/from-archive-tmp" newname.
EOL

		complete_exercise
		exit 2
	fi
	set -e

	( cd "${LUS_HOME}/blue-stripe/from-archive-tmp" && tar czf ../archive-two.tar.gz from-archive )
	rm -Rf "${LUS_HOME}/blue-stripe/from-archive-tmp"

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
We created an archive file called archive-two.tar.gz in ${LUS_HOME}/blue-stripe/.  Go to the directory where it is and
extract it right there.
EOL

	complete_exercise
}

blue_stripe_exercise_zip() { # Introduction to zip and unzip
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
The programs "zip" and "unzip" are easier to use than tar.  Because they're separate programs, you don't need the "x"
or "c" options.  Because they compress by default, you don't need a "z" option.  You do need to remember to put the
archive file first whether you're using zip or unzip, and you should only add directories to an archive (ideally
exactly one) for the same reasons you would with tar.

Because zip is a newer program, it works the same way as "cp" and "rm" in that you need to give it an option
to "recurse", which will add directories and everything in them.  Unlike those other programs, you need to give zip
the "-r" option instead of the "-R" option, which does something else.  Putting all of that together, here is the
command you need to zip a directory called directoryname (and everything in it).

zip -r archive.zip directoryname

If you forget the -r, zip will add an empty directory to the archive, and you will see the following.

EOL

	cat <<EOL >> $fmt_file
[user@host dir]$ zip archive.zip to-archive/
  adding: to-archive/ (stored 0%)
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

If you accidentally use -R instead of -r, you will see the following.


EOL

	cat <<EOL >> $fmt_file
[user@host dir$ zip -R archive.zip to-archive

zip error: Nothing to do! (archive.zip)
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file


Moving on, to unzip a zip archive into the current directory, use the following command.

unzip archive.zip

EOL

	set +e
	if which zip > /dev/null 2>&1; then
		set -e
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
The zip program is installed, so you'll be able to try out zip and unzip.  When you're done, source the "check" script
as usual to move on.
EOL
		if [[ "${INSIDE_DOCKER:-0}" == "1" ]]; then
			fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

You're using a Docker container, so only files and directories you put in $HOME/sandbox will be kept.  If you don't want
to keep your experiments around for the next time you run a Docker container, put them in a different directory under
$HOME.  Leave $HOME/lus for things the exercises ask you to do specifically.
EOL
		fi
	else
		set -e
#		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
#Unfortunately, zip isn't installed here, so you won't be able to try it out.  Make a note of how to use it and then
#source the "check" script as usual to move on.
#EOL
	fi

	complete_exercise
}

blue_stripe_exercise_vi() { # Introduction to vi
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
It's time to start talking about making changes to text files.

We included the following notes for general interest.

In the very beginning was a text editor called ed.  It was replaced by em, which was replaced by ex (short for
EXtended).

As usual, the history lesson is not on the test.

"Ed" and "em" are gone, but "ex" is still around as a helper program for other programs to use.  Ex works on a
set of lines at a time and only displays the lines you asked for, when you ask for them.  That may be difficult
to imagine if you grew up with editors that display as much of a file as would fit in the window or terminal
(all modern text editors do that).

In 1976, Bill Joy wrote a visual mode for ex.  It behaves like a modern text editor, showing as many lines of the
file as will fit in the terminal.  It's called "vi" for VIsual and pronounced "vee eye".  Later, this mode became
both the default and the command to run to start it.

Vi spawned a large number of clones and descendants.  Here's a partial list.

BBStevie | bedit | Bvi | calvin | e3 | elvis | elwin | javi | jvi | lemmy | levee | Neatvi | Neovim | nvi | OakHill vi | PC-Vile | PVIC | STvi (STevie) | trived | tvi | vigor | vile | VIM | vip | viper | virus | Watcom-VI | WinVi | xvi

Vi and its many descendants appeal to a small group of people.

EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL | sed '/^$/d'  >> $fmt_file
* People who grew up with it, who had nothing better
  
* People who like a challenge (Of course I summited Everest!)

* People who like to be challenged (What do you mean I can't ride a unicycle!?)

* People who don't like using a mouse because it's too slow

* People who make fewer than 3 mistakes in 100 typed characters

* People who can remember what they put in multiple clipboards and macros, and what multiple bookmarks are for

* People who believe that they only get a certain number of keystrokes before they die
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

It's more likely that these don't describe you.  Still, in some cases, vi might be all you have to work with.
There are things you can do to cut down on all the memorization if you don't plan on being an expert:  only use
one clipboard, one bookmark, and don't use macros.  Only memorize the basics:  how to move around, how to change
something, how to save, and how to close a file without saving (if you accidentally made a change you didn't want).

It's also good to know how to do these basic things in vi as programs may automatically open vi for you, expecting you
to do something.  Modern Unixes with helpful system administrators will provide an easier to use editor like "nano" on
Linux or "ee" on FreeBSD.

And now, the important bit:  what you really need to know (and what's on the test).

First, we'll teach you how to escape from vi.  It can be difficult to tell that you're in vi, espcially if you're
looking at a file that takes up the whole terminal.

Escaping from vi starts, rather naturally, with pressing the Escape key.  When you do that, you may not see anything.
If you don't see anything happen, that might be because it wasn't actually necessary, or because the version of vi
you're using is old.  Either way (or both ways) it does no harm to press it, and it may be necessary.  In fact, the
Escape key is the only safe key to press in vi.

Next, you need to type a colon ( : ).  Now you'll see something.  If you are, in fact, in vi and have pressed Escape
first, when you press Shift and semicolon to make a colon, you will see a colon at the bottom left of your screen.  The
cursor will jump next to it.  Then you need to type a lowercase q (for quit).  If you see an uppercase Q next to the
colon, press Backspace, check Caps Lock, and type a lowercase q.

Next, type an exclamation point ( ! ), which is Shift+1 on most keyboards.  Then press Enter.  You'll get back to
a prompt.

Let's review.  Pressing Escape gets you out of insert mode (if you're in it).  We'll look at insert mode in the next
lesson.  The colon starts an ex command.  (We talked about ex earlier in the lesson.)  The ex command "q!" means
to quit without saving.

That's how you escape from vi.  You should always have these notes handy.  In the next lesson, we'll look at making
changes and saving.

If you execute vi with no arguments, it will create an empty buffer for you to start writing.  Do that, then escape
from vi (leave vi without saving).
EOL

	complete_exercise
}

blue_stripe_exercise_moving_around_in_vi() { # Moving around in vi
	blue_stripe_lorem_ipsum	

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
The vi editor has three different "modes".  Modes in software are widely criticised by user experience experts.  In
particular, Larry Tesler at Apple had a vanity license plate that read "NOMODES".  You can read all about it online if
you like.

Newer descendents and clones of vi show "--- INSERT ---" in the bottom left of the terminal when you're in insert mode.
In older ones, you have to remember.  The Escape key takes you from insert mode to normal mode.

When you're in insert mode, what you type is put into a buffer.  It isn't added to a file until you save it (vi has
that in common with most software).  Vi will keep changes in a swap file, so if you're connected to a computer over
the internet and your internet connection drops, you may still be able to recover your unsaved changes.

In almost all cases, you will be able to use the arrow keys to get around.  You should make a note (and always keep it
with you) that h, j, k, and l are available if the arrow keys don't work (probably due to incorrect terminal settings).
These keys also work in less and other programs.

EOL

	cat <<EOL >> $fmt_file
h - one character left
j - one character down
k - one character up
l - one character right
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

These only work if Caps Lock is off.  They have completely different behaviour when capitalized.  (You don't need
to know the following.)

EOL

	cat <<EOL >> $fmt_file
H - top of buffer/terminal
J - join with next line
K - open man on word at cursor
L - bottom of buffer/terminal
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

Make a note:  if you suddenly start experiencing all sorts of strange things, you should press Escape and check that
Caps Lock is off.

You can go from normal mode to insert mode by pressing i (lowercase I).  By default, you can't go back before where you
started insert mode.  In other words, if you go into insert mode in the middle of a sentence and hold down Backspace,
you will only wipe out the characters you typed after starting insert mode.  It depends on your settings though.

In normal mode, you can use the arrow keys or "hjkl" to get you where you need to go, then use "x" to delete one
character and "i" to insert more text.

In normal mode, press colon to start an ex command.  We looked at "q!" before, which quits even if there are changes.
Use the ex command "wq" to write and quit vi.  That's the bare minimum of what you need to make and save changes.

ex commands:
EOL

	cat <<EOL >> $fmt_file
w  - write (save) the file and keep vi open
q  - quit, warn if there were changes
q! - quit without saving
wq - write (save) and quit
EOL

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

When you use "i", you might find that where you start typing is a bit awkward.  If that's the case, use "a" instead.
Use vi to open the file "${LUS_HOME}/blue-stripe/vi-intro.txt".   You will pass the check if you make any changes and
save the file, so make sure to try out both "i" and "a" to add text, returning to normal mode with Escape each time.
Also try out "x".
EOL

	complete_exercise
}

blue_stripe_exercise_searching_in_vi() { # Searching in vi
	blue_stripe_lorem_ipsum

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Now we'll do something a little bit more structured:  remove two specific words from a file.  To do that, we'll need
to search for them.

To search in vi, press slash ( / ).  On most keyboards, it's on the same key with question mark and next to the space
key.

Don't confuse it with backslash ( \ ), which is usually above the Enter or Return key.

After you type the slash (in normal mode) you type what you want to find.  Modern versions of vi will find the next
match from the cursor position as you type each character.  For now, avoid using punctuation in your search.  Special
characters (anything except letters, numbers, and spaces) need to be escaped, and it's not done the same way you escape
characters for your shell.

Open the same file as before in vi ("${LUS_HOME}/blue-stripe/vi-intro.txt").  This time, press slash in normal mode (vi
starts in normal mode).  Look for the words "in tempor", delete them by pressing "x" (in normal mode) until they're
gone.  Save the file and quit.
EOL

	complete_exercise
}

blue_stripe_exercise_wrap_up_of_vi() { # Wrap up of vi
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
You may be thinking of vi as a relic of the past, and it is.  But it can also be very powerful and fast.  In normal
mode, every lowercase letter does something and every uppercase letter does something.  If you don't like what they do,
you can change it.  You can provide a "motion" to most commands that can be complex, like "d2w" to delete two words
or "y2w" to "yank" (copy) two words.  Paste the text by pressing "p" (or "P" for before the cursor position).
Turn on even more speed by typing Ctrl+[ instead of Escape so you don't have to move your hands every time you leave
insert mode.

Set a bookmark with two keystrokes.  Go there with two keystrokes.  A single period lets you repeat what you just did
somewhere else at the place where your cursor is now.  Ex commands let you delete all lines matching (or not matching)
a pattern.  Do a complex search and replace in five more keystrokes than it takes to type in the search and replace parts.
If you master it, you will be pleasantly surprised to find it on pretty much any Unix-like OS.

It comes at a cost though.  If you mistype something, you may end up careening wildly through your file, making changes
you didn't intend to make.  Modern clones and descendants have an unlimited undo buffer, so if you recognize it quickly,
you can press Escape, check the Caps Lock key, and undo the changes by pressing "u" until you're done.  If you're
suddenly somewhere you didn't expect to be in your file, type two backticks to go back to where you were.

The backtick ( \` ) is usually on the same key as tilde ( ~ ), just above Tab.

If vi is something you'd like to master (now or later) open vi, type ":help" (without the quotes) and Enter.

Further exploration of vi is up to you, so the check script doesn't check anything this time.  When you're ready to move
on, source the check script.
EOL

	complete_exercise
}

blue_stripe_exercise_nano_and_ee() { # Nano and ee
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Nano and ee are popular editors for beginners.  Nano tends to be installed on Linux systems, and ee tends to be
installed on FreeBSD.  Both of them show help information prominently on the screen (which is different from vi).  Nano
expects you to know that ^X is a short form for Ctrl+x (and likewise, ^G is a short form for Ctrl+g).  In contrast, ee
displays some text explaining it.  When you run the command "nano" on a Mac, you may get Pico instead, which shows ^X as
what you need to type to exit, but actually it's a lowercase x that you need to use.  Depending on the version of nano
you have, you might be able to use both Ctrl+Shift+x (Ctrl+X) and Ctrl+x to exit.

EOL

	set +e
	if which nano > /dev/null 2>&1; then
		if which ee > /dev/null 2>&1; then
			fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Aren't you lucky!  Both nano and ee are installed here, so you can try both of them out.  If you run them with no
arguments, they'll open an empty document for you to start writing in.
EOL
		else
			fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Nano is installed here, so you can try it out.  If you run it with no arguments, it will open an empty document for you
to start writing in.
EOL
		fi
	else
		if which ee > /dev/null 2>&1; then
			fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
The ee (easy editor) program is installed here, so you can try it out.  If you run it with no arguments, it will open an
empty document for you to start writing in.
EOL
		else
			fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
Tough break.  Neither nano nor ee is installed here.
EOL
		fi
	fi
	set -e

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file

When you're ready for the final exam, source the check script as usual.
EOL
	complete_exercise
}

####################
# End of exercises #
####################

# Function definitions for the "welcome" begin here.  (Vim fold) {{{

ask_about_putty_font_size() {
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
Was that text comfortable to read?  It looks like you're connected with SSH, so chances are, you're using PuTTY.
If you're using PuTTY, would you like any help to increase the font size (y/N)?
EOL

	read CHOICE

	if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
Right click on PuTTY's title bar and select "Change Settings".  In the left navigation pane, select Window >
Appearance.  Click the "Change..." button about halfway down the right pane.  Select a new font size and
click "OK".  Click "Apply".  When you're happy with the settings, right click on PuTTYs title bar, go to
Session in the left navigation pane, select the session, and click "Save".
EOL

	size_matters

	echo ""

	fi
}

# insert dbfb406a-b3c4-4c8d-84f3-4f54bef5d50e make_temp

welcome() {
	make_temp
	file_clean_up_array+=($fmt_file)

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL > $fmt_file
When you see a prompt like "Press h for help; Enter for more", press Enter for one more line and Space for one more page.

If there's more text than will fit in your terminal, the Up and Down arrow keys should work in addition to Enter and Space
(but it depends on your terminal settings).  Press "h" for other alternatives.

If all the text fits in your terminal, you'll immediately see a prompt to press "q".  Pressing Enter, Space, or the arrow
keys will have no effect.

At the bottom of the text (or immediately if all the text fits) the prompt will change, asking you to press "q" to move on
(or quit if it's the end of the lesson).  Once you're done reading all the text (including right now) press "q".
EOL

	# When using these scripts through SSH, not clearing the terminal first can make it seem like a bunch of text went by and
	# was lost.  The student can feel like they accidentally pressed q twice and missed something.  Clearing the terminal
	# before each invocation of less for the welcome text helps to prevent that.
	clear
	less -R -P "$less_prompt_move_on" $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL > $fmt_file
The following notes are an overview of what will be covered in this course.
It's likely that you will only understand them if you already have some
experience with them.  Consider them like chapter headings in a textbook you recently received.
EOL

	printf "\n${underline}Beginner and Advanced Ranks${no_underline}\n" >> $fmt_file

	printf "\n`getBeltWithColours white_belt title`\n" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  In a martial arts club (or dojo) a student gets their white belt when they buy a uniform and sign up for classes.  In this
  case, a student gets their white belt when they run the learn script and choose to get started.
EOL

	echo "" >> $fmt_file

	printf "`getBeltWithColours yellow_stripe title`\n" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Understanding \$PATH and environment variables.
EOL

	printf "\n`getBeltWithColours yellow_belt title`\n" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Creating and deleting directories; . and ..; pwd; cd; file types and magic
EOL

	echo "" >> $fmt_file
	printf "`getBeltWithColours green_stripe title`\n" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Intermediate arguments to ls; mounts and drive space
EOL

	printf "\n\n${underline}Advanced Ranks${no_underline}\n" >> $fmt_file

	printf "\n`getBeltWithColours green_belt title`\n" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Ctrl+c redux; hidden files and directories; globbing; directory stacks
EOL

	printf "\n`getBeltWithColours blue_stripe title`\n" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  ZIP and tar archives; editing with vi
EOL

	printf "\n`getBeltWithColours blue_belt title`\n" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Pipes; tee; redirection; head, tail, sort, grep
EOL

	printf "\n`getBeltWithColours red_stripe title`\n" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Finding large files and dirs with du, sort, and head; mv; rm -Rf; diff
EOL

	printf "\n`getBeltWithColours red_belt title`\n" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Signals; stopping processes; ps; pgrep vs grep
EOL

	printf "\n`getBeltWithColours black_stripe title`\n" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  Foreground and background tasks, jobs and &
EOL

	printf "\n`getBeltWithColours black_belt title`\n" >> $fmt_file

	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
  User and group ownership; permissions; ls -ld; stat; namei
EOL

	echo "" >> $fmt_file

	# When using these scripts through SSH, not clearing the terminal first can make it seem like a bunch of text went by and
	# was lost.  The student can feel like they accidentally pressed q twice and missed something.  Clearing the terminal
	# before each invocation of less helps to prevent that.
	clear
	less -R -P "$less_prompt_move_on" $fmt_file

	if [ ! -f "${LUS_PROGRESS}" ] || [ -z "${RANK:-}" ] || [ -z "${EXERCISE:-}" ]; then
		if [ -n "${SSH_CONNECTION:-}" ] || [ -n "${SSH_TTY:-}" ]; then
			ask_about_putty_font_size
		fi

		size_matters

		lus_dir=$(dirname "${LUS_PROGRESS}")
		if [ ! -w "${lus_dir}" ]; then
			if [[ "${INSIDE_DOCKER:-0}" == "0" ]]; then
				echo "Unable to save progress.  Please ask your sysadmin to make sure the"
				echo "directory ${lus_dir} is writable."
			else
				echo "The directory ${lus_dir} is not writable."
				echo 'Unable to save progress.  Please exit the docker container (with "exit")'
				echo "and run the following commands."
				echo
				echo "# Setup commands:  run them once"
				echo "docker volume create lus"
				echo "docker run --mount src=lus,target=/mnt/vol -u 0 alpine /bin/ash -c 'mkdir -p /mnt/vol/testuser;chgrp 1000 /mnt/vol/testuser;chmod g+w /mnt/vol/testuser'"
				echo
				echo "# Work with traditional white text on black terminal settings"
				echo "docker run -it --rm --mount src=lus,target=/mnt/vol cevans42ca/learn-unix-scripts"
				echo
				echo "# Work with black text on white"
				echo "docker run -it --rm --mount src=lus,target=/mnt/vol --env DARK_MODE=0 docker run -it --rm cevans42ca/learn-unix-scripts"
				exit 1
			fi
		fi

		if [[ "${INSIDE_DOCKER:-0}" == "1" ]]; then
			fmt ${FMT_OPTIONS:-}$WIDTH <<EOL > $fmt_file
Welcome to the Docker version of the Learn Unix Scripts.  There's one thing you should keep in mind that applies
specifically to this version.  It's common for Docker containers to be deleted once they complete their work.  Of
course, you'll want to keep your progress, so that will be kept.  Two other things will also be kept:  a "sandbox"
directory for you to try things out, and a "lus" directory which will be used for some of the exercises.  These are in
your home directory (if you don't know what that is, we'll cover it soon).  Only add, modify, or delete files and
directories under "lus" when asked to do so by an exercise.  Anything not in the lus or sandbox directories may be
deleted, depending on how you've started the Docker container.

EOL

			less -R -P "$less_prompt_move_on" $fmt_file
		fi

		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
If you type "y" and press Enter, then you will be given your first task.
EOL

		echo -n "Are you ready to begin (y/n)? "
		read CHOICE

		if [ "$CHOICE" == "" ]; then
			fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
Implict consent is not enough this time.  To begin, you must choose.
EOL

			echo -n "Are you ready to get started (y/n)? "
			read CHOICE
		fi

		if [[ "$CHOICE" =~ ^\s*[Yy].* ]]; then
			clear
			RANK="white_belt"
			EXERCISE="1"
			updateDotFile

			print_rank > $fmt_file

			set_num_exercises

			echo "Exercise 1/${NUM_EXERCISES}" >> $fmt_file
			echo "" >> $fmt_file

			exercise_name=${exercises["${RANK}_1"]}
			function_name="${RANK}_exercise_${exercise_name}"
			eval $function_name
		fi
	fi
}

###############################
# End of function definitions #
###############################
# }}}

# Script execution will begin here.  (Vim fold) {{{

if [ -f "${LUS_PROGRESS}" ]; then
	source "${LUS_PROGRESS}"
fi

LUS_HOME=${LUS_HOME:-"$HOME/lus"}

if [[ "${INSIDE_DOCKER:-0}" == "1" ]]; then
	if [ ! -d "$LUS_DOCKER_BASE/sandbox" ]; then
		mkdir -p "${LUS_DOCKER_BASE}"/sandbox
	fi
fi


if [ ! -f "${LUS_PROGRESS}" ] || [ -z "${RANK:-}" ] || [ -z "${EXERCISE:-}" ]; then
	if (($STTY_ROWS < 24)) || (($STTY_COLUMNS < 80)); then
		# We haven't introduced what Y/n means, but if the user has made a conscious choice to make their terminal
		# smaller, they probably already know.
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
A minimum of 80 columns and 24 rows is strongly recommended.  Would you like to automatically update the terminal size to
the recommended minimum and continue (Y/n)?
EOL

		read CHOICE

		if [[ "$CHOICE" =~ ^\s*[yY] ]] || [ -z "$CHOICE" ]; then
			resize_to_default
			RESIZED_ALREADY=1
			clear
		fi
	fi

	welcome
	exit 0
fi

if [ "${1:-}" == "--welcome" ]; then
	welcome

	if [ -z "${RANK:-}" ]; then
		print_rank
	fi

	exit 0
fi

if [ "${1:-}" == "--return" ]; then
	if [ -z "${SAVED_RANK:-}" ] || [ -z "${SAVED_EXERCISE:-}" ]; then
		echo "There is no saved progress to return to."
		exit 3
	else
		RANK=$SAVED_RANK
		EXERCISE=$SAVED_EXERCISE
		SAVED_RANK=""
		SAVED_EXERCISE=""
		updateDotFile
	fi
fi

if [[ ! "${RANK}" =~ ^(white|yellow|green|blue|red|black)_(stripe|belt)$ ]]; then
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
It looks like the "${LUS_PROGRESS}" file has become corrupted.  If it can't be repaired, you may have no choice but to delete it
and start over.  Sorry about that.
EOL
	exit 2
fi

if [[ ! "${EXERCISE}" =~ ^[0-9]+$ ]]; then
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
It looks like the "${LUS_PROGRESS}" file has become corrupted.  If it can't be repaired, you may have no choice but to delete it
and start over.  Sorry about that.
EOL
	exit 2
fi

all_args="$*"
all_args=${all_args,,}
if [[ "${all_args}" =~ (white|yellow|green|blue|red|black).*(stripe|belt)[^0-9]*([0-9]*) ]]; then
	# The $LUS_PROGRESS file must exist.  If it didn't, we would be running welcome().

	new_rank="${BASH_REMATCH[1]}_${BASH_REMATCH[2]}"

	# No underscore.
	new_rank_for_echo="${BASH_REMATCH[1]} ${BASH_REMATCH[2]}"

	new_exercise="${BASH_REMATCH[3]}"

	if [[ "${all_args}" =~ list ]]; then
		regex="'"
		regex+="${new_rank}_exercise_.*\(\)"
		regex+="'"

		# Advanced sed:  if an exercise exists, skip to the :x label.  If not, replace the line with "No Title".
		# Use cat -n to add a line number (which is the exercise number).
		# Exercises must be in order in this file for it to work.
		bash -c "grep -E ${regex} ~/bin/learn | sed -e 's/.* #[:space:]*//;tx' -e 's/.*/No Title/' -e ':x' -e 's/^[ \t]*//' | cat -n"
		exit 0
	fi

	if [ "${new_exercise}" == "" ]; then
		new_exercise=1
	fi

	if [ "${new_exercise}" == "0" ]; then
		echo "The first exercise of each rank is exercise 1."
		exit 3
	fi

	if [[ "${new_exercise}" =~ 0[0-9]+ ]]; then
		echo "Please don't add leading zeros to the exercise number."
		exit 3
	fi

	new_belt_number=${belt_to_number[$new_rank]}

	if [ -n "${SAVED_RANK:-}" ]; then
		current_belt_number=${belt_to_number[$SAVED_RANK]}
	else
		current_belt_number=${belt_to_number[$RANK]}
	fi

	if [ -n "${SAVED_EXERCISE:-}" ]; then
		current_exercise=${SAVED_EXERCISE}
	else
		current_exercise=$EXERCISE
	fi

	if (($new_belt_number > $current_belt_number)); then
		fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
This feature is for reviewing previous exercises, not for skipping ahead.
EOL
		exit 3
	fi

	if (($new_belt_number == $current_belt_number)); then
		if ((${new_exercise} > $current_exercise)); then
			fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
This feature is for reviewing previous exercises, not for skipping ahead.
EOL
			exit 3
		elif ((${new_exercise} == $current_exercise)); then
			fmt ${FMT_OPTIONS:-}$WIDTH <<EOL
You're already working on that exercise.
EOL
			exit 3
		fi
	fi

	set_num_exercises_for_review

	if [ "$NUM_REVIEW_EXERCISES" == "0" ]; then
		echo "There aren't any exercises for ${new_rank_for_echo} yet."
		exit 3
	fi

	if (( $new_exercise > $NUM_REVIEW_EXERCISES )); then
		echo "There are only $NUM_REVIEW_EXERCISES exercises in ${new_rank_for_echo}."
		exit 3
	fi

	# Only set saved rank and saved exercise if they're currently unset, otherwise students could use this feature to
	# skip ahead.
	if [ -z "${SAVED_RANK:-}" ]; then
		SAVED_RANK=$RANK
	fi

	if [ -z "${SAVED_EXERCISE:-}" ]; then
		SAVED_EXERCISE=$EXERCISE
	fi

	RANK=$new_rank
	EXERCISE=$new_exercise

	updateDotFile

	# Fall out of the if and continue with the requested lesson.
elif [ -n "${1:-}" ] && [ "${1:-}" != "--return" ]; then
	# There was an argument passed but we couldn't figure out what the user wanted.
	echo "Usage:"
	echo ""
	echo "learn --welcome"
	echo "  To see which skills fall under which belts"
	echo "learn white belt"
	echo "  To review the white belt exercises"
	echo "learn yellow stripe"
	echo "  To review the yellow stripe exercises from the beginning"
	echo "learn white belt list"
	echo "  To see a list of white belt exercises"
	echo "learn white belt 6"
	echo "  To start reviewing at a particular exercise"
	echo "learn --return"
	echo "  If you're reviewing exercises, return to where you were."

	exit 1
fi

if [ -z "${fmt_file:-}" ]; then
	make_temp
	file_clean_up_array+=($fmt_file)
fi

print_rank > $fmt_file

if [ -z ${exercises["${RANK}_${EXERCISE}"]:-} ]; then
	fmt ${FMT_OPTIONS:-}$WIDTH <<EOL >> $fmt_file
There are no more exercises at this time.  If you like, you can review exercises you've already completed by executing
"learn white belt" or "learn yellow stripe".  Get a list of exercises with "learn yellow stripe list", and go to a specific
exercise with "learn white belt 6".
EOL

	complete_exercise

	exit 1
fi

set_num_exercises

echo "Exercise ${EXERCISE}/${NUM_EXERCISES}" >> $fmt_file
echo "" >> $fmt_file

exercise_name=${exercises["${RANK}_${EXERCISE}"]}
function_name="${RANK}_exercise_${exercise_name}"
eval $function_name

# }}}
# vim: set foldmethod=marker:
