#!/bin/bash -i

# This script was developed in a 130x30 terminal.

# The "learn-unix-scripts" project is free software: you can redistribute it and/or modify it under the terms of the GNU
# General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# The "learn-unix-scripts" project is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with this project; if not, write to the
# Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA, 02111-1307, USA.
#
# Copyright (C) 2021 Christopher Evans

# replace start b2074508-dd08-48be-bc6c-346c26349e4e (see below for what this line does)

# This script is the master script for the checkmain script.  If you have site-specific changes that you don't want to share,
# you can add a GUID in this script and use the "replace" script to merge this script with your site-specific changes
# (in checkmain-replace) and create a site-specific learn script.  You can insert or replace portions of this code.

# If we didn't replace this text when we created the "checkmain" script, it would seem as though people should be making
# the changes to the "checkmain" script and not this one.  See the replacement for 1acc396a-02a2-40b8-a427-f4685c20320e in
# checkmain-replace for more.

# Insert exercises or elements that are specific to your site with "# insert <GUID>".  If you put a space after the GUID,
# you can add comments.  Replace parts with "# replace start <GUID>" and "# replace end <GUID>".  To remove sections,
# replace the content with nothing.  Put the replacements in the learn-replace file.
#
# replace end b2074508-dd08-48be-bc6c-346c26349e4e

# insert 4c02f3dc-1640-11ed-baa4-1511ebd0a2d1 check tput

# In case this script needs to be moved back to being sourced, use a prefix on the environment variables to avoid messing
# up other programs (Learn Unix Check or luc_).

set -e -o nounset

# DARK_MODE Replacement Tag:  if not running in Docker, replace this line with DARK_MODE=0 for black text on white

# insert bef71a69-5f8d-43d4-af29-60608e9b56c7 temp file clean up and debug

# insert 17fa07e6-24b8-4e35-bc1a-094427fd8699

if [ "$(whoami)" == "root" ]; then
	echo "Run this script as yourself, not the root user."
	exit 1
fi

if [ -z "${1:-}" ]; then
	echo "This script is not meant to be run directly."
	echo "Please execute '. check' to invoke the wrapper script."
fi

luc_history=()
while read i; do
	luc_history+=("$i")
done < "${1}"

LUS_HOME=${LUS_HOME:-"$HOME/lus"}

# insert ffa9e74e-2b02-4d72-9c82-9f9db2915c62 associative arrays for exercises and belt levels

FMT_OPTIONS="-u --width="
BSD_DATE=0
do_shuffle=1

luc_good_work_array[0]="Good work!"
luc_good_work_array[1]="Excellent!"
luc_good_work_array[2]="Well done!"
luc_good_work_array[3]="Brilliant!"
luc_good_work_array[4]="Terrific!"

luc_continue_array[0]="Keep going!"
luc_continue_array[1]="Keep at it!"
luc_continue_array[2]="Keep it up!"

luc_sorry_array[0]="Better luck next time."
luc_sorry_array[1]="Unfortunately, no."
luc_sorry_array[2]="Sorry, that's not it."
luc_sorry_array[3]="That's not it.  Try again."

good_work() {
	size=${#luc_good_work_array[@]}
	index=$(($RANDOM % $size))
	echo ${luc_good_work_array[$index]}

	EXERCISE=`expr $EXERCISE + 1`
}

keep_going() {
	size=${#luc_continue_array[@]}
	index=$(($RANDOM % $size))
	echo ${luc_continue_array[$index]}

	if [ "${1:-}" == "" ]; then
		EXERCISE=$(expr $EXERCISE + 1)
	else
		EXERCISE=$(expr $EXERCISE + ${1})
	fi
}

sorry() {
	size=${#luc_sorry_array[@]}
	index=$(($RANDOM % $size))
	echo ${luc_sorry_array[$index]}
	echo "Run the learn script again if you need to."
}

process_choice() {
	luc_processed_choice=0

	if [[ -z "${luc_choice:-}" ]]; then
		return
	fi

	# That's right, Roman numerals!  Inspired by Starship Titanic.

	# Use the ${ ,,} syntax to lowercase.
	if [[ "${luc_choice,,}" =~ ^[\ ]*(one|1|i)[\ ]*$ ]]; then
		luc_processed_choice=1
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(two|2|ii)[\ ]*$ ]]; then
		luc_processed_choice=2
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(three|3|iii)[\ ]*$ ]]; then
		luc_processed_choice=3
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(four|4|iiii|iv)[\ ]*$ ]]; then
		luc_processed_choice=4
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(five|5|v)[\ ]*$ ]]; then
		luc_processed_choice=5
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(six|6|vi)[\ ]*$ ]]; then
		luc_processed_choice=6
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(seven|7|vii)[\ ]*$ ]]; then
		luc_processed_choice=7
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(eight|8|viii)[\ ]*$ ]]; then
		luc_processed_choice=8
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(nine|9|ix)[\ ]*$ ]]; then
		luc_processed_choice=9
	fi

	if [[ "${luc_choice,,}" =~ ^[\ ]*(ten|10|x)[\ ]*$ ]]; then
		luc_processed_choice=10
	fi
}

# insert 37333148-8746-4468-826e-544e532f1ebc updateDotFile, getBeltWithColours

# Yes, it's overkill.  But I can't pass up tested, working code.
# From http://mywiki.wooledge.org/BashFAQ/026
# in the section Shuffling an array.
shuffle() {
   local i tmp size max rand

   # $RANDOM % (i+1) is biased because of the limited range of $RANDOM
   # Compensate by using a range which is a multiple of the array size.
   luc_shuffled_answers=( "${luc_answers[@]}" )
   size=${#luc_shuffled_answers[*]}
   max=$(( 32768 / size * size ))

   for ((i=size-1; i>0; i--)); do
      while (( (rand=$RANDOM) >= max )); do :; done
      rand=$(( rand % (i+1) ))
      tmp=${luc_shuffled_answers[i]} luc_shuffled_answers[i]=${luc_shuffled_answers[rand]} luc_shuffled_answers[rand]=$tmp
   done
}


handle_answer() {
	if [ -n "${do_shuffle:-}" ]; then
		shuffle
	else
	   luc_shuffled_answers=( "${luc_answers[@]}" )
	fi

	luc_num=1
	for item in "${luc_shuffled_answers[@]}"
	do
		fmt ${FMT_OPTIONS:-}$luc_width <<EOL
(${luc_num}) $item
EOL
		if [[ "$item" == "${1}" ]]; then
			luc_correct_answer=$luc_num
		fi
		luc_num=$((luc_num+1))
	done

	echo ""

	while true
	do
		# Stdin has been redirected to pull in the command history, so we need an extra step to read from the terminal.
		# There must be no space between < and /.
		read -p "Your answer (1-${#luc_answers[@]})?  " luc_choice </dev/tty

		process_choice

		echo ""

		if [[ "$luc_processed_choice" == "$luc_correct_answer" ]]; then
			luc_correct_answers=$((luc_correct_answers+1))
			break
		elif [[ "$luc_processed_choice" == "0" ]]; then
			echo "Your answer should be a number from 1 to ${#luc_answers[@]}."
		elif [[ "$luc_processed_choice" > "${#luc_answers[@]}" ]]; then
			echo "Your answer should be a number from 1 to ${#luc_answers[@]}."
		else
			break
		fi
	done
}

ask_review_final_exam() {
	if [ -n "${SAVED_RANK:-}" ] && [ -n "${SAVED_EXERCISE:-}" ]; then
		echo "Right now, you're reviewing exercises you've already completed."
		echo "The final exam for `getBeltWithColours ${RANK:-}` is next."
		echo
		echo "What would you like to do?"
		echo "(1) Attempt the exam again"
		echo "(2) Skip it"
		echo "(3) Quit"
		read -p "Please choose (1-3)?  " luc_choice </dev/tty
		process_choice

		if [[ "$luc_processed_choice" == "1" ]]; then
			return 1
		elif [[ "$luc_processed_choice" == "2" ]]; then
			return 0
		else
			exit 0
		fi
	else
		return 1
	fi
}

white_belt_exercise_what_execute_means() {
	# For this exercise, we're only confirming this script was run, so there's nothing to check.
	good_work
	echo ""
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
For each exercise, you'll run the learn and check scripts.  Execute "learn" for your next task or to pick up where you left off.
EOL
}

white_belt_exercise_stuck() {
	# For this exercise, we're only confirming this script was run, so there's nothing to check.
	good_work
	echo ""
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Execute "learn" for your next task or to pick up where you left off.
EOL
}

white_belt_exercise_cd_root() {
	if [[ `pwd` == "/" ]]; then
		good_work
		echo ""
		echo $'Execute "learn" when you\'re ready for the next exercise.'
	else
		sorry
	fi
}

white_belt_exercise_ls_root() {
	# Chances are, "ls" is going to be in the history, so cheaters will get a pass on this one.
	# We could generate history with a smaller size for this exercise, but it doesn't seem worthwhile.
	# The list command is so basic that I'm not really concerned that something will be missed here.

	good_work
	echo ""
	echo $'Execute "learn" when you\'re ready for the next exercise.'
}

white_belt_exercise_common_root_directories() {
	if [[ `pwd` == "$HOME" ]]; then
		good_work
		echo ""
		echo $'Execute "learn" when you\'re ready for the next exercise.'
	else
		sorry
	fi
}

white_belt_exercise_set() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*set([ ]|$) ]]; then
			good_work
			echo ""
			echo $'Execute "learn" when you\'re ready for the next exercise.'
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

white_belt_frozen_test() {
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 1/1

Your terminal is frozen!  What is the next thing you should try after typing Ctrl+c?

EOL

	luc_correct_answers=0
	luc_answers=( 'Give up and go back to Windows' 'Type Ctrl+q' 'Type Ctrl+s' 'Type Ctrl+u' 'Scream in panic' 'Open another terminal' )

	handle_answer "Type Ctrl+q"
}

white_belt_exercise_frozen() {
	white_belt_frozen_test

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
		echo ""
		echo $'Execute "learn" when you\'re ready for the next exercise.'
	else
		sorry
		echo ""
		echo $'Execute "learn white belt list" to see the list of exercises.'
		echo $'Execute "learn white belt 2" to review a specific white belt exercise.'
	fi
}

white_belt_exercise_set_more() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*set[\ ]*\|[\ ]*more[\ ]*$ ]]; then
			good_work
			echo ""
			echo $'Execute "learn" when you\'re ready for the next exercise.'
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

white_belt_exercise_set_less() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*set[\ ]*\|[\ ]*less[\ ]*$ ]]; then
			good_work
			echo ""
			echo $'Execute "learn" when you\'re ready for the next exercise.'
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

white_belt_exercise_path_and_sourcing() {
	if ask_review_final_exam; then
		keep_going
		return 0
	fi

	if white_belt_final_exam; then
		good_work
	else
		echo "Results:  $luc_correct_answers out of 5 correct"
		echo ""
		sorry
	fi
}

white_belt_final_exam() {
	luc_correct_answers=0

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
If you press Ctrl+c, you will get back to a prompt, but your progress through the questions will not be saved.

You must answer all questions correctly to pass.

Question 1/5

What does the "." in ". check" do?
EOL

	luc_answers=( 'It executes the "check" script as if it was typed in, which changes how environment variables work.' 'It changes the script output to the current directory.' 'It causes the script to be run with authority.' )
	handle_answer 'It executes the "check" script as if it was typed in, which changes how environment variables work.'

	echo
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 2/5

What does slash (/) refer to in terms of a path?

EOL

	luc_answers=( "It's the root directory, in which (or under which) all other directories exist." "It means or:  allowing one path or another to be chosen based on which one exists." "Slash and burn.  Delete everything from here down." "It's the user's home directory." )
	handle_answer "It's the root directory, in which (or under which) all other directories exist."

	echo
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 3/5

What would you find in a user's home directory?

EOL

	luc_answers=( 'Configuration files and other private files' 'System files' 'Global configuration files' 'A well appointed kitchen, including several sinks' )
	handle_answer 'Configuration files and other private files'

	echo
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 4/5

What's the shortest command that will return you to your home directory?

EOL

	luc_answers=( 'cd' 'cd ~' '/' '${HOME}' )
	handle_answer 'cd'

	echo
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 5/5

What are the two situations that you are most likely to run into where Ctrl+c doesn't return you to a prompt?

EOL

	luc_answers=( 'Using less (including man) and accidentally typing Ctrl+s' 'Accidentally typing Ctrl+s and \' 'Using less (including man) and accidentally typing ?' 'The power goes out and gunpowder stops working' )
	handle_answer 'Using less (including man) and accidentally typing Ctrl+s'

	if [ "$luc_correct_answers" == "5" ]; then
		return 0
	else
		return 1
	fi
}

white_belt_test_out() {
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
The white belt tests consist of a one question quiz and a five question final exam.  You must answer all questions
correctly to pass.  Are you ready (y/N)?
EOL

	read CHOICE

	if [[ ! "$CHOICE" =~ ^\s*[Yy].* ]]; then
		exit 2
	fi

	white_belt_frozen_test

	if [[ "$luc_correct_answers" != "1" ]]; then
		sorry
		echo $'You can try again, or execute "learn" to continue with the next exercise.'
		exit 1
	fi

	if white_belt_final_exam; then
		echo "You have successfully tested out of white belt."
	else
		sorry
		echo $'You can try again, or execute "learn" to continue with the next exercise.'
	fi
}

yellow_stripe_exercise_pwd() {
	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*pwd([ ]|$) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
}

yellow_stripe_exercise_cd_dot_dot() {
	luc_req_1=0
	luc_req_2=0

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*pwd([ ]|$) ]]; then
			luc_req_1=1
		fi

		if [[ "$item" =~ ^[\ ]*cd( )*\.\.( )*$ ]]; then
			luc_req_2=1
		fi
	done
	unset IFS

	if [ $luc_req_1 == "1" ] && [ $luc_req_2 == "1" ] && [[ `pwd` == "/" ]]; then
		good_work
	else
		sorry
	fi
}

yellow_stripe_exercise_no_news_is_good_news() {
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 1/1

Your coworker is confused that they input a command to create a directory and only got a prompt back.

EOL

echo "user@example:~/lus$ mkdir one"
echo "user@example:~/lus$"

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL

What happened here?
EOL

	luc_correct_answers=0
	luc_answers=( 'The directory was created.' 'Nothing happened.' 'Something went wrong.' 'A stray cosmic ray flipped a bit in memory.  Reboot!' )

	handle_answer 'The directory was created.'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

yellow_stripe_exercise_mkdir_and_relative_paths() {
	if [ ! -d $LUS_HOME/parent ]; then
		sorry
		return
	fi

	if [ ! -d $LUS_HOME/parent/one ] || [ ! -d $LUS_HOME/parent/two ] || [ ! -d $LUS_HOME/parent/three ]; then
		sorry
		return
	fi

	good_work
}

yellow_stripe_exercise_rmdir() {
	if [ ! -d $LUS_HOME/parent ]; then
		good_work
	else
		sorry
	fi
}

yellow_stripe_exercise_special_characters() {
	if [ -f $LUS_HOME/yellow ]; then
		good_work
	else
		sorry
	fi
}

yellow_stripe_exercise_file() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*file( )*yellow[\ ]*$ ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

yellow_stripe_exercise_cat_less() {
	luc_req_1=0
	luc_req_2=0

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*cat( )*yellow([ ]|$) ]]; then
			luc_req_1=1
		fi

		if [[ "$item" =~ ^[\ ]*less( )*yellow([ ]|$) ]]; then
			luc_req_2=1
		fi
	done
	unset IFS

	if [ $luc_req_1 == "1" ] && [ $luc_req_2 == "1" ]; then
		good_work
	else
		sorry
	fi
}

yellow_stripe_exercise_quotes() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*echo.*HOME ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
}

yellow_stripe_exercise_escaping_quotes() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*echo.*HOME ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
}

yellow_stripe_exercise_quote_finale() {
	if ask_review_final_exam; then
		keep_going
		return 0
	fi

	luc_correct_answers=0

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
If you press Ctrl+c, you will get back to a prompt, but your progress through the questions will not be saved.

You must answer all questions correctly to pass.

Question 1/3

A misbehaving process has created a file called "!@#$".  What is the shortest command line that will successfully rename it?

EOL

	luc_answers=( 'mv !@#$ newname' 'mv !@#'"'"'$'"'"' newname' 'mv '"'"'!@#$'"'"' newname' 'mv "!@#$" newname' 'Open Windows Explorer, click the file, and press F2.' )
	handle_answer 'mv '"'"'!@#$'"'"' newname'

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 2/3

A cat walked across your keyboard while you had a Unix terminal open.  Due to bad luck, you had typed part of a command
line and a single quote before the cat struck.  Due to worse luck, it pressed the single quote key and then Enter.
You now have a file called "kASjiczkskflopd;[f".  Which command will successfully rename it?

EOL

	luc_answers=( 'mv '"'"'kASjiczkskflopd;[f'"'"' newname' 'mv "kASjiczkskflopd;[f" newname' 'mv kASjiczkskflopd\;\[f newname' 'All the mv command lines will work' 'Impossible!  Cats are banned from my workstation.' )
	handle_answer 'All the mv command lines will work'

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 3/3

You need to deal with a file that has multiple spaces and one single quote.  What's the shortest way to quote it that
will work?

EOL

	luc_answers=( '"Monday'"'"'s TPS Report for John"      (30 characters)' '"Monday\'"'"'s TPS Report for John"     (31 characters)' 'Monday\'"'"'s\ TPS\ Report\ for\ John   (33 characters)' 'Funny answer TBD                    (16 characters)' )
	handle_answer '"Monday'"'"'s TPS Report for John"      (30 characters)'

	if [ "$luc_correct_answers" == "3" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers out of 3 correct"
		echo ""
		sorry
	fi
}

yellow_belt_exercise_terminals_and_shells() {
	keep_going
}

yellow_belt_exercise_asterisk() {
	if [[ `pwd` == "$LUS_HOME/complete" ]]; then
		good_work
		echo ""
		echo $'Execute "learn" when you\'re ready for the next exercise.'
	else
		sorry
	fi
}

yellow_belt_exercise_unquoted_tab_completion() {
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 1/1

What kind of file is Monday's TPS Report for John?

EOL

	luc_correct_answers=0
	luc_answers=( 'empty' 'Microsoft Word' 'text file' 'Martian cartographic data' )

	handle_answer 'empty'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

yellow_belt_exercise_unquoted_tab_completion_two_options() {
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 1/1

What kind of file is Monday's TPS Report for Fred?

EOL

	luc_correct_answers=0
	luc_answers=( 'empty' 'Microsoft Excel' 'ASCII text' 'Open Office Presentation' )

	handle_answer 'ASCII text'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

yellow_belt_exercise_quoted_tab_completion() {
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 1/1

What's inside Monday's TPS Report for Fred?

EOL

	luc_correct_answers=0
	luc_answers=( 'TBA' 'TBD' 'TBW' 'Top-secret Space Station Plans' )

	handle_answer 'TBW'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

yellow_belt_exercise_tab_is_context_sensitive() {
	keep_going
}

yellow_belt_exercise_up() {
	keep_going
}

yellow_belt_exercise_home_end_and_pound() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*# ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
}

yellow_belt_exercise_ctrl_r() {
	keep_going
}

yellow_belt_exercise_history_bang() {
	if ask_review_final_exam; then
		keep_going
		return 0
	fi

	luc_correct_answers=0

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
If you press Ctrl+c, you will get back to a prompt, but your progress through the questions will not be saved.

You must answer all questions correctly to pass.

Question 1/3

If you found a command in your history with Ctrl+r but you need to make a change to it first, what should you do?

EOL

	luc_answers=( 'Type Ctrl+c' 'Type Ctrl+g' 'Start typing the desired changes' 'Press Left, Right, Ctrl+b, or Ctrl+f' 'Ask the audience' )
	handle_answer 'Press Left, Right, Ctrl+b, or Ctrl+f'

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 2/3

With some terminals, what keystrokes do you need to go to the beginning and end of the current command line?

EOL

	luc_answers=( 'Ctrl+a and Ctrl+e' 'Ctrl+f and Ctrl+b' 'Ctrl+1 and Ctrl+9' 'The Home and End keys work everywhere!' )
	handle_answer 'Ctrl+a and Ctrl+e'

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 3/3

If you want to keep what you've typed so far but not run it, what should you do?

EOL

	luc_answers=( 'Type Ctrl+a, #, Enter' "Just press Enter, there are errors so it won't run" 'Type Ctrl+h' 'Type Ctrl+s' )
	handle_answer 'Type Ctrl+a, #, Enter'

	if [ "$luc_correct_answers" == "3" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers out of 3 correct"
		echo ""
		sorry
	fi
}

green_stripe_exercise_command_line_options() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*man( )*ls([ ]|$) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

green_stripe_exercise_ls() {
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 1/1

Did you notice anything odd about the file listings?

EOL

	luc_correct_answers=0
	luc_answers=( 'The files "one", "two", and "three" were in alphabetical order, which was odd.' 'There was no file called "two".' 'The files "first", "second", and "third" were out of order.' 'Oh, a squirrel.' )

	handle_answer 'The files "one", "two", and "three" were in alphabetical order, which was odd.'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

green_stripe_exercise_ls_dash_l() {
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 1/1

What did you find?

EOL

	luc_correct_answers=0
	luc_answers=( 'The files "one", "two", and "three" have different dates.' 'There is no file called "second".' 'The files "first", "second", and "third" have different dates.' 'Hey!  Look at the obvious distraction!' )

	handle_answer 'The files "one", "two", and "three" have different dates.'

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

green_stripe_exercise_ls_explore() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*ls( )*-([A-Za-z]*t[A-Za-z]*r[A-Za-z]*|[A-Za-z]*r[A-Za-z]*t[A-Za-z]*) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

green_stripe_exercise_ls_dash_h() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*ls( )*-([A-Za-z]*h) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

green_stripe_exercise_ls_dash_f() {
	keep_going
}

green_stripe_exercise_df() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*df( )*-([A-Za-z]*h) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

green_stripe_exercise_dev_and_mount() {
	if ask_review_final_exam; then
		keep_going
		return 0
	fi

	luc_correct_answers=0

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
If you press Ctrl+c, you will get back to a prompt, but your progress through the questions will not be saved.

Once you complete all questions correctly, you will move to the advanced ranks.

Question 1/9

If you found a command in your history with Ctrl+r but you need to make a change to it first, what should you do?

EOL

	luc_answers=( 'Type Ctrl+c' 'Type Ctrl+g' 'Start typing the desired changes' 'Press Left, Right, Ctrl+b, or Ctrl+f' 'Ask the audience' )
	handle_answer 'Press Left, Right, Ctrl+b, or Ctrl+f'

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 2/9

You want to see a long-format file list with the most recent files at the bottom.  Which options will do that?

EOL

	luc_answers=( 'ls -lh' 'ls -ltr' 'ls -Al' 'ls -lt' 'ls -ohno' )
	handle_answer 'ls -ltr'

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 3/9

You want to see a long-format file list with the oldest files at the bottom.  Which options will do that?

EOL

	luc_answers=( 'ls -lh' 'ls -lt' 'ls -Al' 'ls -ltr' 'Ctrl+c! Ctrl+c!!' )
	handle_answer 'ls -lt'

	# Start of Question 4/9
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 4/9

After executing "df -h" on a FreeBSD system, you see the following output.  Is there a problem?

EOL

	cat <<EOL
Filesystem         Size    Used   Avail Capacity  Mounted on
/dev/gpt/rootfs    9.7G    5.5G    3.4G    62%    /
devfs              1.0K    1.0K      0B   100%    /dev

EOL

	luc_answers=( 'Yes' 'No' 'Fish' )
	handle_answer 'No'

	# Start of Question 5/6
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 5/9

Now you're on a Mac.  You execute "df -h", and see the following.  Is there a problem?

EOL

	cat <<EOL
Filesystem       Size   Used  Avail Capacity iused      ifree %iused  Mounted on
/dev/disk1s6s1  466Gi   22Gi  227Gi     9%  501138 2383102400    0%   /
devfs           199Ki  199Ki    0Bi   100%     690          0  100%   /dev
/dev/disk1s5    466Gi  2.0Gi  227Gi     1%       2 2383102400    0%   /System/Volumes/VM
/dev/disk1s3    466Gi  256Mi  227Gi     1%     814 2383102400    0%   /System/Volumes/Preboot
/dev/disk1s7    466Gi  100Mi  227Gi     1%     441 2383102400    0%   /System/Volumes/Update
/dev/disk1s1    466Gi  201Gi  227Gi    47% 1250938 2383102400    0%   /System/Volumes/Data
map auto_home     0Bi    0Bi    0Bi   100%       0          0  100%   /System/Volumes/Data/home
/dev/disk1s6    466Gi   22Gi  227Gi     9%  502049 2383102400    0%   /System/Volumes/Update/mnt1

EOL

	luc_answers=( 'Yes' 'No' 'Phone a friend' )
	handle_answer 'No'

	# Start of Question 6/9
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 6/9

Here is the output of "df -h" from a Linux system.  Is there a problem?

EOL

	cat <<EOL
Filesystem      Size  Used Avail Use% Mounted on
udev            445M     0  445M   0% /dev
tmpfs            99M  1.2M   98M   2% /run
/dev/sda5        29G   28G     0 100% /
tmpfs           491M     0  491M   0% /dev/shm
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
tmpfs           491M     0  491M   0% /sys/fs/cgroup
/dev/sda1       511M  4.0K  511M   1% /boot/efi
tmpfs            99M   20K   99M   1% /run/user/1000

EOL

	luc_answers=( 'Yes' 'No' 'Maybe' )
	handle_answer 'Yes'

	# Start of Question 7/9
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 7/9

Where would you find the details for all mounts that are mounted when the system boots?

EOL

	luc_answers=( '/etc/fstab' '/etc/fsystab' '/etc/fstable' '/etc/stable' )
	handle_answer '/etc/fstab'

	# Start of Question 8/9
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 8/9

Is the following statement true?  The special file /dev/sda1 isn't a real file, so you don't need to be careful with it.

EOL

	luc_answers=( 'Yes' 'No' 'Maybe' )
	handle_answer 'No'

	# Start of Question 9/9
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 9/9

Can non-root users mount filesystems?

EOL

	luc_answers=( 'Only if FUSE is installed and configured' 'No' 'Yes' )
	handle_answer 'Only if FUSE is installed and configured'

	# Final check
	if [ "$luc_correct_answers" == "9" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers out of 9 correct"
		echo ""
		sorry
	fi
}

green_belt_exercise_ctrl_c() {
	luc_correct_answers=0

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
You must answer all questions correctly to pass.

Question 1/2

What happens when you press Ctrl+c while the "cp" command is doing its work?

EOL

	luc_answers=( 'The filesystem is corrupted' 'Previous files remain and the current file will be partially written' 'All changes are undone' 'Previous files remain and the current file will be removed' )
	handle_answer 'Previous files remain and the current file will be partially written'

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 2/2

What is a Unix signal?

EOL

	luc_answers=( 'A simple way for one program to tell another that something happened' 'A coloured light that controls vehicles' 'A complex mechanism to send information from one program to another' )
	handle_answer 'A simple way for one program to tell another that something happened'

	# Final check
	if [ "$luc_correct_answers" == "2" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers out of 6 correct"
		echo ""
		sorry
	fi
}

green_belt_exercise_ctrl_l() {
	keep_going
}

green_belt_exercise_ls_a_alias() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*type[\ ][\ ]*ls([\ ]|$) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

green_belt_exercise_hidden_files() {
	keep_going
}

green_belt_exercise_pushd() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*pushd[\ ][\ ]*/([\ ]|$) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

green_belt_exercise_popd() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*popd([\ ]|$) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

green_belt_exercise_dir_stacks() { # Final
	luc_correct_answers=0
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 1/5

Feel free to check your notes.  What does "mv .[^.]* .." do?

EOL

	luc_answers=( 'It moves all files in the current directory to the parent directory.' 'It moves all hidden files in the current directory to the parent directory as long as none of them start with two dots.' 'It moves all hidden files in the current directory to the parent directory.' 'It makes a hole in the space-time continuum.' )
	handle_answer 'It moves all hidden files in the current directory to the parent directory as long as none of them start with two dots.'

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 2/5

What does "cp -R /home/user/abc /mnt/usb/" do?

EOL

	luc_answers=( 'It copies the abc directory and everything in it (including hidden files and hidden directories) into /mnt/usb/, creating /mnt/usb/abc/ if necessary.' 'It copies everything inside the abc directory (including hidden files and hidden directories) into /mnt/usb/.' 'It copies anything recent with "abc" in it to /mnt/usb/.' )

handle_answer 'It copies the abc directory and everything in it (including hidden files and hidden directories) into /mnt/usb/, creating /mnt/usb/abc/ if necessary.'

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 3/5

What does "cp -R /home/user/abc/. /mnt/usb/" do?

EOL

	luc_answers=( 'It copies the abc directory and everything in it (including hidden files and hidden directories) into /mnt/usb/, creating /mnt/usb/abc/ if necessary.' 'It copies everything inside the abc directory (including hidden files and hidden directories) into /mnt/usb/.' 'It copies anything recent with "abc" in it to /mnt/usb/.' )

	handle_answer 'It copies everything inside the abc directory (including hidden files and hidden directories) into /mnt/usb/.'

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 4/5

Which command line shows hidden files and hidden directories, assuming ls is not aliased?

EOL

	luc_answers=( 'ls -a' 'ls -l' 'ls -R' 'ls -ohno' )
	handle_answer 'ls -a'

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 5/5

If you needed to check something quickly in the /tmp directory and then wanted to go back to where you were,
what two command lines would you use?

EOL

	luc_answers=( '"pushd /tmp" and "popd"' '"pushd" and "popd /tmp"' '"pushd /" and "popd"' '"pushy /" and "poppy"' )
	handle_answer '"pushd /tmp" and "popd"'

	# Final check
	if [ "$luc_correct_answers" == "5" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers out of 5 correct"
		echo ""
		sorry
	fi
}

blue_stripe_exercise_archive_files() {
	success=0
	archive_file="${LUS_HOME}/blue-stripe/archive-one.tar.gz"
	if [ -f "${archive_file}" ]; then
		file_type=$(file "${archive_file}")
		if [[ "${file_type}" =~ "gzip compressed data" ]]; then
			inner_file_type=$(gunzip -c "${archive_file}" | file -)
			if [[ "${inner_file_type}" =~ "tar archive" ]]; then
				set +e
				diff -q <( tar tzf "${archive_file}" | sort ) <(cat <<EOL
to-archive/
to-archive/dir1/
to-archive/dir1/file4
to-archive/dir1/file5
to-archive/dir2/
to-archive/dir2/file6
to-archive/file1
to-archive/file2
to-archive/file3
EOL
) > /dev/null
				diff_result=$?
				set -e
				if [ "${diff_result}" == "0" ]; then
					# Check all file data with grep .*
					if [ -f "${LUS_HOME}/blue-stripe/to-archive-extract-check" ]; then
						fmt ${FMT_OPTIONS:-}$luc_width <<EOL
We need to extract the archive to ${LUS_HOME}/blue-stripe/to-archive-extract-check, but it's a file, not a directory.
Is it OK to overwrite it (y/N)?
EOL

						read CHOICE

						if [[ ! "$CHOICE" =~ ^\s*[Yy].* ]]; then
							exit 2
						fi

						rm -f "${LUS_HOME}/blue-stripe/to-archive-extract-check"
					fi

					if [ -d "${LUS_HOME}/blue-stripe/to-archive-extract-check" ]; then
						fmt ${FMT_OPTIONS:-}$luc_width <<EOL
We need to extract the archive to ${LUS_HOME}/blue-stripe/to-archive-extract-check, but it already exists.  Is it OK to
delete everything in it (y/N)?
EOL

						read CHOICE

						if [[ ! "$CHOICE" =~ ^\s*[Yy].* ]]; then
							exit 2
						fi

						rm -Rf "${LUS_HOME}/blue-stripe/to-archive-extract-check"
					fi

					mkdir -p "${LUS_HOME}/blue-stripe/to-archive-extract-check"
					cd "${LUS_HOME}/blue-stripe/to-archive-extract-check"
					tar xzf "${archive_file}"

					set +e
					diff -q <( find . -type f -print -exec grep -Hin ".*" {} \; | sort ) <(cat <<EOL
./to-archive/dir1/file4
./to-archive/dir1/file4:1:file4
./to-archive/dir1/file5
./to-archive/dir1/file5:1:file5
./to-archive/dir2/file6
./to-archive/dir2/file6:1:file6
./to-archive/file1
./to-archive/file1:1:file1
./to-archive/file2
./to-archive/file2:1:file2
./to-archive/file3
./to-archive/file3:1:file3
EOL
) > /dev/null

					diff_result=$?
					set -e
					if [[ "${diff_result}" == "0" ]]; then
						echo "You have successfully created a flawless archive!"
						good_work
						success=1
					else	
						sorry
						fmt ${FMT_OPTIONS:-}$luc_width <<EOL
All the files are there in the archive, but the data in them isn't correct.  Run the learn script again to update the
files and try again.
EOL
					fi
				else
					sorry
					echo "We were expecting to see the following in the archive."
					cat <<EOL
to-archive/
to-archive/dir1/
to-archive/dir1/file4
to-archive/dir1/file5
to-archive/dir2/
to-archive/dir2/file6
to-archive/file1
to-archive/file2
to-archive/file3
EOL

					echo
					echo "But instead, the archive contains the following."
					tar tzf "${archive_file}" | sort
					echo

					if tar tzf "${archive_file}" | grep -q "blue-stripe"; then
						fmt ${FMT_OPTIONS:-}$luc_width <<EOL
The archive file should only contain the "to-archive" directory.  Make sure you're in the right directory when you make it.
Try again.  Run the learn script again if you need to.
EOL
					elif tar tzf "${archive_file}" | grep -q -v "to-archive"; then
						fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Oh no!  This is a tarbomb!  Try again.  Run the learn script again if you need to.
EOL
					fi
				fi
			else
				sorry
				fmt ${FMT_OPTIONS:-}$luc_width <<EOL
The file "${LUS_HOME}/blue-stripe/archive-one.tar.gz" isn't a valid tar.gz file.  Please use the tar command to create
the archive.  If you need more hints, execute "learn" again.
EOL
			fi
		else
			sorry
			echo "Did you forget to use the 'z' option to compress the archive?"
		fi

		# We're still in the "if the file exists" block.
		if [ "$success" = "0" ]; then
			fmt ${FMT_OPTIONS:-}$luc_width <<EOL

Keep in mind that if you run tar again on the same archive, it will add more files to it.  You're going to want to
delete it first by executing the following.

rm "${archive_file}"
EOL
	fi
	else
		sorry
		echo "Can't find a file called \"${LUS_HOME}/blue-stripe/archive-one.tar.gz\"."
		echo "Did you create the archive file with exactly the right name?"
		echo "UNIX is (usually) case sensitive."
	fi

	if [ -d "${LUS_HOME}/blue-stripe/to-archive-extract-check" ]; then
		rm -Rf "${LUS_HOME}/blue-stripe/to-archive-extract-check"
	fi
}

blue_stripe_exercise_archive_files_extract() {
	if [ -d "${LUS_HOME}/blue-stripe/from-archive" ]; then
		set +e
		diff -q <( cd "${LUS_HOME}/blue-stripe/from-archive" && find . -type f -print -exec grep -Hin ".*" {} \; | sort ) <(cat <<EOL
./dir1/file10
./dir1/file10:1:file10
./dir1/file11
./dir1/file11:1:file11
./dir2/file12
./dir2/file12:1:file12
./file7
./file7:1:file7
./file8
./file8:1:file8
./file9
./file9:1:file9
EOL
)

		diff_result=$?
		set -e
		if [[ "${diff_result}" == "0" ]]; then
			echo "You have successfully extracted the archive to the correct location."
			good_work
			success=1
		else	
			sorry
			fmt ${FMT_OPTIONS:-}$luc_width <<EOL
There's unexpected data.  Please rename or move \"${LUS_HOME}/blue-stripe/from-archive\" and try again.
EOL
		fi
	else
		sorry
		fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Unable to find \"${LUS_HOME}/blue-stripe/from-archive\", which should have been created when you extracted the archive.
EOL
	fi
}

blue_stripe_exercise_zip() { # Introduction to zip and unzip
	keep_going
}

blue_stripe_exercise_vi() { # Introducion to vi
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*vi([\ ]|$) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

blue_stripe_exercise_moving_around_in_vi() {
	set +e
	diff -q "${LUS_HOME}/blue-stripe/vi-intro.txt" <(cat <<EOL
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum malesuada ut
quam at ullamcorper. Praesent cursus tellus in convallis pulvinar. Sed
facilisis, urna nec venenatis mattis, orci ex consequat nibh, id aliquet diam
lectus at turpis. Morbi porttitor bibendum sem ut faucibus. Interdum et
malesuada fames ac ante ipsum primis in faucibus. Morbi ac sagittis dui. Aliquam
fermentum magna nec faucibus imperdiet. In hac habitasse platea dictumst.
Curabitur imperdiet lorem fringilla leo pellentesque, quis fermentum augue
vestibulum. Nunc pellentesque in massa et cursus. Suspendisse at euismod leo, ac
volutpat ex. Phasellus vel finibus diam.

Pellentesque malesuada felis in justo pretium feugiat. Vivamus lobortis, urna
nec rhoncus viverra, nulla quam semper ante, non vehicula orci tortor vitae
eros. Donec eget eros faucibus, tristique sem non, condimentum arcu. Morbi quis
bibendum magna. Ut bibendum purus nunc, non porta justo aliquam eget. Praesent
vel odio quis tellus feugiat viverra. Pellentesque mollis et mauris in sagittis.

Quisque suscipit efficitur nisi in tempor. Donec nulla quam, pretium ut dapibus
vestibulum, iaculis ac ante. Ut facilisis ante ac imperdiet viverra. Vivamus
lectus lectus, fermentum non turpis quis, facilisis congue metus. Nullam ut
tellus vulputate, mattis est vitae, dapibus orci. Integer condimentum quis risus
ac fringilla. Quisque efficitur posuere eleifend. Cras eget neque eget ante
scelerisque imperdiet. Proin lorem lorem, malesuada non condimentum eu, accumsan
at odio. Integer laoreet venenatis lacus, at iaculis massa venenatis ac.

Vivamus iaculis et neque eu porta. Duis quam felis, placerat eu rhoncus a,
feugiat nec neque. Duis rhoncus justo non lectus sollicitudin vulputate. Vivamus
ac libero finibus, commodo lacus a, suscipit mi. Praesent lacinia ex arcu, at
elementum eros ornare sed. Curabitur non nisi sapien. Suspendisse vehicula ex id
congue laoreet. Duis posuere tortor a quam blandit, vel molestie ex aliquet.
Vestibulum tempus lacus in diam viverra, sit amet semper lorem consectetur.
Donec leo quam, tincidunt sed ipsum ac, posuere interdum felis. Nunc quis metus
sit amet nunc feugiat consequat sit amet eget urna. Nullam bibendum convallis
enim eu luctus. Aliquam vitae scelerisque augue, a ullamcorper enim. Nam
hendrerit dui in nibh ornare, ut consequat lectus suscipit.

Vestibulum molestie pellentesque sodales. Nunc tincidunt ipsum eu viverra
tincidunt. Nulla facilisi. Etiam consequat finibus nibh, fermentum imperdiet
libero dictum in. Sed erat ex, laoreet ut aliquam et, dapibus eu magna.
Vestibulum at posuere arcu. Mauris a ligula at nisl tincidunt imperdiet. Quisque
dapibus, turpis et ornare venenatis, tortor diam pretium ipsum, vitae semper
lectus arcu ac est. Maecenas vestibulum risus eu lacinia blandit. Sed vel est
sapien. Vestibulum et ullamcorper est, fermentum elementum sem. Aliquam et
placerat sapien.
EOL
)

	if [[ $? == "1" ]]; then
		set -e
		good_work
	else
		set -e
		echo "The file hasn't been changed."
		sorry
	fi
}

blue_stripe_exercise_searching_in_vi() {
	set +e
	if grep -q "in tempor" "${LUS_HOME}/blue-stripe/vi-intro.txt"; then
		set -e
		sorry
	else
		set -e
		good_work
	fi
}

blue_stripe_exercise_wrap_up_of_vi() {
	keep_going
}

blue_stripe_exercise_nano_and_ee() {
	if ask_review_final_exam; then
		keep_going
		return 0
	fi

	luc_correct_answers=0

	# Question 1
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 1/7

Which of the following commands creates a tar archive called archive.tar.gz and fills it with the contents of dir1?

EOL

	luc_answers=( 'tar czf archive.tar.gz dir1' 'tar -cfz archive.tar.gz dir1' 'tar xvzf archive.tar.gz dir1' 'tar xzf archive.tar.gz dir1' 'tar --feather archive.tar.gz' )
	handle_answer 'tar czf archive.tar.gz dir1'

	# Question 2
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 2/7

Which of the following commands extracts a tar archive called archive.tar.gz?

EOL

	luc_answers=( 'tar xzf archive.tar.gz' 'tar -xfz archive.tar.gz dir1' 'tar cvzf archive.tar.gz' 'tar czf archive.tar.gz' 'solvent' )
	handle_answer 'tar xzf archive.tar.gz'

	# Question 3
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 3/7

Which of the following commands creates a zip archive called "archive.zip" that contains the contents of dir1?

EOL

	luc_answers=( 'zip -r archive.zip dir1' 'zip archive.zip dir1' 'unzip -r archive.zip dir1' 'unzip archive.zip dir1' 'Coat' )
	handle_answer 'zip -r archive.zip dir1'

	# Question 4
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 4/7

Which of the following commands unzips a zip archive called "archive.zip" into the current directory?

EOL

	luc_answers=( 'zip -r archive.zip' 'zip archive.zip' 'unzip -r archive.zip' 'unzip archive.zip' 'Jacket' )
	handle_answer 'unzip archive.zip'

	# Question 5
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 5/7

How do you "escape" from vi (quit without saving)?

EOL

	luc_answers=( 'Escape :q! Enter' 'Escape Escape' 'Keep pressing Escape until vi gives up' 'Escape :wq Enter' )
	handle_answer 'Escape :q! Enter'

	# Question 6
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 6/7

How do you save and quit vi?

EOL

	luc_answers=( 'Escape :q! Enter' 'Escape Escape' 'Keep pressing Escape until vi gives up' 'Escape :wq Enter' )
	handle_answer 'Escape :wq Enter'

	# Question 7
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 7/7

What do you type to search in vi (in normal mode, not in insert mode)?

EOL

	luc_answers=( '/ (Slash)' ': (Colon)' '| (Pipe)' '~ (Tilde)' )
	handle_answer '/ (Slash)'

	if [ "$luc_correct_answers" == "7" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers out of 7 correct"
		echo ""
		sorry
	fi
}

blue_belt_exercise_intro_to_pipes() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*set[\ ]*\|[\ ]*wc[\ ][\ ]*-l$ ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

blue_belt_exercise_stdout_and_stderr() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*set[\ ]*\|[\ ]*grep[\ ][\ ]*BASH[\ ]*$ ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

blue_belt_exercise_chaining_pipes() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*set[\ ]*\|[\ ]*grep[\ ][\ ]*\^BASH[\ ]*\|[\ ]*wc[\ ][\ ]*-l$ ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

blue_belt_exercise_cut() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		compressed_item=$(tr -s ' ' <<< "$item")
		if [[ "$item" =~ ^[\ ]*set[\ ]*\|[\ ]*grep\ \^BASH[\ ]*\|[\ ]*cut\ -d\'=\'\ -f1[\ ]*$ ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

blue_belt_exercise_redirection() {
	if [ ! -f "${LUS_HOME}/blue-belt/bash-names" ]; then
		sorry
	else
		set +e
		if grep "^BASH$" "${LUS_HOME}/blue-belt/bash-names" > /dev/null 2>&1; then
			if grep "^BASH_VERSION$" "${LUS_HOME}/blue-belt/bash-names" > /dev/null 2>&1; then
				good_work
			else
				sorry
			fi
		else
			sorry
		fi
		set -e
	fi
}

blue_belt_exercise_tee() {
	blue_belt_exercise_redirection
}

blue_belt_exercise_cat_revisited() {
	if [ -f "${LUS_HOME}/blue-belt/cat-output" ]; then
		file_lines=$(cat "${LUS_HOME}/blue-belt/cat-output" | wc -l)
		if [[ "$file_lines" == "3" ]]; then
			good_work
		else
			sorry
			echo "The file ${LUS_HOME}/blue-belt/cat-output has ${file_lines} lines."
		fi 
	else
		sorry
		echo "The file ${LUS_HOME}/blue-belt/cat-output doesn't exist."
	fi
}

blue_belt_exercise_predicting_the_future() {
	luc_correct_answers=0
	luc_answers=( '5 pm' '6 pm' '7 pm' '8 pm' 'Never' )

	handle_answer "8 pm"

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

blue_belt_exercise_epoch_time() {
	keep_going
}

epoch_to_human_readable() {
	if [[ "${BSD_DATE:-}" -eq "1" ]]; then
		echo $(date -r $1 +"%B %-d, %Y")
	else
		echo $(date -d@$1 +"%B %-d, %Y")
	fi
}

blue_belt_exercise_converting_to_epoch_time() {
	if [ -z "${LUS_SECRET:-}" ]; then
		echo "Please run the learn script first."
		exit 1
	fi
}

epoch_quiz_main() {
	epoch_date_only=${LUS_SECRET}

	# Is the correct answer behind door #1, door #2, or door #3?
	door=$(( $RANDOM % 3 ))

	if [[ "$door" -eq "0" ]]; then
		door_1=${epoch_date_only}
		door_2=$(( ${epoch_date_only} + 10 * 86400 ))
		door_3=$(( ${epoch_date_only} + 20 * 86400 ))
	elif [[ "$door" -eq "1" ]]; then
		door_1=$(( ${epoch_date_only} - 10 * 86400 ))
		door_2=${epoch_date_only}
		door_3=$(( ${epoch_date_only} + 10 * 86400 ))
	else
		door_1=$(( ${epoch_date_only} - 20 * 86400 ))
		door_2=$(( ${epoch_date_only} - 10 * 86400 ))
		door_3=${epoch_date_only}
	fi
}

epoch_quiz_human_readable() {
	door_1h=$(epoch_to_human_readable ${door_1})
	door_2h=$(epoch_to_human_readable ${door_2})
	door_3h=$(epoch_to_human_readable ${door_3})
}

blue_belt_exercise_converting_to_epoch_time() {
	if [ -z "${LUS_SECRET:-}" ]; then
		echo "Please run the learn script first."
		exit 1
	fi

	epoch_quiz_main

	luc_correct_answers=0
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question l/1

What is the epoch time for $(epoch_to_human_readable ${LUS_SECRET})?

EOL

	luc_answers=( -17 $door_1 $door_2 $door_3 650696040000 )
	do_shuffle=
	handle_answer ${LUS_SECRET}

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

blue_belt_exercise_converting_from_epoch_time() {
	if [ -z "${LUS_SECRET:-}" ]; then
		echo "Please run the learn script first."
		exit 1
	fi

	epoch_quiz_main
	epoch_quiz_human_readable

	luc_correct_answers=0
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question l/1

What is the date corresponding to epoch time ${LUS_SECRET}?

EOL

	luc_answers=( "May 28, -585" "$door_1h" "$door_2h" "$door_3h" "September 28, 22586" )
	do_shuffle=
	handle_answer "$(epoch_to_human_readable ${LUS_SECRET})"

	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		sorry
	fi
}

blue_belt_exercise_piping_pipes() {
	keep_going
}

blue_belt_exercise_beyond_pipes() {
	if ask_review_final_exam; then
		keep_going
		return 0
	fi

	luc_correct_answers=0

	# Question 1
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 1/9

What is "standard out" (aka "stdout")?

EOL

	luc_answers=( 'The normal output of a process (which can be redirected with a pipe or right angle bracket)' 'The end of anti-exceptionalism.' 'The error output of a process (usually error messages, if there are any)' 'The difference between the height of the regression line and a data point.' )
	handle_answer 'The normal output of a process (which can be redirected with a pipe or right angle bracket)'

	# Question 2
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 2/9

What is "standard error" (aka "stderr")?

EOL

	luc_answers=( 'The normal output of a process (which can be redirected with a pipe or right angle bracket)' 'The end of anti-exceptionalism.' 'The error output of a process (usually error messages, if there are any)' 'The difference between the height of the regression line and a data point.' )
	handle_answer 'The error output of a process (usually error messages, if there are any)'

	# Question 3
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 3/9

When you use ">" after a command and before a filename at a prompt (in your shell) what does it do?

EOL

	luc_answers=( 'It redirects the output of the command to the filename, wiping the file if it exists.' 'It redirects the output of the command to the filename, appending to the file if it exists.' 'It returns true if the return value of the first command is larger than the return value of the second command.' )
	handle_answer 'It redirects the output of the command to the filename, wiping the file if it exists.'

	# Question 4
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 4/9

When you use ">>" after a command and before a filename at a prompt (in your shell) what does it do?

EOL

	luc_answers=( 'It redirects the output of the command to the filename, wiping the file if it exists.' 'It redirects the output of the command to the filename, appending to the file if it exists.' 'It returns true if the return value of the first command is much larger than the return value of the second command.' )
	handle_answer 'It redirects the output of the command to the filename, appending to the file if it exists.'

	# Question 5
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 5/9

What does the tr program do (among other things)?

EOL

	luc_answers=( 'It replaces runs of characters with a single one (for example, replacing a series of spaces with one space). It can also delete all examples of a specific character.' 'It pulls out one field or specific fields from the input.' 'It searches for things in the input and prints out any matches.' 'It sends its input to two (or more) places at the same time, for example, to both the terminal and a file.' )
	handle_answer 'It replaces runs of characters with a single one (for example, replacing a series of spaces with one space). It can also delete all examples of a specific character.'

	# Question 6
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 6/9

What does the cut program do?

EOL

	luc_answers=( 'It replaces runs of characters with a single one (for example, replacing a series of spaces with one space). It can also delete all examples of a specific character.' 'It pulls out one field or specific fields from the input.' 'It searches for things in the input and prints out any matches.' 'It sends its input to two (or more) places at the same time, for example, to both the terminal and a file.' )
	handle_answer 'It pulls out one field or specific fields from the input.'

	# Question 7
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 7/9

What does the grep program do?

EOL

	luc_answers=( 'It replaces runs of characters with a single one (for example, replacing a series of spaces with one space). It can also delete all examples of a specific character.' 'It pulls out one field or specific fields from the input.' 'It searches for things in the input and prints out any matches.' 'It sends its input to two (or more) places at the same time, for example, to both the terminal and a file.' )
	handle_answer 'It searches for things in the input and prints out any matches.'

	# Question 8
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 8/9

What does the tee program do?

EOL

	luc_answers=( 'It replaces runs of characters with a single one (for example, replacing a series of spaces with one space). It can also delete all examples of a specific character.' 'It pulls out one field or specific fields from the input.' 'It searches for things in the input and prints out any matches.' 'It sends its input to two (or more) places at the same time, for example, to both the terminal and a file.' )
	handle_answer 'It sends its input to two (or more) places at the same time, for example, to both the terminal and a file.'

	# Question 9
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 9/9

What is epoch time?

EOL

	do_shuffle=
	luc_answers=( 'The number of seconds since midnight January 1, 1960 UTC' 'The number of seconds since July 20, 1969, at 20:17 UTC' 'The number of seconds since midnight January 1, 1970 UTC' 'The number of seconds since midnight January 1, 1980 UTC' )
	handle_answer 'The number of seconds since midnight January 1, 1970 UTC'

	# Final check
	if [ "$luc_correct_answers" == "9" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers out of 9 correct"
		echo ""
		sorry
	fi
}

# Red stripe exercises (Start vim fold) {{{
red_stripe_exercise_storage_size_terms() {
	keep_going
}

red_stripe_exercise_du() {
	keep_going
}

red_stripe_exercise_du_sort() {
	keep_going
}

red_stripe_exercise_du_sort_head() {
	keep_going
}

red_stripe_exercise_diff() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*diff.*rules.*rules ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

red_stripe_exercise_diff_u() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*diff.*-u.*rules.*rules ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

red_stripe_exercise_diff_changes() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*diff.*-u.*rules.*rules-changed ]]; then
			good_work
			unset IFS
			return
		fi

		if [[ "$item" =~ ^[\ ]*diff.*-u.*rules-changed.*rules ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

red_stripe_exercise_diff_adds() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*diff.*-u.*rules.*rules-added ]]; then
			good_work
			unset IFS
			return
		fi

		if [[ "$item" =~ ^[\ ]*diff.*-u.*rules-added.*rules ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

red_stripe_exercise_diff_extras() {
	keep_going
}

red_stripe_exercise_mv() {
	if [ -f "${LUS_HOME}/red-stripe/mv/lorem-ipsum" ] && [ ! -f "${LUS_HOME}/red-stripe/mv/lorem" ]; then
		good_work
	else
		sorry
	fi
}

red_stripe_exercise_mv_wrap_up() {
	keep_going
}

red_stripe_exercise_rm_rf() {
	if [ ! -d "$LUS_HOME/red-stripe" ]; then
		good_work
	else
		sorry
	fi
}

red_stripe_exercise_final() {
	luc_correct_answers=0

	# Question 1
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 1/6

Which command will sort lines with human readable numbers largest to smallest?

EOL

	luc_answers=( 'sort -r' 'sort -hr' 'sort -h' 'sort' 'sort --help' )
	handle_answer 'sort -hr'

	# Question 2
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 2/6

Which command will show you the top ten largest files and directories in the current directory (recursively)?

EOL

	luc_answers=(
		'sort -hr | head | du -ah'
		'sort -hr | du -ah | head'
		'du -ah | sort -hr | head'
		'du -ah | head | sort -hr'
		'head | sort -hr | du -ah'
		'head | du -ah | sort -hr'
		'du hast sort'
	)
	do_shuffle=
	handle_answer 'du -ah | sort -hr | head'
	do_shuffle=1

	# Question 3
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 3/6

Which program would you use to see if two text files have different contents?

EOL

	luc_answers=(
		'du'
		'df'
		'mv'
		'rm'
		'diff'
		'help!'
	)
	handle_answer 'diff'

	# Question 4
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 4/6

The "diff" program gave you the following output.  What does it mean?

EOL

	cat <<EOL
4d3
< (4) The fourth rule of tautology club either is or it isn't.

EOL

	luc_answers=(
		'The fourth line of the first file was deleted.'
		'The third line of the first file was deleted.'
		'Four lines from the first file were deleted.'
		'Three lines from the first file were deleted.'
		'The end is nigh.'
	)
	handle_answer 'The fourth line of the first file was deleted.'

	# Question 5
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 5/6

Which command renames the directory named "my-stuff" to "our-stuff"?

EOL

	luc_answers=(
		'mv -r my-stuff our-stuff'
		'mv -R my-stuff our-stuff'
		'mv my-stuff our-stuff'
		'marriage'
	)
	handle_answer 'mv my-stuff our-stuff'

	# Question 6
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 6/6

Which command, in some circumstances, will cause the "rm" program to attempt to delete all files and directories?

EOL

	luc_answers=(
		'rm -rf .*'
		'rm -rf .'
		'rm .*'
		'rm'
		'make world'
	)
	handle_answer 'rm -rf .*'

	# Final check
	if [ "$luc_correct_answers" == "6" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers out of 6 correct"
		echo ""
		sorry
	fi
}
# (End vim fold) }}}

# Red belt exercises (Start vim fold) {{{
red_belt_exercise_programs_vs_commands() {
	luc_correct_answers=0

	# Question 1
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 1/2

Which of the following is a valid command by itself?

EOL

	luc_answers=( 'cp' 'mv' 'ls' 'rm' 'aaaiiieee' )
	handle_answer 'ls'

	# Question 2
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 2/2

Which of the following is a program?

EOL

	luc_answers=(
		'du -ah | sort -hr | head'
		'ls -l'
		'cp one.txt two.txt'
		'file'
		'cat tail'
	)
	handle_answer 'file'

	# Final check
	if [ "$luc_correct_answers" == "2" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers out of 2 correct"
		echo ""
		sorry
	fi
}

red_belt_exercise_introduction_to_find() {
	keep_going
}

red_belt_exercise_find_glob() {
	keep_going
}

red_belt_exercise_find_type() {
	keep_going
}

red_belt_exercise_find_mtime() {
	keep_going
}

red_belt_exercise_find_size() {
	keep_going
}

red_belt_exercise_find_grep() {
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 1/1

Which file did you find?

EOL

	luc_correct_answers=0
	luc_answers=( './size/lorem' './size/lorem2' './size/lorem3' './find/lorem2' 'dolor sit amet' )

	handle_answer "./size/lorem"

	# Final check
	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers out of 2 correct"
		echo ""
		sorry
	fi
}

# --- Define Expected Files ---

# Expected files for red-belt/src
declare -a src_files=(
    "Client Agreement"
    "Daily Activity Log"
    "Meeting Minutes"
    "Project Schedule"
    "Team Presentation"
    "Company Policy Manual"
    "Final Summary"
    "Office Correspondence"
    "Quarterly Report"
    "User Instructions"
)

# Expected files for red-belt/vault
declare -a vault_files=(
    "Agent's Secret Notes"
    "Final Secret Objective"
    "Secret Codes List"
    "Secret Mission Briefing"
    "The Secret Message"
    "Classified Secret Data"
    "Hidden Secret Plans"
    "Secret Hideout Map"
    "Secret Project Files"
    "Top Secret Document"
)

# Function to verify directory contents
# Usage: verify_directory_contents <directory_path> <expected_files_array_name>
# Returns 0 on success, 1 on failure
verify_directory_contents() {
    local dir_path="$1"
    local -n expected_files_ref="$2" # Use nameref to access array by name

    local verification_failed=0

    echo "--- Verifying $dir_path ---"

    if [[ ! -d "$dir_path" ]]; then
        echo "Error: Directory '$dir_path' does not exist."
        return 1 # Indicate failure if directory doesn't exist
    fi

    # Create an associative array for efficient lookup of expected files
    declare -A expected_map
    for file in "${expected_files_ref[@]}"; do
        expected_map["$file"]=1
    done

    # 1. Check for missing expected files
    for file in "${expected_files_ref[@]}"; do
        if [[ ! -f "$dir_path/$file" ]]; then
            echo "Error: Missing expected file in '$dir_path': '$file'"
            verification_failed=1
        fi
    done

    # 2. Check for unexpected files
    for found_item in "$dir_path"/*; do
        # We only care about actual files, not directories or special files
        if [[ -f "$found_item" ]]; then
            local filename=$(basename "$found_item")
            if [[ -z "${expected_map["$filename"]}" ]]; then
                echo "Error: Unexpected file found in '$dir_path': '$filename'"
                verification_failed=1
            fi
        fi
    done

    if [[ $verification_failed -eq 0 ]]; then
        echo "All files in '$dir_path' are correct and no unexpected files were found."
        return 0 # Success
    else
        echo "Verification of '$dir_path' failed."
        return 1 # Failure
    fi
}

red_belt_exercise_find_xargs() {
	overall_status=0

	# Verify red-belt/src
	verify_directory_contents "$LUS_HOME/red-belt/src" "src_files"
	if [[ $? -ne 0 ]]; then
	    overall_status=1
	fi

	echo "" # Add a newline for readability

	# Verify red-belt/vault
	verify_directory_contents "$LUS_HOME/red-belt/vault" "vault_files"
	if [[ $? -ne 0 ]]; then
	    overall_status=1
	fi

	# Final overall result
	if [[ $overall_status -eq 0 ]]; then
	    echo -e "\nAll directory verifications passed!"
	else
	    echo -e "\nOne or more directory verifications failed."
	fi

	# --- Call good_work or sorry based on overall status ---
	if [[ $overall_status -eq 0 ]]; then
	    good_work
	else
	    sorry
	fi
}

red_belt_exercise_cat_xargs() {
	keep_going
}

red_belt_exercise_find_or() {
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 1/1

How many files in "$LUS_HOME/red-belt/or" have filenames containing either "secret" or "hidden"?

EOL

	luc_correct_answers=0
	luc_answers=( '0' '12' '18' '30' 'infinity' )
	do_shuffle=
	handle_answer "12"
	do_shuffle=1

	# Final check
	if [ "$luc_correct_answers" == "1" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers out of 1 correct"
		echo ""
		sorry
	fi
}

red_belt_exercise_find_or_not() {
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 1/1

How many files in "$LUS_HOME/red-belt/or" have filenames containing either "secret" or "hidden"?

EOL

	luc_correct_answers=0
	luc_answers=( '0' '12' '18' '30' 'infinity' )
	do_shuffle=
	handle_answer "18"
	do_shuffle=1

	# Final check
	if [ "$luc_correct_answers" == "1" ]; then
		good_work

	else
		echo "Results:  $luc_correct_answers out of 1 correct"
		echo ""
		sorry
	fi
}

red_belt_exercise_find_paths() {
	keep_going
}

red_belt_exercise_find_cleanup() {
	keep_going
}

red_belt_exercise_symlinks_and_canonical_paths() {
	keep_going
}

red_belt_exercise_symlinks() {
	SOURCE_PATH="$LUS_HOME/red-belt/link/source"
	TARGET_PATH="$LUS_HOME/red-belt/link/target"
	if [ -L "$SOURCE_PATH" ]; then
		# Get the *canonical, absolute* target of the symbolic link,
		# resolving all components including bind mounts/chroots.
		# This also covers the Docker container.
		ACTUAL_CANONICAL_TARGET=$(realpath "$SOURCE_PATH")
		EXIT_CODE_ACTUAL=$?

		# Get the *canonical, absolute* path of the expected target,
		# also resolving all components including bind mounts/chroots.
		EXPECTED_CANONICAL_TARGET=$(realpath "$TARGET_PATH")
		EXIT_CODE_EXPECTED=$?

		if [ $EXIT_CODE_ACTUAL -eq 0 ] && [ -n "$ACTUAL_CANONICAL_TARGET" ] && \
				[ $EXIT_CODE_EXPECTED -eq 0 ] && [ -n "$EXPECTED_CANONICAL_TARGET" ]; then
			# Compare the canonical actual target with the canonical expected target
			if [ "$ACTUAL_CANONICAL_TARGET" = "$EXPECTED_CANONICAL_TARGET" ]; then
				echo "Success! '$SOURCE_PATH' is a symbolic link and correctly points to the expected canonical target."
				good_work
			else
				echo "Almost there! '$SOURCE_PATH' is a symbolic link, but its actual canonical target is '$ACTUAL_CANONICAL_TARGET'."
				echo "It should canonically point to '$EXPECTED_CANONICAL_TARGET'."
				echo "This might mean the link points to a similar file on a different underlying mount point."
				sorry
			fi
		else
			echo "Error: Could not determine the canonical paths for comparison."
			echo "This might happen if the link is broken or the target doesn't exist."
			echo "Please ensure the link and its target are valid."
			sorry
		fi
	elif [ -f "$SOURCE_PATH" ]; then
		# Get inode numbers
		original_inode=$(ls -i "$SOURCE_PATH" 2>/dev/null | awk '{print $1}')
		link_inode=$(ls -i "$TARGET_PATH" 2>/dev/null | awk '{print $1}')

		if [ "$TARGET_PATH" -eq "$SOURCE_PATH" ]; then
			echo "'$SOURCE_PATH' has the same inode number ($original_inode) as '$TARGET_PATH'."
			echo "This means you created a hard link, not a symbolic link."
		else
			echo "'$SOURCE_PATH' exists, but it's a regular file, not a symbolic link."
			echo "Remember to use 'ln -s' for symbolic links."
		fi

		sorry
	else
		echo "'$SOURCE_PATH' does not exist."
		echo "Please ensure you create the link with the correct name"
		echo "and in the correct location."
		sorry
	fi
}

red_belt_exercise_final_exam() {
	if ask_review_final_exam; then
		keep_going
		return 0
	fi

	luc_correct_answers=0

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
It's getting close to the end now.  You're going for your black stripe belt.  This exam is likely to be harder than
anything you've faced before.  Don't be embarrased or ashamed if it takes you multiple atttempts, or if you have to
review previous exercises.

Question 1/7

Which command finds files that have the word "secret" in the file's data, case-sensitive, in the current directory and
all subdirectories?

EOL

	luc_answers=( 
'find . -type f -exec grep secret {} \;'
"find . -type f -iname '*secret*'"
"find . -type f -name '*secret*'"
"find . -type f -exec grep secret {}"
"find all secrets"
)

	handle_answer 'find . -type f -exec grep secret {} \;'

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 2/7

What does the following command do (on Linux)?

find . -iname "*secret*" -print0 | xargs -0 mv -t ~/vault

EOL

	luc_answers=( 
"It searches for all files with 'secret' in their name (case-insensitive) in the current directory (and all subdirectories) and moves them to the 'vault' directory inside your home directory."
"It searches for all files with 'secret' in their name (case-insensitive) in the current directory (and all subdirectories) and renames them to be 'vault' inside your home directory."
"It creates a new directory named 'secret' inside ~/vault and copies all files from the current directory that have 'secret' in their name into it."
"It deputizes your computer as a highly efficient 'secret' agent, tasked with rounding up all files with 'secret' in their name (because they can't keep one) and sending them to the ~/vault for highly classified re-education on discretion."
)

	handle_answer "It searches for all files with 'secret' in their name (case-insensitive) in the current directory (and all subdirectories) and moves them to the 'vault' directory inside your home directory."

	# Use single quotes around EOL to treat the content of the here-document literally.
	fmt ${FMT_OPTIONS:-}$luc_width <<'EOL'
Question 3/7

What does the following command do?

find . -type f \! \( -iname "*secret*" -o -iname "*hidden*" \)

EOL

	luc_answers=( 
"It finds all files in the current directory (and all subdirectories) that contain neither 'secret' nor 'hidden' in their name (case-insensitive)."
"It finds all files in the current directory (and all subdirectories) that contain either 'secret' or 'hidden' in their name (case-insensitive)."
"It finds all files in the current directory (and all subdirectories) that contain neither 'secret' nor 'hidden' in their name (case-sensitive)."
"It finds all files in the current directory (and all subdirectories) that contain either 'secret' or 'hidden' in their name (case-sensitive)."
"It diligently searches your current location for all files that haven't mastered the art of being 'secret' or 'hidden,' so they can be registered for remedial camouflage classes."
)

	handle_answer "It finds all files in the current directory (and all subdirectories) that contain neither 'secret' nor 'hidden' in their name (case-insensitive)."

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 4/7

What does the following command do?

find ~ -path "*/apps/webapp/*"

EOL

	luc_answers=( 
"It searches for files and directories that have '/apps/webapp/' somewhere in their path under your home directory."
"It searches for files that contain the string 'webapp' in their content, specifically within 'apps' directories under your home directory."
"It finds all files and folders that are named 'webapp' and are located anywhere within an 'apps' directory under your home directory."
"It finds all subdirectories named 'webapp' that exist within any 'apps' directory under your home directory."
"It helps your computer locate its long-lost 'webapp' child, who ran away to join the 'apps' circus, ensuring it's safely returned to its home directory before sundown."
)

	handle_answer "It searches for files and directories that have '/apps/webapp/' somewhere in their path under your home directory."

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 5/7

What is the canonical path of "/home/user/documents/projects/../.."?

EOL

	luc_answers=( 
"/home/user"
"/home"
"/home/user/documents"
"/home/user/documents/projects"
"There is no canonical path."
)

	handle_answer "/home/user"

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 6/7

What is the canonical path of "/home///user//documents/projects/"?

EOL

	luc_answers=( 
"/home/user/documents/projects"
"/"
"/home/documents"
"/home/projects"
"No resolution to a canonical path is possible."
)

	handle_answer "/home/user/documents/projects"

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Question 7/7

Which command creates a symbolic link from a file called source to a file called target?

EOL

	luc_answers=( 
"ln -s target source"
"ln -s source target"
"ln target source"
"ln source target"
"ln -s imagination real-life"
)

	handle_answer "ln -s target source"

	if [ "$luc_correct_answers" == "7" ]; then
		good_work
	else
		echo "Results:  $luc_correct_answers out of 7 correct"
		echo ""
		echo "See how to look at previous exercises by executing 'learn help'."
		echo ""
		sorry
	fi
}
# (End vim fold) }}}

# Black belt exercises (Start vim fold) {{{
black_stripe_exercise_processes() {
	IFS='
'

	for item in "${luc_history[@]}"
	do
		if [[ "$item" =~ ^[\ ]*ps([ ]|$) ]]; then
			good_work
			unset IFS
			return
		fi
	done

	sorry
	unset IFS
	return
}

black_stripe_exercise_processes_man_info() {
	keep_going
}
# }}}

####################
# End of exercises #
####################

# Function definitions (Vim fold) {{{
belt_complete() {
	rank_exercises_completed=$RANK
	rank_attained=$(getNextBelt $RANK)
	rank_working_towards=$(getNextBelt $rank_attained)

	RANK=$rank_attained
	EXERCISE=1

	echo ""

	if [ -z "${SAVED_RANK:-}" ]; then
		printf "Congratulations!  You have now attained your `getBeltWithColours $RANK`.\n"
		printf "You're working toward your `getBeltWithColours $rank_working_towards`.\n\n"
	else
		printf "You have reviewed all the exercises in `getBeltWithColours $rank_exercises_completed`.\n"
		printf "Execute \"learn\" to start reviewing the `getBeltWithColours $rank_attained` exercises.\n\n"
	fi
}

###############################
# End of function definitions #
###############################
# }}}

# Script execution begins here.  (Vim fold) {{{

# If this script is switched back to being sourced, we'll need to change the "exit"s below to returns.

if [ ! -f "${LUS_PROGRESS}" ]; then
	echo 'Please run the "learn" script first.'
	exit 1
fi

source "${LUS_PROGRESS}"

LUS_HOME=${LUS_HOME:-"$HOME/lus"}

if [ -z "${RANK:-}" ] || [ -z "${EXERCISE:-}" ]; then
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
Please run the "learn" script first.
EOL
	exit 1
fi

# luc = Learn Unix Check
luc_width=`expr $3 - 5`

if [[ ! "${RANK}" =~ ^(white|yellow|green|blue|red|black)_(stripe|belt)$ ]]; then
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
It looks like the ${LUS_PROGRESS} file has become corrupted.  If it can't be repaired, you may have no choice but to delete it
and start over.  Sorry about that.
EOL
	exit 2
fi

if [[ ! "${EXERCISE}" =~ ^[0-9]+$ ]]; then
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
It looks like the ${LUS_PROGRESS} file has become corrupted.  If it can't be repaired, you may have no choice but to delete it
and start over.  Sorry about that.
EOL
	exit 2
fi

luc_regex="'"
luc_regex+="${RANK}_exercise_.*\(\)"
luc_regex+="'"
luc_num_exercises=$(bash -c "grep -E ${luc_regex} ~/bin/learn | wc -l")

exercise_name=${exercises["${RANK}_${EXERCISE}"]:-}

if [ -z "$exercise_name" ]; then
	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
There are no more exercises at this time.  If you like, you can review exercises you've already completed by executing
"learn white belt", "learn yellow stripe", or "learn white belt 6" to start review at a particular exercise.
EOL

	exit 1
fi

skip_exercise=0
if [[ -n "${4:-}" ]] && [[ "${4,,}" == "exam" ]]; then
	if [ -n "${SAVED_EXERCISE:-}" ] || [ -n "${SAVED_RANK:-}" ]; then
		echo "Testing out of a belt can only be done when not reviewing exercises."
		echo "Instead of testing out, find the lesson that has the exam with"
		echo "learn ${RANK/_/ } list, then skip to it.  For more, execute "'"'"learn --help"'"'"."

		exit 1
	else
		if declare -F "${RANK}_test_out" > /dev/null; then
			if ${RANK}_test_out; then
				skip_exercise=1
				EXERCISE=$(( ${luc_num_exercises}+1 ))
			else
				exit 0
			fi
		else
			printf "It's not currently possible to test out of `getBeltWithColours ${RANK}`.\n"
			exit 3
		fi
	fi
fi

if [[ "${skip_exercise}" == "0" ]]; then
	function_name="${RANK}_exercise_${exercise_name}"
	eval $function_name
fi

if [ "${EXERCISE:-}" == "${SAVED_EXERCISE:-}" ] && [ "${SAVED_RANK:-}" == "${RANK:-}" ]; then
	SAVED_RANK=""
	SAVED_EXERCISE=""
	updateDotFile

	fmt ${FMT_OPTIONS:-}$luc_width <<EOL
You were reviewing past exercises and you've caught up to where you were.  Execute "learn" to continue.
EOL
fi

if (($EXERCISE > $luc_num_exercises)); then
	new_belt_number=`expr 1 + ${belt_to_number[$RANK]}`
	new_belt=${number_to_belt[$new_belt_number]}

	if [[ "$new_belt" == "${SAVED_RANK:-}" && "${SAVED_EXERCISE:-}" == "1" ]]; then
		printf "\nYou have reviewed all the exercises in `getBeltWithColours $RANK`.\n"
		printf "You're all caught up.\n"
		printf "Execute \"learn\" to begin the `getBeltWithColours $new_belt` exercises.\n"

		RANK=$SAVED_RANK
		EXERCISE=1
		SAVED_RANK=""
		SAVED_EXERCISE=""

		updateDotFile

		exit 0
	fi

	if [ $RANK == "white_belt" ]; then
		echo ""

		if [ -z "${SAVED_RANK:-}" ]; then
			printf "Congratulations!  You have now attained your `getBeltWithColours yellow_stripe`.\n"
			printf "You are now working toward your `getBeltWithColours yellow_belt`.\n\n"

			fmt ${FMT_OPTIONS:-}$luc_width <<EOL
If you don't consider yourself to be detail oriented, the last few yellow stripe exercises may be challenging.  If you need
caffeine, a good night's sleep, or a hearty breakfast to be on top of your game, consider doing that.  If you're a morning
person (or a night owl) and you can do the exercises in the morning (or at night), consider doing that.

From here on out, only the first exercise of each belt will prompt you to execute "learn" and ". check", unless it's needed
for clarity.
EOL

			RANK=yellow_stripe
			EXERCISE=1
		else
			printf "You have reviewed all the exercises in `getBeltWithColours white_belt`.\n"
			printf "Execute \"learn\" to start reviewing the `getBeltWithColours yellow_stripe` exercises.\n"

			RANK=yellow_stripe
			EXERCISE=1
		fi
	elif [ $RANK == "yellow_stripe" ]; then
		belt_complete
	elif [ $RANK == "yellow_belt" ]; then
		belt_complete
	else
		rank_exercises_completed=$RANK
		rank_attained=$(getNextBelt $RANK)
		rank_working_towards=$(getNextBelt $rank_attained)

		RANK=$rank_attained
		EXERCISE=1

		if [ -z "${SAVED_RANK:-}" ]; then
			printf "Congratulations!  You have now attained your `getBeltWithColours $rank_attained`.\n"
			printf "You would be working toward your `getBeltWithColours $rank_working_towards`, but there are no more exercises.\n\n"
		else
			printf "You have reviewed all the exercises in `getBeltWithColours $rank_exercises_completed`.\n"
			printf "There are no more exercises at this time.\n\n"

			SAVED_RANK=""
			SAVED_EXERCISE=""
		fi
	fi
fi

updateDotFile

# }}}
# vim: set foldmethod=marker:
